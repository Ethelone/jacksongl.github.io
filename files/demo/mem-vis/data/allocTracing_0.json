{
  "allocations":[
    {
    "src":{"function":"Anonymous function", "line":1487, "column":4, "fileId":35},
    "allocInfo":{"count":1, "estimatedSize":32},
    "objectIds":[38770798464]
    }, 
    {
    "src":{"function":"Anonymous function", "line":2043, "column":4, "fileId":35},
    "allocInfo":{"count":1, "estimatedSize":230},
    "objectIds":[38770804032]
    }, 
    {
    "src":{"function":"BigInteger", "line":57, "column":8, "fileId":35},
    "allocInfo":{"count":2, "estimatedSize":64},
    "objectIds":[38765133456, 38765133568]
    }, 
    {
    "src":{"function":"Anonymous function", "line":2091, "column":12, "fileId":35},
    "allocInfo":{"count":1, "estimatedSize":128},
    "objectIds":[38780372000]
    }, 
    {
    "src":{"function":"Anonymous function", "line":2086, "column":4, "fileId":35},
    "allocInfo":{"count":5, "estimatedSize":312},
    "objectIds":[38779568768, 38762605392, 38770787584, 38724766720, 38770787504]
    }, 
    {
    "src":{"function":"Anonymous function", "line":2092, "column":12, "fileId":35},
    "allocInfo":{"count":3, "estimatedSize":278},
    "objectIds":[38763281328, 38780372048, 38780237152]
    }, 
    {
    "src":{"function":"Anonymous function", "line":163, "column":4, "fileId":35},
    "allocInfo":{"count":1, "estimatedSize":32},
    "objectIds":[38765133680]
    }, 
    {
    "src":{"function":"Anonymous function", "line":52, "column":4, "fileId":35},
    "allocInfo":{"count":125, "estimatedSize":6016},
    "objectIds":[38769507712, 38769520352, 38769506176, 38769523520, 38769515648, 38769518816, 38769504640, 38769521984, 38769520448, 38769507840, 38769523616, 38769515744, 38769518912, 38769506304, 38769522080, 38769514208, 38769504768, 38769520544, 38769523712, 38769515840, 38769503232, 38769507968, 38769519008, 38769522176, 38769506432, 38769520640, 38769504896, 38769523808, 38769515936, 38769519104, 38769503360, 38769522272, 38769508096, 38769517568, 38769497088, 38769520736, 38769506560, 38768540480, 38769523904, 38769516032, 38769519200, 38769505024, 38768538944, 38769522368, 38769503488, 38769520832, 38769524000, 38769516128, 38769519296, 38769506688, 38769522464, 38769517760, 38769505152, 38769520928, 38769524096, 38769503616, 38769519392, 38769522560, 38769506816, 38769521024, 38769505280, 38769524192, 38769519488, 38769503744, 38769522656, 38768534528, 38768537696, 38769521120, 38769506944, 38768532992, 38769519584, 38769505408, 38769522752, 38769503872, 38769521216, 38769524384, 38769508640, 38769519680, 38769507072, 38769522848, 38769518144, 38769505536, 38769521312, 38769524480, 38769504000, 38769519776, 38769522944, 38769507200, 38769518240, 38769521408, 38769505664, 38769519872, 38769504128, 38769523040, 38769518336, 38769521504, 38769507328, 38768541248, 38769519968, 38769505792, 38769523136, 38769518432, 38769504256, 38769521600, 38769520064, 38769507456, 38769523232, 38769518528, 38769505920, 38769521696, 38768541440, 38769504384, 38769520160, 38769523328, 38769507584, 38769518624, 38769521792, 38769506048, 38769520256, 38768540000, 38769504512, 38769523424, 38769515552, 38769518720, 38769521888]
    }, 
    {
    "src":{"function":"Anonymous function", "line":2093, "column":12, "fileId":35},
    "allocInfo":{"count":427, "estimatedSize":14382},
    "objectIds":[38780401920, 38762113728, 38761637920, 38780388160, 38764927328, 38764903200, 38762048256, 38780395072, 38764899808, 38762100032, 38780391680, 38780377904, 38780398592, 38780402048, 38761634592, 38763606848, 38762117312, 38769075392, 38761641536, 38764899904, 38763603456, 38764889568, 38764924064, 38761944992, 38769434048, 38780388352, 38764927520, 38762155328, 38780391808, 38764903392, 38780395264, 38763351808, 38780402176, 38761638176, 38761945056, 38766206784, 38764900000, 38729358016, 38769165184, 38780398784, 38770771968, 38764903488, 38764531104, 38760438336, 38763531200, 38759393600, 38780388480, 38759383264, 38780391936, 38780395392, 38761638272, 38764538048, 38763351936, 38764900096, 38764924256, 38764927712, 38769079104, 38764903584, 38767979200, 38763596800, 38760745312, 38780402368, 38761628032, 38764900192, 38780392064, 38780395520, 38780398976, 38764903680, 38762117696, 38780388672, 38765107136, 38763348672, 38759393824, 38762614272, 38763607296, 38764924448, 38764927904, 38764900320, 38780392192, 38780395648, 38762855680, 38763352192, 38780378432, 38762117824, 38761638560, 38756549312, 38760800704, 38780388800, 38764903840, 38763348800, 38780399168, 38762166144, 38768565632, 38764924576, 38764900448, 38780395776, 38761611072, 38763597120, 38762166208, 38764872896, 38762162784, 38780388928, 38764928096, 38780392384, 38760752576, 38763348928, 38780399296, 38762118016, 38761897344, 38764900576, 38764541984, 38764931616, 38764904032, 38780395904, 38759394144, 38756590944, 38780389056, 38761638848, 38763597312, 38780399424, 38760759616, 38764900672, 38762114688, 38722862656, 38764435200, 38763542176, 38762935328, 38762166432, 38764883456, 38760387264, 38764928288, 38728310528, 38780392576, 38764904160, 38730134528, 38780396032, 38761638944, 38728386432, 38780389184, 38764900768, 38780399552, 38761863104, 38769176320, 38762114816, 38764904256, 38759394368, 38761987264, 38769079808, 38780392704, 38780396160, 38764900864, 38780403072, 38722855968, 38760759840, 38780389312, 38764928480, 38764904352, 38764935392, 38763349312, 38780399680, 38763263136, 38761639136, 38728386624, 38722859488, 38764900960, 38764525152, 38780403200, 38765149248, 38769179968, 38780389440, 38780392896, 38780396352, 38760397952, 38780399808, 38759394592, 38760760032, 38764928672, 38762625408, 38763597760, 38763352960, 38764901120, 38780403328, 38760391136, 38730076352, 38780396480, 38769169792, 38780399936, 38762115200, 38762642752, 38722859744, 38780389632, 38780393088, 38764894336, 38761598048, 38760384352, 38760760192, 38728400736, 38764925408, 38759394816, 38764928864, 38764901280, 38759387936, 38780396608, 38780400064, 38763601408, 38762115328, 38730190304, 38762118784, 38763363520, 38780389760, 38780393216, 38764522080, 38763529056, 38764901376, 38761632704, 38761636160, 38780396736, 38764929024, 38780403648, 38769076992, 38780389888, 38764901472, 38780393344, 38764539456, 38780400256, 38760760448, 38762884416, 38764529120, 38759398496, 38761636256, 38761594880, 38728383744, 38763249952, 38780396864, 38763598208, 38764901568, 38780383088, 38768570240, 38763539616, 38760753632, 38764925728, 38764929184, 38762101824, 38780393472, 38722853248, 38780383136, 38729397568, 38759398624, 38762622528, 38780390080, 38780383184, 38761636416, 38780396992, 38780400448, 38764929280, 38780383232, 38764881024, 38764901728, 38728477056, 38764925888, 38780383280, 38763246720, 38761636512, 38763363968, 38780390208, 38730090784, 38780393664, 38761995136, 38780383328, 38780400576, 38762115840, 38764925984, 38764929440, 38780383376, 38728480640, 38780397184, 38762633088, 38760774624, 38780383424, 38780390336, 38764901920, 38722850112, 38780393792, 38761636672, 38780400704, 38780383472, 38761995328, 38763236608, 38729394496, 38768567232, 38764874432, 38764926176, 38762043648, 38780390464, 38764929632, 38764902048, 38780393920, 38780369792, 38780397376, 38762881536, 38760747232, 38766508864, 38780400896, 38759395680, 38764902144, 38780383664, 38763357440, 38762160992, 38761995488, 38761636896, 38764898720, 38780390592, 38766212416, 38780394048, 38780369920, 38764536704, 38780383712, 38761602464, 38762116224, 38764926368, 38764902240, 38762630016, 38780397568, 38763612704, 38780401024, 38730094720, 38729353408, 38780390720, 38780394176, 38780370048, 38764898880, 38780383856, 38761995680, 38780387328, 38759395904, 38764902368, 38780383904, 38780401152, 38763250816, 38764926560, 38780390848, 38780383952, 38780394304, 38780397760, 38764933504, 38780384000, 38759427072, 38761637248, 38780370240, 38780401280, 38780384048, 38762116544, 38730201856, 38780390976, 38764902560, 38761868320, 38762102784, 38780394432, 38780384096, 38763602688, 38780387584, 38764926752, 38759396160, 38780384144, 38762875200, 38728477952, 38780397952, 38729384800, 38780384192, 38760744384, 38756592992, 38761637440, 38780370432, 38766495680, 38780401472, 38764902720, 38763620064, 38780384240, 38764892384, 38756606848, 38780387712, 38761823680, 38780391168, 38780394624, 38780398080, 38764526944, 38760389344, 38761892672, 38763261536, 38763358080, 38728385024, 38763544288, 38764926944, 38764902816, 38780370560, 38780401600, 38762116864, 38759392960, 38730195296, 38780387840, 38780391296, 38764902912, 38780394816, 38762051456, 38761637696, 38780370688, 38780398272, 38762116992, 38769430208, 38780387968, 38764927136, 38762927296, 38780391424, 38764903008, 38762841120, 38780401792, 38760761984, 38764534112, 38763361792, 38780394944, 38760755136, 38780370816, 38780398400, 38763358400, 38763534272, 38728309504, 38780391552]
    }, 
    {
    "src":{"function":"Anonymous function", "line":1312, "column":4, "fileId":35},
    "allocInfo":{"count":2, "estimatedSize":102},
    "objectIds":[38756625216, 38761640128]
    }, 
    {
    "src":{"function":"bnToString", "line":287, "column":23, "fileId":35},
    "allocInfo":{"count":1, "estimatedSize":520},
    "objectIds":[38776651584]
    }, 
    {
    "src":{"function":"Anonymous function", "line":1723, "column":4, "fileId":35},
    "allocInfo":{"count":2, "estimatedSize":86},
    "objectIds":[38756625472, 38761639744]
    }, 
    {
    "src":{"function":"Anonymous function", "line":1801, "column":4, "fileId":35},
    "allocInfo":{"count":2, "estimatedSize":88},
    "objectIds":[38761639488, 38756625728]
    }, 
    {
    "src":{"function":"prng_newstate", "line":1728, "column":8, "fileId":35},
    "allocInfo":{"count":1, "estimatedSize":56},
    "objectIds":[38770796944]
    }, 
    {
    "src":{"function":"Anonymous function", "line":1210, "column":4, "fileId":35},
    "allocInfo":{"count":2, "estimatedSize":94},
    "objectIds":[38756624960, 38761640384]
    }, 
    {
    "src":{"function":"Anonymous function", "line":2087, "column":8, "fileId":35},
    "allocInfo":{"count":894, "estimatedSize":141912},
    "objectIds":[38780214464, 38761800448, 38780183584, 38762603760, 38780183616, 38780322656, 38724740768, 38780229984, 38780183648, 38780214560, 38780183680, 38762603856, 38780183712, 38724740864, 38780183744, 38780230096, 38780214656, 38780291904, 38780152896, 38780152928, 38762604000, 38780214752, 38780152960, 38780230208, 38724741008, 38780152992, 38766234352, 38780153024, 38762604096, 38780214848, 38780153056, 38724741104, 38780153088, 38780292128, 38762604192, 38780214944, 38724741200, 38780230432, 38762604288, 38761801008, 38780215040, 38724741296, 38762604384, 38766234672, 38780292352, 38780215136, 38724741392, 38762604480, 38780215232, 38724741488, 38766234832, 38780230768, 38780292576, 38724741584, 38761801344, 38780261760, 38780215424, 38780230880, 38724741680, 38780339072, 38780230992, 38724741776, 38780292800, 38724741872, 38780231104, 38780215680, 38780262080, 38724741968, 38780231216, 38780293024, 38780246720, 38766235392, 38724742064, 38780231328, 38780215904, 38766235472, 38761801904, 38724742160, 38780231440, 38780293248, 38724742256, 38780262400, 38780154272, 38766235632, 38760767040, 38780154304, 38780231552, 38760767072, 38724742352, 38722486944, 38780216128, 38780154336, 38780154368, 38780154400, 38780247104, 38780231664, 38724742448, 38780293472, 38722487056, 38762605584, 38724742544, 38780231776, 38780216352, 38762605632, 38766235952, 38762605680, 38724742640, 38780231888, 38762605728, 38780293696, 38722487280, 38780247360, 38761802464, 38762605776, 38724742736, 38762605824, 38780232000, 38780216576, 38762605872, 38724742832, 38762605920, 38780232112, 38780293920, 38762605968, 38724742928, 38766236272, 38762606016, 38780232224, 38762606064, 38724743024, 38780216800, 38761802800, 38762606112, 38762606160, 38780232336, 38724743120, 38780294144, 38762606208, 38762606256, 38724743216, 38780232448, 38722487840, 38780217024, 38762606304, 38760397248, 38759393152, 38762606352, 38724743312, 38766236672, 38780232560, 38762606400, 38761803136, 38762606448, 38724743408, 38780294432, 38762606496, 38780294464, 38780232672, 38780217248, 38762606544, 38766236832, 38724743504, 38762606592, 38759393408, 38780232784, 38780294592, 38762606640, 38724743600, 38730088640, 38762606688, 38730088672, 38780356480, 38780232896, 38762606736, 38724743696, 38780217472, 38780155680, 38780294720, 38730088736, 38762606784, 38780155712, 38780155744, 38759393632, 38762606832, 38724743792, 38780155776, 38762606880, 38780155808, 38762606928, 38779568832, 38724743888, 38780217696, 38762606976, 38761803696, 38762607024, 38724743984, 38759393856, 38780295008, 38779568960, 38780233232, 38762607072, 38780295040, 38780295072, 38762607120, 38724744080, 38780295104, 38762607168, 38780295136, 38766237472, 38780217920, 38762607216, 38780187040, 38761803920, 38724744176, 38779569152, 38762607264, 38759394080, 38780233456, 38762607312, 38724744272, 38762607360, 38780295360, 38762607408, 38724744368, 38722488960, 38780218144, 38762607456, 38759394304, 38762607504, 38724744464, 38762607552, 38762607600, 38724744560, 38780233792, 38780218368, 38762607648, 38762607696, 38724744656, 38759394528, 38780295680, 38770810608, 38780233904, 38762607744, 38780295712, 38780342080, 38780295744, 38762607792, 38724744752, 38762607840, 38780218592, 38762607888, 38724744848, 38729394720, 38762607936, 38759394752, 38729394752, 38762607984, 38780187808, 38766238272, 38724744944, 38780295968, 38780187840, 38729394816, 38762608032, 38729394848, 38780234240, 38762608080, 38729394880, 38724745040, 38780218816, 38762608128, 38759394976, 38761634944, 38762608176, 38780234352, 38724745136, 38761634976, 38762608224, 38762608272, 38724745232, 38780219040, 38762608320, 38780203632, 38780296320, 38762608368, 38724745328, 38759395200, 38760383872, 38762608416, 38760754656, 38780157376, 38762608464, 38724745424, 38780296448, 38780188320, 38762608512, 38780219264, 38780296512, 38762608560, 38724745520, 38780296544, 38762608608, 38759395424, 38780296576, 38780188448, 38766238912, 38762608656, 38724745616, 38780188512, 38762608704, 38780296672, 38780188544, 38762608752, 38780188576, 38724745712, 38780219488, 38762608800, 38759395648, 38762608848, 38724745808, 38762608896, 38780296864, 38780188736, 38762608944, 38724745904, 38780204256, 38780219712, 38762608992, 38780296960, 38780204304, 38779617280, 38762609040, 38780188864, 38724746000, 38759395872, 38780297056, 38779617376, 38762609136, 38724746096, 38780235360, 38780189024, 38780219936, 38779617472, 38762609232, 38724746192, 38759396096, 38780189120, 38780235472, 38780343616, 38779617568, 38762609328, 38724746288, 38729396192, 38760755648, 38762609424, 38724746384, 38780220160, 38780189280, 38729396256, 38780204736, 38780204784, 38780297472, 38762609520, 38724746480, 38780189376, 38766239872, 38780297568, 38762609616, 38724746576, 38729396448, 38724731168, 38780220384, 38769499520, 38762609712, 38780189536, 38724746672, 38759396544, 38762609808, 38780189632, 38724746768, 38769499648, 38780220608, 38762609904, 38769499776, 38780189792, 38762610000, 38759396864, 38780359808, 38780189888, 38780143552, 38780298048, 38728392768, 38769499904, 38762610096, 38780143584, 38780220832, 38780298080, 38780143616, 38780298112, 38780143648, 38762610192, 38780143680, 38769500032, 38780190048, 38780143712, 38724731744, 38780143744, 38762610288, 38780143776, 38780298272, 38780190144, 38780143808, 38724731840, 38780221056, 38769500160, 38779618624, 38762610384, 38724731936, 38759397248, 38780298400, 38769500288, 38780190304, 38762610480, 38724732032, 38766240832, 38779618816, 38780190400, 38762610576, 38780298560, 38769500416, 38756585888, 38724732128, 38780221344, 38780221376, 38779618912, 38756585952, 38759397504, 38780298656, 38724732224, 38769500544, 38780190560, 38762595312, 38779619008, 38780221504, 38766241072, 38724732320, 38780190656, 38779619104, 38769500672, 38780237040, 38724732416, 38780221632, 38780175296, 38779619200, 38780175328, 38759397792, 38780175360, 38769500800, 38762595552, 38724732512, 38779619296, 38724732608, 38769500928, 38779619392, 38762595744, 38724732704, 38780221920, 38759398016, 38780360960, 38780221952, 38780299200, 38779619488, 38769501056, 38780221984, 38730093248, 38724732800, 38780222016, 38730093280, 38780222048, 38779619584, 38769501184, 38724732896, 38779619680, 38724763840, 38780222176, 38779573376, 38724732992, 38769501312, 38779619776, 38762596080, 38780222272, 38780145056, 38724733088, 38780145088, 38779619872, 38769501440, 38780145120, 38780222368, 38759398464, 38724733184, 38779619968, 38762596272, 38780222464, 38759398560, 38769501568, 38724733280, 38762596368, 38724764224, 38766242112, 38780222560, 38724733376, 38769501696, 38779620160, 38762596464, 38724764320, 38780207200, 38780222656, 38730202048, 38724733472, 38779620256, 38769501824, 38780207296, 38729398848, 38724733568, 38779620352, 38724764512, 38769501952, 38724733664, 38729398976, 38780207456, 38760387680, 38779620448, 38724764608, 38724733760, 38769502080, 38780207552, 38779620544, 38724764704, 38766242592, 38724733856, 38780145856, 38779620640, 38769502208, 38780145888, 38780207712, 38780145920, 38724733952, 38780145952, 38780223200, 38779620736, 38769502336, 38780207808, 38769131600, 38724734048, 38780223296, 38779620832, 38724734144, 38769502464, 38780223392, 38779620928, 38724765088, 38780207968, 38766242992, 38724734240, 38780223488, 38779621024, 38769502592, 38780208064, 38760743584, 38779651968, 38724734336, 38779621120, 38780223600, 38724765280, 38769502720, 38724734432, 38780208224, 38779652096, 38780223712, 38724734528, 38769502848, 38780208320, 38779621312, 38780223824, 38724734624, 38730095104, 38779652288, 38780208480, 38724734720, 38780223936, 38780193120, 38780208576, 38762597856, 38724734816, 38780224048, 38724765760, 38760388864, 38724734912, 38780224160, 38780208736, 38762598048, 38724735008, 38760759776, 38780224272, 38780208832, 38779575488, 38762598144, 38780177984, 38780178016, 38762598240, 38780208992, 38760759968, 38762598336, 38780209088, 38760760064, 38762598432, 38780224608, 38766244192, 38770816800, 38760760160, 38780209248, 38762598528, 38766244272, 38780224720, 38779622272, 38760760288, 38780209344, 38762598624, 38760760320, 38760760352, 38779622368, 38760760384, 38766244432, 38762598720, 38760760416, 38779622464, 38766244512, 38780209504, 38760760480, 38762598816, 38779576192, 38779622560, 38780209600, 38780225056, 38762598912, 38779622656, 38760760672, 38780225168, 38762599008, 38766244752, 38780209760, 38779622752, 38762599104, 38779622848, 38779576512, 38762599200, 38779622944, 38780210016, 38780210048, 38780225504, 38779623040, 38761796080, 38766245152, 38779623136, 38780210176, 38779623232, 38762599536, 38780225728, 38766245312, 38780210304, 38761796304, 38779623328, 38780225840, 38722496688, 38779623424, 38762599728, 38760761440, 38780225952, 38779623520, 38780210592, 38730097280, 38780210624, 38730097312, 38779623616, 38762599920, 38761796640, 38730097376, 38780226176, 38779623712, 38762600016, 38780210752, 38780179904, 38779623808, 38762600112, 38760391072, 38780210880, 38779623904, 38762600208, 38724737168, 38779624000, 38762600304, 38724737264, 38780226512, 38780149280, 38766246112, 38780149312, 38761797088, 38779624096, 38762600400, 38724737360, 38780149344, 38780365632, 38780211168, 38780149376, 38780226624, 38760762144, 38780211200, 38722497472, 38780149408, 38762600496, 38724737456, 38780149440, 38766246272, 38780149472, 38780226736, 38780149504, 38779624288, 38762600592, 38724737552, 38780211328, 38780226848, 38779624384, 38762600688, 38724737648, 38780211456, 38779624480, 38762600784, 38724737744, 38780226960, 38722497808, 38779624576, 38762600880, 38724737840, 38780227072, 38760762624, 38779624672, 38762600976, 38780227184, 38766246752, 38780211744, 38724737984, 38722498032, 38780211776, 38780289024, 38779624768, 38762601072, 38780211808, 38724738080, 38780227296, 38780211872, 38722498144, 38780289120, 38779624864, 38762601168, 38724738176, 38780181056, 38780227408, 38780289216, 38780181088, 38762601264, 38730191392, 38730191424, 38766231632, 38780289312, 38780227520, 38779625056, 38762601360, 38766247152, 38780289408, 38762601456, 38780227632, 38761798208, 38780289504, 38762601552, 38780212288, 38780227744, 38780212320, 38722498592, 38780289600, 38780181472, 38762601648, 38766247392, 38780227856, 38780212448, 38780289696, 38762601744, 38780227968, 38766247552, 38780212544, 38780289792, 38730191936, 38761798544, 38762601840, 38724738800, 38780228080, 38780212640, 38780289888, 38762601936, 38724738896, 38780212736, 38780228192, 38762602032, 38724738992, 38761798768, 38780212832, 38780290080, 38762602128, 38724739088, 38780228304, 38780212928, 38762602224, 38724739184, 38780228416, 38780166656, 38761798992, 38762602320, 38724739280, 38780228528, 38780290336, 38722499376, 38761799104, 38780166784, 38762602416, 38724739424, 38780228640, 38779626208, 38762602512, 38724739520, 38780228752, 38780290560, 38780166976, 38779626304, 38724739616, 38780228864, 38722855040, 38724739712, 38780213504, 38780228976, 38780290784, 38724739808, 38780213600, 38780229088, 38780321792, 38724739904, 38780213696, 38780321840, 38780321888, 38780229200, 38780291008, 38724740000, 38780213792, 38780321936, 38780321984, 38780229312, 38780213888, 38780322032, 38780322080, 38780229424, 38780213984, 38780322128, 38780291232, 38761800000, 38780322176, 38780214080, 38780322224, 38761800112, 38780322272, 38780214176, 38780322320, 38780291456, 38780214272, 38780322416, 38780229760, 38780183424, 38780322464, 38780183456, 38761800336, 38780214368, 38780183488, 38762603664, 38780183520, 38780322560, 38780291680, 38780183552]
    }, 
    {
    "src":{"function":"nbi", "line":66, "column":8, "fileId":35},
    "allocInfo":{"count":2, "estimatedSize":112},
    "objectIds":[38770798704, 38770798944]
    }, 
    {
    "src":{"function":"Anonymous function", "line":696, "column":4, "fileId":35},
    "allocInfo":{"count":2, "estimatedSize":116},
    "objectIds":[38761640992, 38756623744]
    }, 
    {
    "src":{"function":"Anonymous function", "line":734, "column":4, "fileId":35},
    "allocInfo":{"count":2, "estimatedSize":628},
    "objectIds":[38761640736, 38756624000]
    }, 
    {
    "src":{"function":"Anonymous function", "line":147, "column":4, "fileId":35},
    "allocInfo":{"count":1, "estimatedSize":48},
    "objectIds":[38768532704]
    }, 
    {
    "src":{"function":"Arcfour", "line":1695, "column":8, "fileId":35},
    "allocInfo":{"count":1, "estimatedSize":32},
    "objectIds":[38765132112]
    }, 
    {
    "src":{"function":"Anonymous function", "line":1890, "column":4, "fileId":35},
    "allocInfo":{"count":2, "estimatedSize":132},
    "objectIds":[38756625984, 38761639232]
    }, 
    {
    "src":{"function":"Anonymous function", "line":596, "column":4, "fileId":35},
    "allocInfo":{"count":2, "estimatedSize":102},
    "objectIds":[38761641248, 38756623488]
    }, 
    {
    "src":{"function":"Anonymous function", "line":1762, "column":8, "fileId":35},
    "allocInfo":{"count":1, "estimatedSize":32},
    "objectIds":[38765133344]
    }
    ],
  "fileToSourceMap":[{"fileId":1, "filename":"path.js", "source":"(function (exports, require, module, __filename, __dirname) { // Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst inspect = require('util').inspect;\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + inspect(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringWin32(path, allowAboveRoot) {\n  var res = '';\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47/*/*/ || code === 92/*\\*/)\n      break;\n    else\n      code = 47/*/*/;\n    if (code === 47/*/*/ || code === 92/*\\*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 ||\n            res.charCodeAt(res.length - 1) !== 46/*.*/ ||\n            res.charCodeAt(res.length - 2) !== 46/*.*/) {\n          if (res.length > 2) {\n            const start = res.length - 1;\n            var j = start;\n            for (; j >= 0; --j) {\n              if (res.charCodeAt(j) === 92/*\\*/)\n                break;\n            }\n            if (j !== start) {\n              if (j === -1)\n                res = '';\n              else\n                res = res.slice(0, j);\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '\\\\..';\n          else\n            res = '..';\n        }\n      } else {\n        if (res.length > 0)\n          res += '\\\\' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46/*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47/*/*/)\n      break;\n    else\n      code = 47/*/*/;\n    if (code === 47/*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 ||\n            res.charCodeAt(res.length - 1) !== 46/*.*/ ||\n            res.charCodeAt(res.length - 2) !== 46/*.*/) {\n          if (res.length > 2) {\n            const start = res.length - 1;\n            var j = start;\n            for (; j >= 0; --j) {\n              if (res.charCodeAt(j) === 47/*/*/)\n                break;\n            }\n            if (j !== start) {\n              if (j === -1)\n                res = '';\n              else\n                res = res.slice(0, j);\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46/*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  const dir = pathObject.dir || pathObject.root;\n  const base = pathObject.base ||\n    ((pathObject.name || '') + (pathObject.ext || ''));\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nconst win32 = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedDevice = '';\n    var resolvedTail = '';\n    var resolvedAbsolute = false;\n\n    for (var i = arguments.length - 1; i >= -1; i--) {\n      var path;\n      if (i >= 0) {\n        path = arguments[i];\n      } else if (!resolvedDevice) {\n        path = process.cwd();\n      } else {\n        // Windows has the concept of drive-specific current working\n        // directories. If we've resolved a drive letter but not yet an\n        // absolute path, get cwd for that drive, or the process cwd if\n        // the drive cwd is not available. We're sure the device is not\n        // a UNC path at this points, because UNC paths are always absolute.\n        path = process.env['=' + resolvedDevice] || process.cwd();\n\n        // Verify that a cwd was found and that it actually points\n        // to our drive. If not, default to the drive's root.\n        if (path === undefined ||\n            path.slice(0, 3).toLowerCase() !==\n              resolvedDevice.toLowerCase() + '\\\\') {\n          path = resolvedDevice + '\\\\';\n        }\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      var len = path.length;\n      var rootEnd = 0;\n      var code = path.charCodeAt(0);\n      var device = '';\n      var isAbsolute = false;\n\n      // Try to match a root\n      if (len > 1) {\n        if (code === 47/*/*/ || code === 92/*\\*/) {\n          // Possible UNC root\n\n          // If we started with a separator, we know we at least have an\n          // absolute path of some kind (UNC or otherwise)\n          isAbsolute = true;\n\n          code = path.charCodeAt(1);\n          if (code === 47/*/*/ || code === 92/*\\*/) {\n            // Matched double path separator at beginning\n            var j = 2;\n            var last = j;\n            // Match 1 or more non-path separators\n            for (; j < len; ++j) {\n              code = path.charCodeAt(j);\n              if (code === 47/*/*/ || code === 92/*\\*/)\n                break;\n            }\n            if (j < len && j !== last) {\n              const firstPart = path.slice(last, j);\n              // Matched!\n              last = j;\n              // Match 1 or more path separators\n              for (; j < len; ++j) {\n                code = path.charCodeAt(j);\n                if (code !== 47/*/*/ && code !== 92/*\\*/)\n                  break;\n              }\n              if (j < len && j !== last) {\n                // Matched!\n                last = j;\n                // Match 1 or more non-path separators\n                for (; j < len; ++j) {\n                  code = path.charCodeAt(j);\n                  if (code === 47/*/*/ || code === 92/*\\*/)\n                    break;\n                }\n                if (j === len) {\n                  // We matched a UNC root only\n\n                  device = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last);\n                  rootEnd = j;\n                } else if (j !== last) {\n                  // We matched a UNC root with leftovers\n\n                  device = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last, j);\n                  rootEnd = j;\n                }\n              }\n            }\n          } else {\n            rootEnd = 1;\n          }\n        } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||\n                   (code >= 97/*a*/ && code <= 122/*z*/)) {\n          // Possible device root\n\n          code = path.charCodeAt(1);\n          if (path.charCodeAt(1) === 58/*:*/) {\n            device = path.slice(0, 2);\n            rootEnd = 2;\n            if (len > 2) {\n              code = path.charCodeAt(2);\n              if (code === 47/*/*/ || code === 92/*\\*/) {\n                // Treat separator following drive name as an absolute path\n                // indicator\n                isAbsolute = true;\n                rootEnd = 3;\n              }\n            }\n          }\n        }\n      } else if (code === 47/*/*/ || code === 92/*\\*/) {\n        // `path` contains just a path separator\n        rootEnd = 1;\n        isAbsolute = true;\n      }\n\n      if (device.length > 0 &&\n          resolvedDevice.length > 0 &&\n          device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n        // This path points to another device so it is not applicable\n        continue;\n      }\n\n      if (resolvedDevice.length === 0 && device.length > 0) {\n        resolvedDevice = device;\n      }\n      if (!resolvedAbsolute) {\n        resolvedTail = path.slice(rootEnd) + '\\\\' + resolvedTail;\n        resolvedAbsolute = isAbsolute;\n      }\n\n      if (resolvedDevice.length > 0 && resolvedAbsolute) {\n        break;\n      }\n    }\n\n    // At this point the path should be resolved to a full absolute path,\n    // but handle relative paths to be safe (might happen when process.cwd()\n    // fails)\n\n    // Normalize the tail path\n    resolvedTail = normalizeStringWin32(resolvedTail, !resolvedAbsolute);\n\n    return (resolvedDevice + (resolvedAbsolute ? '\\\\' : '') + resolvedTail) ||\n           '.';\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    var rootEnd = 0;\n    var code = path.charCodeAt(0);\n    var device;\n    var isAbsolute = false;\n\n    // Try to match a root\n    if (len > 1) {\n      if (code === 47/*/*/ || code === 92/*\\*/) {\n        // Possible UNC root\n\n        // If we started with a separator, we know we at least have an absolute\n        // path of some kind (UNC or otherwise)\n        isAbsolute = true;\n\n        code = path.charCodeAt(1);\n        if (code === 47/*/*/ || code === 92/*\\*/) {\n          // Matched double path separator at beginning\n          var j = 2;\n          var last = j;\n          // Match 1 or more non-path separators\n          for (; j < len; ++j) {\n            code = path.charCodeAt(j);\n            if (code === 47/*/*/ || code === 92/*\\*/)\n              break;\n          }\n          if (j < len && j !== last) {\n            const firstPart = path.slice(last, j);\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            for (; j < len; ++j) {\n              code = path.charCodeAt(j);\n              if (code !== 47/*/*/ && code !== 92/*\\*/)\n                break;\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              for (; j < len; ++j) {\n                code = path.charCodeAt(j);\n                if (code === 47/*/*/ || code === 92/*\\*/)\n                  break;\n              }\n              if (j === len) {\n                // We matched a UNC root only\n                // Return the normalized version of the UNC root since there\n                // is nothing left to process\n\n                return '\\\\\\\\' + firstPart + '\\\\' + path.slice(last) + '\\\\';\n              } else if (j !== last) {\n                // We matched a UNC root with leftovers\n\n                device = '\\\\\\\\' + firstPart + '\\\\' + path.slice(last, j);\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||\n                 (code >= 97/*a*/ && code <= 122/*z*/)) {\n        // Possible device root\n\n        code = path.charCodeAt(1);\n        if (path.charCodeAt(1) === 58/*:*/) {\n          device = path.slice(0, 2);\n          rootEnd = 2;\n          if (len > 2) {\n            code = path.charCodeAt(2);\n            if (code === 47/*/*/ || code === 92/*\\*/) {\n              // Treat separator following drive name as an absolute path\n              // indicator\n              isAbsolute = true;\n              rootEnd = 3;\n            }\n          }\n        }\n      }\n    } else if (code === 47/*/*/ || code === 92/*\\*/) {\n      // `path` contains just a path separator, exit early to avoid unnecessary\n      // work\n      return '\\\\';\n    }\n\n    code = path.charCodeAt(len - 1);\n    var trailingSeparator = (code === 47/*/*/ || code === 92/*\\*/);\n    var tail;\n    if (rootEnd < len)\n      tail = normalizeStringWin32(path.slice(rootEnd), !isAbsolute);\n    else\n      tail = '';\n    if (tail.length === 0 && !isAbsolute)\n      tail = '.';\n    if (tail.length > 0 && trailingSeparator)\n      tail += '\\\\';\n    if (device === undefined) {\n      if (isAbsolute) {\n        if (tail.length > 0)\n          return '\\\\' + tail;\n        else\n          return '\\\\';\n      } else if (tail.length > 0) {\n        return tail;\n      } else {\n        return '';\n      }\n    } else {\n      if (isAbsolute) {\n        if (tail.length > 0)\n          return device + '\\\\' + tail;\n        else\n          return device + '\\\\';\n      } else if (tail.length > 0) {\n        return device + tail;\n      } else {\n        return device;\n      }\n    }\n  },\n\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    const len = path.length;\n    if (len === 0)\n      return false;\n    var code = path.charCodeAt(0);\n    if (code === 47/*/*/ || code === 92/*\\*/) {\n      return true;\n    } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||\n               (code >= 97/*a*/ && code <= 122/*z*/)) {\n      // Possible device root\n\n      if (len > 2 && path.charCodeAt(1) === 58/*:*/) {\n        code = path.charCodeAt(2);\n        if (code === 47/*/*/ || code === 92/*\\*/)\n          return true;\n      }\n    }\n    return false;\n  },\n\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n\n    var joined;\n    var firstPart;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = firstPart = arg;\n        else\n          joined += '\\\\' + arg;\n      }\n    }\n\n    if (joined === undefined)\n      return '.';\n\n    // Make sure that the joined path doesn't start with two slashes, because\n    // normalize() will mistake it for an UNC path then.\n    //\n    // This step is skipped when it is very clear that the user actually\n    // intended to point at an UNC path. This is assumed when the first\n    // non-empty string arguments starts with exactly two slashes followed by\n    // at least one more non-slash character.\n    //\n    // Note that for normalize() to treat a path as an UNC path it needs to\n    // have at least 2 components, so we don't filter for that here.\n    // This means that the user can use join to construct UNC paths from\n    // a server name and a share name; for example:\n    //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n    //var firstPart = paths[0];\n    var needsReplace = true;\n    var slashCount = 0;\n    var code = firstPart.charCodeAt(0);\n    if (code === 47/*/*/ || code === 92/*\\*/) {\n      ++slashCount;\n      const firstLen = firstPart.length;\n      if (firstLen > 1) {\n        code = firstPart.charCodeAt(1);\n        if (code === 47/*/*/ || code === 92/*\\*/) {\n          ++slashCount;\n          if (firstLen > 2) {\n            code = firstPart.charCodeAt(2);\n            if (code === 47/*/*/ || code === 92/*\\*/)\n              ++slashCount;\n            else {\n              // We matched a UNC path in the first part\n              needsReplace = false;\n            }\n          }\n        }\n      }\n    }\n    if (needsReplace) {\n      // Find any more consecutive slashes we need to replace\n      for (; slashCount < joined.length; ++slashCount) {\n        code = joined.charCodeAt(slashCount);\n        if (code !== 47/*/*/ && code !== 92/*\\*/)\n          break;\n      }\n\n      // Replace the slashes if needed\n      if (slashCount >= 2)\n        joined = '\\\\' + joined.slice(slashCount);\n    }\n\n    return win32.normalize(joined);\n  },\n\n\n  // It will solve the relative path from `from` to `to`, for instance:\n  //  from = 'C:\\\\orandea\\\\test\\\\aaa'\n  //  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n  // The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to)\n      return '';\n\n    var fromOrig = win32.resolve(from);\n    var toOrig = win32.resolve(to);\n\n    if (fromOrig === toOrig)\n      return '';\n\n    from = fromOrig.toLowerCase();\n    to = toOrig.toLowerCase();\n\n    if (from === to)\n      return '';\n\n    // Trim any leading backslashes\n    var fromStart = 0;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 92/*\\*/)\n        break;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    var fromEnd = from.length;\n    for (; fromEnd - 1 > fromStart; --fromEnd) {\n      if (from.charCodeAt(fromEnd - 1) !== 92/*\\*/)\n        break;\n    }\n    var fromLen = (fromEnd - fromStart);\n\n    // Trim any leading backslashes\n    var toStart = 0;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 92/*\\*/)\n        break;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    var toEnd = to.length;\n    for (; toEnd - 1 > toStart; --toEnd) {\n      if (to.charCodeAt(toEnd - 1) !== 92/*\\*/)\n        break;\n    }\n    var toLen = (toEnd - toStart);\n\n    // Compare paths to find the longest common path from root\n    var length = (fromLen < toLen ? fromLen : toLen);\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 92/*\\*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n            return toOrig.slice(toStart + i + 1);\n          } else if (i === 2) {\n            // We get here if `from` is the device root.\n            // For example: from='C:\\\\'; to='C:\\\\foo'\n            return toOrig.slice(toStart + i);\n          }\n        }\n        if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 92/*\\*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n            lastCommonSep = i;\n          } else if (i === 2) {\n            // We get here if `to` is the device root.\n            // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n            lastCommonSep = 3;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 92/*\\*/)\n        lastCommonSep = i;\n    }\n\n    // We found a mismatch before the first common path separator was seen, so\n    // return the original `to`.\n    if (i !== length && lastCommonSep === -1) {\n      return toOrig;\n    }\n\n    var out = '';\n    if (lastCommonSep === -1)\n      lastCommonSep = 0;\n    // Generate the relative path based on the path difference between `to` and\n    // `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 92/*\\*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '\\\\..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + toOrig.slice(toStart + lastCommonSep, toEnd);\n    else {\n      toStart += lastCommonSep;\n      if (toOrig.charCodeAt(toStart) === 92/*\\*/)\n        ++toStart;\n      return toOrig.slice(toStart, toEnd);\n    }\n  },\n\n\n  _makeLong: function _makeLong(path) {\n    // Note: this will *probably* throw somewhere.\n    if (typeof path !== 'string')\n      return path;\n\n    if (path.length === 0) {\n      return '';\n    }\n\n    const resolvedPath = win32.resolve(path);\n\n    if (resolvedPath.length >= 3) {\n      var code = resolvedPath.charCodeAt(0);\n      if (code === 92/*\\*/) {\n        // Possible UNC root\n\n        if (resolvedPath.charCodeAt(1) === 92/*\\*/) {\n          code = resolvedPath.charCodeAt(2);\n          if (code !== 63/*?*/ && code !== 46/*.*/) {\n            // Matched non-long UNC root, convert the path to a long UNC path\n            return '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.slice(2);\n          }\n        }\n      } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||\n                 (code >= 97/*a*/ && code <= 122/*z*/)) {\n        // Possible device root\n\n        if (resolvedPath.charCodeAt(1) === 58/*:*/ &&\n            resolvedPath.charCodeAt(2) === 92/*\\*/) {\n          // Matched device root, convert the path to a long UNC path\n          return '\\\\\\\\?\\\\' + resolvedPath;\n        }\n      }\n    }\n\n    return path;\n  },\n\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    var rootEnd = -1;\n    var end = -1;\n    var matchedSlash = true;\n    var offset = 0;\n    var code = path.charCodeAt(0);\n\n    // Try to match a root\n    if (len > 1) {\n      if (code === 47/*/*/ || code === 92/*\\*/) {\n        // Possible UNC root\n\n        rootEnd = offset = 1;\n\n        code = path.charCodeAt(1);\n        if (code === 47/*/*/ || code === 92/*\\*/) {\n          // Matched double path separator at beginning\n          var j = 2;\n          var last = j;\n          // Match 1 or more non-path separators\n          for (; j < len; ++j) {\n            code = path.charCodeAt(j);\n            if (code === 47/*/*/ || code === 92/*\\*/)\n              break;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            for (; j < len; ++j) {\n              code = path.charCodeAt(j);\n              if (code !== 47/*/*/ && code !== 92/*\\*/)\n                break;\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              for (; j < len; ++j) {\n                code = path.charCodeAt(j);\n                if (code === 47/*/*/ || code === 92/*\\*/)\n                  break;\n              }\n              if (j === len) {\n                // We matched a UNC root only\n                return path;\n              }\n              if (j !== last) {\n                // We matched a UNC root with leftovers\n\n                // Offset by 1 to include the separator after the UNC root to\n                // treat it as a \"normal root\" on top of a (UNC) root\n                rootEnd = offset = j + 1;\n              }\n            }\n          }\n        }\n      } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||\n                 (code >= 97/*a*/ && code <= 122/*z*/)) {\n        // Possible device root\n\n        code = path.charCodeAt(1);\n        if (path.charCodeAt(1) === 58/*:*/) {\n          rootEnd = offset = 2;\n          if (len > 2) {\n            code = path.charCodeAt(2);\n            if (code === 47/*/*/ || code === 92/*\\*/)\n              rootEnd = offset = 3;\n          }\n        }\n      }\n    } else if (code === 47/*/*/ || code === 92/*\\*/) {\n      return path[0];\n    }\n\n    for (var i = len - 1; i >= offset; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47/*/*/ || code === 92/*\\*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) {\n      if (rootEnd === -1)\n        return '.';\n      else\n        end = rootEnd;\n    }\n    return path.slice(0, end);\n  },\n\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string')\n      throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n    if (path.length >= 2) {\n      const drive = path.charCodeAt(0);\n      if ((drive >= 65/*A*/ && drive <= 90/*Z*/) ||\n          (drive >= 97/*a*/ && drive <= 122/*z*/)) {\n        if (path.charCodeAt(1) === 58/*:*/)\n          start = 2;\n      }\n    }\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path)\n        return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= start; --i) {\n        const code = path.charCodeAt(i);\n        if (code === 47/*/*/ || code === 92/*\\*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= start; --i) {\n        const code = path.charCodeAt(i);\n        if (code === 47/*/*/ || code === 92/*\\*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1)\n        return '';\n      return path.slice(start, end);\n    }\n  },\n\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      const code = path.charCodeAt(i);\n      if (code === 47/*/*/ || code === 92/*\\*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46/*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError(\n        `Parameter \"pathObject\" must be an object, not ${typeof pathObject}`\n      );\n    }\n    return _format('\\\\', pathObject);\n  },\n\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0)\n      return ret;\n\n    var len = path.length;\n    var rootEnd = 0;\n    var code = path.charCodeAt(0);\n    var isAbsolute = false;\n\n    // Try to match a root\n    if (len > 1) {\n      if (code === 47/*/*/ || code === 92/*\\*/) {\n        // Possible UNC root\n\n        isAbsolute = true;\n\n        code = path.charCodeAt(1);\n        rootEnd = 1;\n        if (code === 47/*/*/ || code === 92/*\\*/) {\n          // Matched double path separator at beginning\n          var j = 2;\n          var last = j;\n          // Match 1 or more non-path separators\n          for (; j < len; ++j) {\n            code = path.charCodeAt(j);\n            if (code === 47/*/*/ || code === 92/*\\*/)\n              break;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            for (; j < len; ++j) {\n              code = path.charCodeAt(j);\n              if (code !== 47/*/*/ && code !== 92/*\\*/)\n                break;\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              for (; j < len; ++j) {\n                code = path.charCodeAt(j);\n                if (code === 47/*/*/ || code === 92/*\\*/)\n                  break;\n              }\n              if (j === len) {\n                // We matched a UNC root only\n\n                rootEnd = j;\n              } else if (j !== last) {\n                // We matched a UNC root with leftovers\n\n                rootEnd = j + 1;\n              }\n            }\n          }\n        }\n      } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||\n                 (code >= 97/*a*/ && code <= 122/*z*/)) {\n        // Possible device root\n\n        code = path.charCodeAt(1);\n        if (path.charCodeAt(1) === 58/*:*/) {\n          rootEnd = 2;\n          if (len > 2) {\n            code = path.charCodeAt(2);\n            if (code === 47/*/*/ || code === 92/*\\*/) {\n              if (len === 3) {\n                // `path` contains just a drive root, exit early to avoid\n                // unnecessary work\n                ret.root = ret.dir = path.slice(0, 3);\n                return ret;\n              }\n              isAbsolute = true;\n              rootEnd = 3;\n            }\n          } else {\n            // `path` contains just a drive root, exit early to avoid\n            // unnecessary work\n            ret.root = ret.dir = path.slice(0, 2);\n            return ret;\n          }\n        }\n      }\n    } else if (code === 47/*/*/ || code === 92/*\\*/) {\n      // `path` contains just a path separator, exit early to avoid\n      // unnecessary work\n      ret.root = ret.dir = path[0];\n      return ret;\n    }\n\n    if (rootEnd > 0)\n      ret.root = path.slice(0, rootEnd);\n\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= rootEnd; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47/*/*/ || code === 92/*\\*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46/*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute)\n          ret.base = ret.name = path.slice(rootEnd, end);\n        else\n          ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(rootEnd, startDot);\n        ret.base = path.slice(rootEnd, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0)\n      ret.dir = path.slice(0, startPart - 1);\n    else if (isAbsolute)\n      ret.dir = path.slice(0, rootEnd);\n\n    return ret;\n  },\n\n\n  sep: '\\\\',\n  delimiter: ';',\n  win32: null,\n  posix: null\n};\n\n\nconst posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47/*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0)\n      return '.';\n\n    const isAbsolute = path.charCodeAt(0) === 47/*/*/;\n    const trailingSeparator = path.charCodeAt(path.length - 1) === 47/*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute)\n      path = '.';\n    if (path.length > 0 && trailingSeparator)\n      path += '/';\n\n    if (isAbsolute)\n      return '/' + path;\n    return path;\n  },\n\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47/*/*/;\n  },\n\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to)\n      return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to)\n      return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47/*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = (fromEnd - fromStart);\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47/*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = (toEnd - toStart);\n\n    // Compare paths to find the longest common path from root\n    var length = (fromLen < toLen ? fromLen : toLen);\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47/*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47/*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47/*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47/*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47/*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0)\n      return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = (code === 47/*/*/);\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47/*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1)\n      return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1)\n      return '//';\n    return path.slice(0, end);\n  },\n\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string')\n      throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path)\n        return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        const code = path.charCodeAt(i);\n        if (code === 47/*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47/*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1)\n        return '';\n      return path.slice(start, end);\n    }\n  },\n\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      const code = path.charCodeAt(i);\n      if (code === 47/*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46/*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError(\n        `Parameter \"pathObject\" must be an object, not ${typeof pathObject}`\n      );\n    }\n    return _format('/', pathObject);\n  },\n\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0)\n      return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = (code === 47/*/*/);\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47/*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46/*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute)\n          ret.base = ret.name = path.slice(1, end);\n        else\n          ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0)\n      ret.dir = path.slice(0, startPart - 1);\n    else if (isAbsolute)\n      ret.dir = '/';\n\n    return ret;\n  },\n\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\n\nif (process.platform === 'win32')\n  module.exports = win32;\nelse\n  module.exports = posix;\n\n});"},
    {"fileId":2, "filename":"fs.js", "source":"(function (exports, require, module, __filename, __dirname) { // Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Maintainers, keep in mind that ES1-style octal literals (`0666`) are not\n// allowed in strict mode. Use ES6-style octal literals instead (`0o666`).\n\n'use strict';\n\nconst constants = process.binding('constants').fs;\nconst { S_IFIFO, S_IFLNK, S_IFMT, S_IFREG, S_IFSOCK } = constants;\nconst util = require('util');\nconst pathModule = require('path');\nconst { isUint8Array } = process.binding('util');\n\nconst binding = process.binding('fs');\nconst fs = exports;\nconst Buffer = require('buffer').Buffer;\nconst Stream = require('stream').Stream;\nconst EventEmitter = require('events');\nconst FSReqWrap = binding.FSReqWrap;\nconst FSEvent = process.binding('fs_event_wrap').FSEvent;\nconst internalFS = require('internal/fs');\nconst internalURL = require('internal/url');\nconst internalUtil = require('internal/util');\nconst assertEncoding = internalFS.assertEncoding;\nconst stringToFlags = internalFS.stringToFlags;\nconst getPathFromURL = internalURL.getPathFromURL;\n\nObject.defineProperty(exports, 'constants', {\n  configurable: false,\n  enumerable: true,\n  value: constants\n});\n\nconst Readable = Stream.Readable;\nconst Writable = Stream.Writable;\n\nconst kMinPoolSpace = 128;\nconst kMaxLength = require('buffer').kMaxLength;\n\nconst isWindows = process.platform === 'win32';\n\nconst DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\nconst errnoException = util._errnoException;\n\nfunction getOptions(options, defaultOptions) {\n  if (options === null || options === undefined ||\n      typeof options === 'function') {\n    return defaultOptions;\n  }\n\n  if (typeof options === 'string') {\n    defaultOptions = util._extend({}, defaultOptions);\n    defaultOptions.encoding = options;\n    options = defaultOptions;\n  } else if (typeof options !== 'object') {\n    throw new TypeError('\"options\" must be a string or an object, got ' +\n                        typeof options + ' instead.');\n  }\n\n  if (options.encoding !== 'buffer')\n    assertEncoding(options.encoding);\n  return options;\n}\n\nfunction copyObject(source) {\n  var target = {};\n  for (var key in source)\n    target[key] = source[key];\n  return target;\n}\n\nfunction rethrow() {\n  // TODO(thefourtheye) Throw error instead of warning in major version > 7\n  process.emitWarning(\n    'Calling an asynchronous function without callback is deprecated.',\n    'DeprecationWarning', 'DEP0013', rethrow\n  );\n\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\n  // is fairly slow to generate.\n  if (DEBUG) {\n    var backtrace = new Error();\n    return function(err) {\n      if (err) {\n        backtrace.stack = err.name + ': ' + err.message +\n                          backtrace.stack.substr(backtrace.name.length);\n        throw backtrace;\n      }\n    };\n  }\n\n  return function(err) {\n    if (err) {\n      throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs\n    }\n  };\n}\n\nfunction maybeCallback(cb) {\n  return typeof cb === 'function' ? cb : rethrow();\n}\n\n// Ensure that callbacks run in the global context. Only use this function\n// for callbacks that are passed to the binding layer, callbacks that are\n// invoked from JS already run in the proper scope.\nfunction makeCallback(cb) {\n  if (cb === undefined) {\n    return rethrow();\n  }\n\n  if (typeof cb !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n\n  return function() {\n    return cb.apply(null, arguments);\n  };\n}\n\n// Special case of `makeCallback()` that is specific to async `*stat()` calls as\n// an optimization, since the data passed back to the callback needs to be\n// transformed anyway.\nfunction makeStatsCallback(cb) {\n  if (cb === undefined) {\n    return rethrow();\n  }\n\n  if (typeof cb !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n\n  return function(err) {\n    if (err) return cb(err);\n    cb(err, statsFromValues());\n  };\n}\n\nfunction nullCheck(path, callback) {\n  if (('' + path).indexOf('\\u0000') !== -1) {\n    var er = new Error('Path must be a string without null bytes');\n    er.code = 'ENOENT';\n    if (typeof callback !== 'function')\n      throw er;\n    process.nextTick(callback, er);\n    return false;\n  }\n  return true;\n}\n\nfunction isFd(path) {\n  return (path >>> 0) === path;\n}\n\n// Constructor for file stats.\nfunction Stats(\n    dev,\n    mode,\n    nlink,\n    uid,\n    gid,\n    rdev,\n    blksize,\n    ino,\n    size,\n    blocks,\n    atim_msec,\n    mtim_msec,\n    ctim_msec,\n    birthtim_msec) {\n  this.dev = dev;\n  this.mode = mode;\n  this.nlink = nlink;\n  this.uid = uid;\n  this.gid = gid;\n  this.rdev = rdev;\n  this.blksize = blksize;\n  this.ino = ino;\n  this.size = size;\n  this.blocks = blocks;\n  this._atim_msec = atim_msec;\n  this._mtim_msec = mtim_msec;\n  this._ctim_msec = ctim_msec;\n  this._birthtim_msec = birthtim_msec;\n}\nfs.Stats = Stats;\n\n// defining the properties in this fashion (explicitly with no loop or factory)\n// has been shown to be the most performant on V8 contemp.\n// Ref: https://github.com/nodejs/node/pull/12818\n// + 0.5 is added to the Dates to protect values from being rounded down\n// Ref: https://github.com/nodejs/node/pull/12607\nObject.defineProperties(Stats.prototype, {\n  atime: {\n    configurable: true,\n    enumerable: true,\n    get() {\n      return this._atime !== undefined ?\n          this._atime :\n          (this._atime = new Date(this._atim_msec + 0.5));\n    },\n    set(value) { return this._atime = value; }\n  },\n  mtime: {\n    configurable: true,\n    enumerable: true,\n    get() {\n      return this._mtime !== undefined ?\n          this._mtime :\n          (this._mtime = new Date(this._mtim_msec + 0.5));\n    },\n    set(value) { return this._mtime = value; }\n  },\n  ctime: {\n    configurable: true,\n    enumerable: true,\n    get() {\n      return this._ctime !== undefined ?\n        this._ctime :\n        (this._ctime = new Date(this._ctim_msec + 0.5));\n    },\n    set(value) { return this._ctime = value; }\n  },\n  birthtime: {\n    configurable: true,\n    enumerable: true,\n    get() {\n      return this._birthtime !== undefined ?\n        this._birthtime :\n        (this._birthtime = new Date(this._birthtim_msec + 0.5));\n    },\n    set(value) { return this._birthtime = value; }\n  },\n});\n\nStats.prototype.toJSON = function toJSON() {\n  return {\n    dev: this.dev,\n    mode: this.mode,\n    nlink: this.nlink,\n    uid: this.uid,\n    gid: this.gid,\n    rdev: this.rdev,\n    blksize: this.blksize,\n    ino: this.ino,\n    size: this.size,\n    blocks: this.blocks,\n    atime: this.atime,\n    ctime: this.ctime,\n    mtime: this.mtime,\n    birthtime: this.birthtime\n  };\n};\n\n\nStats.prototype._checkModeProperty = function(property) {\n  return ((this.mode & S_IFMT) === property);\n};\n\nStats.prototype.isDirectory = function() {\n  return this._checkModeProperty(constants.S_IFDIR);\n};\n\nStats.prototype.isFile = function() {\n  return this._checkModeProperty(S_IFREG);\n};\n\nStats.prototype.isBlockDevice = function() {\n  return this._checkModeProperty(constants.S_IFBLK);\n};\n\nStats.prototype.isCharacterDevice = function() {\n  return this._checkModeProperty(constants.S_IFCHR);\n};\n\nStats.prototype.isSymbolicLink = function() {\n  return this._checkModeProperty(S_IFLNK);\n};\n\nStats.prototype.isFIFO = function() {\n  return this._checkModeProperty(S_IFIFO);\n};\n\nStats.prototype.isSocket = function() {\n  return this._checkModeProperty(S_IFSOCK);\n};\n\nconst statValues = binding.getStatValues();\n\nfunction statsFromValues() {\n  return new Stats(statValues[0], statValues[1], statValues[2], statValues[3],\n                   statValues[4], statValues[5],\n                   statValues[6] < 0 ? undefined : statValues[6], statValues[7],\n                   statValues[8], statValues[9] < 0 ? undefined : statValues[9],\n                   statValues[10], statValues[11], statValues[12],\n                   statValues[13]);\n}\n\n// Don't allow mode to accidentally be overwritten.\nObject.defineProperties(fs, {\n  F_OK: {enumerable: true, value: constants.F_OK || 0},\n  R_OK: {enumerable: true, value: constants.R_OK || 0},\n  W_OK: {enumerable: true, value: constants.W_OK || 0},\n  X_OK: {enumerable: true, value: constants.X_OK || 0},\n});\n\nfunction handleError(val, callback) {\n  if (val instanceof Error) {\n    if (typeof callback === 'function') {\n      process.nextTick(callback, val);\n      return true;\n    } else throw val;\n  }\n  return false;\n}\n\nfs.access = function(path, mode, callback) {\n  if (typeof mode === 'function') {\n    callback = mode;\n    mode = fs.F_OK;\n  } else if (typeof callback !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n\n  if (!nullCheck(path, callback))\n    return;\n\n  mode = mode | 0;\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.access(pathModule._makeLong(path), mode, req);\n};\n\nfs.accessSync = function(path, mode) {\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n\n  if (mode === undefined)\n    mode = fs.F_OK;\n  else\n    mode = mode | 0;\n\n  binding.access(pathModule._makeLong(path), mode);\n};\n\nfs.exists = function(path, callback) {\n  if (handleError((path = getPathFromURL(path)), cb))\n    return;\n  if (!nullCheck(path, cb)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = cb;\n  binding.stat(pathModule._makeLong(path), req);\n  function cb(err) {\n    if (callback) callback(err ? false : true);\n  }\n};\n\nfs.existsSync = function(path) {\n  try {\n    handleError((path = getPathFromURL(path)));\n    nullCheck(path);\n    binding.stat(pathModule._makeLong(path));\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\nfs.readFile = function(path, options, callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options, { flag: 'r' });\n\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback))\n    return;\n\n  var context = new ReadFileContext(callback, options.encoding);\n  context.isUserFd = isFd(path); // file descriptor ownership\n  var req = new FSReqWrap();\n  req.context = context;\n  req.oncomplete = readFileAfterOpen;\n\n  if (context.isUserFd) {\n    process.nextTick(function() {\n      req.oncomplete(null, path);\n    });\n    return;\n  }\n\n  binding.open(pathModule._makeLong(path),\n               stringToFlags(options.flag || 'r'),\n               0o666,\n               req);\n};\n\nconst kReadFileBufferLength = 8 * 1024;\n\nfunction ReadFileContext(callback, encoding) {\n  this.fd = undefined;\n  this.isUserFd = undefined;\n  this.size = undefined;\n  this.callback = callback;\n  this.buffers = null;\n  this.buffer = null;\n  this.pos = 0;\n  this.encoding = encoding;\n  this.err = null;\n}\n\nReadFileContext.prototype.read = function() {\n  var buffer;\n  var offset;\n  var length;\n\n  if (this.size === 0) {\n    buffer = this.buffer = Buffer.allocUnsafeSlow(kReadFileBufferLength);\n    offset = 0;\n    length = kReadFileBufferLength;\n  } else {\n    buffer = this.buffer;\n    offset = this.pos;\n    length = this.size - this.pos;\n  }\n\n  var req = new FSReqWrap();\n  req.oncomplete = readFileAfterRead;\n  req.context = this;\n\n  binding.read(this.fd, buffer, offset, length, -1, req);\n};\n\nReadFileContext.prototype.close = function(err) {\n  var req = new FSReqWrap();\n  req.oncomplete = readFileAfterClose;\n  req.context = this;\n  this.err = err;\n\n  if (this.isUserFd) {\n    process.nextTick(function() {\n      req.oncomplete(null);\n    });\n    return;\n  }\n\n  binding.close(this.fd, req);\n};\n\nfunction readFileAfterOpen(err, fd) {\n  var context = this.context;\n\n  if (err) {\n    context.callback(err);\n    return;\n  }\n\n  context.fd = fd;\n\n  var req = new FSReqWrap();\n  req.oncomplete = readFileAfterStat;\n  req.context = context;\n  binding.fstat(fd, req);\n}\n\nfunction readFileAfterStat(err) {\n  var context = this.context;\n\n  if (err)\n    return context.close(err);\n\n  // Use stats array directly to avoid creating an fs.Stats instance just for\n  // our internal use.\n  var size;\n  if ((statValues[1/*mode*/] & S_IFMT) === S_IFREG)\n    size = context.size = statValues[8/*size*/];\n  else\n    size = context.size = 0;\n\n  if (size === 0) {\n    context.buffers = [];\n    context.read();\n    return;\n  }\n\n  if (size > kMaxLength) {\n    err = new RangeError('File size is greater than possible Buffer: ' +\n                         `0x${kMaxLength.toString(16)} bytes`);\n    return context.close(err);\n  }\n\n  context.buffer = Buffer.allocUnsafeSlow(size);\n  context.read();\n}\n\nfunction readFileAfterRead(err, bytesRead) {\n  var context = this.context;\n\n  if (err)\n    return context.close(err);\n\n  if (bytesRead === 0)\n    return context.close();\n\n  context.pos += bytesRead;\n\n  if (context.size !== 0) {\n    if (context.pos === context.size)\n      context.close();\n    else\n      context.read();\n  } else {\n    // unknown size, just read until we don't get bytes.\n    context.buffers.push(context.buffer.slice(0, bytesRead));\n    context.read();\n  }\n}\n\nfunction readFileAfterClose(err) {\n  var context = this.context;\n  var buffer = null;\n  var callback = context.callback;\n\n  if (context.err || err)\n    return callback(context.err || err);\n\n  if (context.size === 0)\n    buffer = Buffer.concat(context.buffers, context.pos);\n  else if (context.pos < context.size)\n    buffer = context.buffer.slice(0, context.pos);\n  else\n    buffer = context.buffer;\n\n  if (context.encoding) {\n    return tryToString(buffer, context.encoding, callback);\n  }\n\n  callback(null, buffer);\n}\n\nfunction tryToString(buf, encoding, callback) {\n  try {\n    buf = buf.toString(encoding);\n  } catch (err) {\n    return callback(err);\n  }\n  callback(null, buf);\n}\n\nfunction tryStatSync(fd, isUserFd) {\n  var threw = true;\n  try {\n    binding.fstat(fd);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return !threw;\n}\n\nfunction tryCreateBuffer(size, fd, isUserFd) {\n  var threw = true;\n  var buffer;\n  try {\n    buffer = Buffer.allocUnsafe(size);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return buffer;\n}\n\nfunction tryReadSync(fd, isUserFd, buffer, pos, len) {\n  var threw = true;\n  var bytesRead;\n  try {\n    bytesRead = fs.readSync(fd, buffer, pos, len);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return bytesRead;\n}\n\nfs.readFileSync = function(path, options) {\n  options = getOptions(options, { flag: 'r' });\n  var isUserFd = isFd(path); // file descriptor ownership\n  var fd = isUserFd ? path : fs.openSync(path, options.flag || 'r', 0o666);\n\n  // Use stats array directly to avoid creating an fs.Stats instance just for\n  // our internal use.\n  var size;\n  if (tryStatSync(fd, isUserFd) && (statValues[1/*mode*/] & S_IFMT) === S_IFREG)\n    size = statValues[8/*size*/];\n  else\n    size = 0;\n  var pos = 0;\n  var buffer; // single buffer with file data\n  var buffers; // list for when size is unknown\n\n  if (size === 0) {\n    buffers = [];\n  } else {\n    buffer = tryCreateBuffer(size, fd, isUserFd);\n  }\n\n  var bytesRead;\n\n  if (size !== 0) {\n    do {\n      bytesRead = tryReadSync(fd, isUserFd, buffer, pos, size - pos);\n      pos += bytesRead;\n    } while (bytesRead !== 0 && pos < size);\n  } else {\n    do {\n      // the kernel lies about many files.\n      // Go ahead and try to read some bytes.\n      buffer = Buffer.allocUnsafe(8192);\n      bytesRead = tryReadSync(fd, isUserFd, buffer, 0, 8192);\n      if (bytesRead !== 0) {\n        buffers.push(buffer.slice(0, bytesRead));\n      }\n      pos += bytesRead;\n    } while (bytesRead !== 0);\n  }\n\n  if (!isUserFd)\n    fs.closeSync(fd);\n\n  if (size === 0) {\n    // data was collected into the buffers list.\n    buffer = Buffer.concat(buffers, pos);\n  } else if (pos < size) {\n    buffer = buffer.slice(0, pos);\n  }\n\n  if (options.encoding) buffer = buffer.toString(options.encoding);\n  return buffer;\n};\n\n\n// Yes, the follow could be easily DRYed up but I provide the explicit\n// list to make the arguments clear.\n\nfs.close = function(fd, callback) {\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.close(fd, req);\n};\n\nfs.closeSync = function(fd) {\n  return binding.close(fd);\n};\n\nfunction modeNum(m, def) {\n  if (typeof m === 'number')\n    return m;\n  if (typeof m === 'string')\n    return parseInt(m, 8);\n  if (def)\n    return modeNum(def);\n  return undefined;\n}\n\nfs.open = function(path, flags, mode, callback_) {\n  var callback = makeCallback(arguments[arguments.length - 1]);\n  mode = modeNum(mode, 0o666);\n\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n\n  binding.open(pathModule._makeLong(path),\n               stringToFlags(flags),\n               mode,\n               req);\n};\n\nfs.openSync = function(path, flags, mode) {\n  mode = modeNum(mode, 0o666);\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  return binding.open(pathModule._makeLong(path), stringToFlags(flags), mode);\n};\n\nfs.read = function(fd, buffer, offset, length, position, callback) {\n  if (length === 0) {\n    return process.nextTick(function() {\n      callback && callback(null, 0, buffer);\n    });\n  }\n\n  function wrapper(err, bytesRead) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback && callback(err, bytesRead || 0, buffer);\n  }\n\n  var req = new FSReqWrap();\n  req.oncomplete = wrapper;\n\n  binding.read(fd, buffer, offset, length, position, req);\n};\n\nObject.defineProperty(fs.read, internalUtil.customPromisifyArgs,\n                      { value: ['bytesRead', 'buffer'], enumerable: false });\n\nfs.readSync = function(fd, buffer, offset, length, position) {\n  if (length === 0) {\n    return 0;\n  }\n\n  return binding.read(fd, buffer, offset, length, position);\n};\n\n// usage:\n//  fs.write(fd, buffer[, offset[, length[, position]]], callback);\n// OR\n//  fs.write(fd, string[, position[, encoding]], callback);\nfs.write = function(fd, buffer, offset, length, position, callback) {\n  function wrapper(err, written) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err, written || 0, buffer);\n  }\n\n  var req = new FSReqWrap();\n  req.oncomplete = wrapper;\n\n  if (isUint8Array(buffer)) {\n    callback = maybeCallback(callback || position || length || offset);\n    if (typeof offset !== 'number') {\n      offset = 0;\n    }\n    if (typeof length !== 'number') {\n      length = buffer.length - offset;\n    }\n    if (typeof position !== 'number') {\n      position = null;\n    }\n    return binding.writeBuffer(fd, buffer, offset, length, position, req);\n  }\n\n  if (typeof buffer !== 'string')\n    buffer += '';\n  if (typeof position !== 'function') {\n    if (typeof offset === 'function') {\n      position = offset;\n      offset = null;\n    } else {\n      position = length;\n    }\n    length = 'utf8';\n  }\n  callback = maybeCallback(position);\n  return binding.writeString(fd, buffer, offset, length, req);\n};\n\nObject.defineProperty(fs.write, internalUtil.customPromisifyArgs,\n                      { value: ['bytesWritten', 'buffer'], enumerable: false });\n\n// usage:\n//  fs.writeSync(fd, buffer[, offset[, length[, position]]]);\n// OR\n//  fs.writeSync(fd, string[, position[, encoding]]);\nfs.writeSync = function(fd, buffer, offset, length, position) {\n  if (isUint8Array(buffer)) {\n    if (position === undefined)\n      position = null;\n    if (typeof offset !== 'number')\n      offset = 0;\n    if (typeof length !== 'number')\n      length = buffer.length - offset;\n    return binding.writeBuffer(fd, buffer, offset, length, position);\n  }\n  if (typeof buffer !== 'string')\n    buffer += '';\n  if (offset === undefined)\n    offset = null;\n  return binding.writeString(fd, buffer, offset, length, position);\n};\n\nfs.rename = function(oldPath, newPath, callback) {\n  callback = makeCallback(callback);\n  if (handleError((oldPath = getPathFromURL(oldPath)), callback))\n    return;\n\n  if (handleError((newPath = getPathFromURL(newPath)), callback))\n    return;\n\n  if (!nullCheck(oldPath, callback)) return;\n  if (!nullCheck(newPath, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.rename(pathModule._makeLong(oldPath),\n                 pathModule._makeLong(newPath),\n                 req);\n};\n\nfs.renameSync = function(oldPath, newPath) {\n  handleError((oldPath = getPathFromURL(oldPath)));\n  handleError((newPath = getPathFromURL(newPath)));\n  nullCheck(oldPath);\n  nullCheck(newPath);\n  return binding.rename(pathModule._makeLong(oldPath),\n                        pathModule._makeLong(newPath));\n};\n\nfs.truncate = function(path, len, callback) {\n  if (typeof path === 'number') {\n    return fs.ftruncate(path, len, callback);\n  }\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  } else if (len === undefined) {\n    len = 0;\n  }\n\n  callback = maybeCallback(callback);\n  fs.open(path, 'r+', function(er, fd) {\n    if (er) return callback(er);\n    var req = new FSReqWrap();\n    req.oncomplete = function oncomplete(er) {\n      fs.close(fd, function(er2) {\n        callback(er || er2);\n      });\n    };\n    binding.ftruncate(fd, len, req);\n  });\n};\n\nfs.truncateSync = function(path, len) {\n  if (typeof path === 'number') {\n    // legacy\n    return fs.ftruncateSync(path, len);\n  }\n  if (len === undefined) {\n    len = 0;\n  }\n  // allow error to be thrown, but still close fd.\n  var fd = fs.openSync(path, 'r+');\n  var ret;\n\n  try {\n    ret = fs.ftruncateSync(fd, len);\n  } finally {\n    fs.closeSync(fd);\n  }\n  return ret;\n};\n\nfs.ftruncate = function(fd, len, callback) {\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  } else if (len === undefined) {\n    len = 0;\n  }\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.ftruncate(fd, len, req);\n};\n\nfs.ftruncateSync = function(fd, len) {\n  if (len === undefined) {\n    len = 0;\n  }\n  return binding.ftruncate(fd, len);\n};\n\nfs.rmdir = function(path, callback) {\n  callback = maybeCallback(callback);\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.rmdir(pathModule._makeLong(path), req);\n};\n\nfs.rmdirSync = function(path) {\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  return binding.rmdir(pathModule._makeLong(path));\n};\n\nfs.fdatasync = function(fd, callback) {\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.fdatasync(fd, req);\n};\n\nfs.fdatasyncSync = function(fd) {\n  return binding.fdatasync(fd);\n};\n\nfs.fsync = function(fd, callback) {\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.fsync(fd, req);\n};\n\nfs.fsyncSync = function(fd) {\n  return binding.fsync(fd);\n};\n\nfs.mkdir = function(path, mode, callback) {\n  if (typeof mode === 'function') callback = mode;\n  callback = makeCallback(callback);\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.mkdir(pathModule._makeLong(path),\n                modeNum(mode, 0o777),\n                req);\n};\n\nfs.mkdirSync = function(path, mode) {\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  return binding.mkdir(pathModule._makeLong(path),\n                       modeNum(mode, 0o777));\n};\n\nfs.readdir = function(path, options, callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options, {});\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.readdir(pathModule._makeLong(path), options.encoding, req);\n};\n\nfs.readdirSync = function(path, options) {\n  options = getOptions(options, {});\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  return binding.readdir(pathModule._makeLong(path), options.encoding);\n};\n\nfs.fstat = function(fd, callback) {\n  var req = new FSReqWrap();\n  req.oncomplete = makeStatsCallback(callback);\n  binding.fstat(fd, req);\n};\n\nfs.lstat = function(path, callback) {\n  callback = makeStatsCallback(callback);\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.lstat(pathModule._makeLong(path), req);\n};\n\nfs.stat = function(path, callback) {\n  callback = makeStatsCallback(callback);\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.stat(pathModule._makeLong(path), req);\n};\n\nfs.fstatSync = function(fd) {\n  binding.fstat(fd);\n  return statsFromValues();\n};\n\nfs.lstatSync = function(path) {\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  binding.lstat(pathModule._makeLong(path));\n  return statsFromValues();\n};\n\nfs.statSync = function(path) {\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  binding.stat(pathModule._makeLong(path));\n  return statsFromValues();\n};\n\nfs.readlink = function(path, options, callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options, {});\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.readlink(pathModule._makeLong(path), options.encoding, req);\n};\n\nfs.readlinkSync = function(path, options) {\n  options = getOptions(options, {});\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  return binding.readlink(pathModule._makeLong(path), options.encoding);\n};\n\nfunction preprocessSymlinkDestination(path, type, linkPath) {\n  if (!isWindows) {\n    // No preprocessing is needed on Unix.\n    return path;\n  } else if (type === 'junction') {\n    // Junctions paths need to be absolute and \\\\?\\-prefixed.\n    // A relative target is relative to the link's parent directory.\n    path = pathModule.resolve(linkPath, '..', path);\n    return pathModule._makeLong(path);\n  } else {\n    // Windows symlinks don't tolerate forward slashes.\n    return ('' + path).replace(/\\//g, '\\\\');\n  }\n}\n\nfs.symlink = function(target, path, type_, callback_) {\n  var type = (typeof type_ === 'string' ? type_ : null);\n  var callback = makeCallback(arguments[arguments.length - 1]);\n\n  if (handleError((target = getPathFromURL(target)), callback))\n    return;\n\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n\n  if (!nullCheck(target, callback)) return;\n  if (!nullCheck(path, callback)) return;\n\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n\n  binding.symlink(preprocessSymlinkDestination(target, type, path),\n                  pathModule._makeLong(path),\n                  type,\n                  req);\n};\n\nfs.symlinkSync = function(target, path, type) {\n  type = (typeof type === 'string' ? type : null);\n  handleError((target = getPathFromURL(target)));\n  handleError((path = getPathFromURL(path)));\n  nullCheck(target);\n  nullCheck(path);\n\n  return binding.symlink(preprocessSymlinkDestination(target, type, path),\n                         pathModule._makeLong(path),\n                         type);\n};\n\nfs.link = function(existingPath, newPath, callback) {\n  callback = makeCallback(callback);\n\n  if (handleError((existingPath = getPathFromURL(existingPath)), callback))\n    return;\n\n  if (handleError((newPath = getPathFromURL(newPath)), callback))\n    return;\n\n  if (!nullCheck(existingPath, callback)) return;\n  if (!nullCheck(newPath, callback)) return;\n\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n\n  binding.link(pathModule._makeLong(existingPath),\n               pathModule._makeLong(newPath),\n               req);\n};\n\nfs.linkSync = function(existingPath, newPath) {\n  handleError((existingPath = getPathFromURL(existingPath)));\n  handleError((newPath = getPathFromURL(newPath)));\n  nullCheck(existingPath);\n  nullCheck(newPath);\n  return binding.link(pathModule._makeLong(existingPath),\n                      pathModule._makeLong(newPath));\n};\n\nfs.unlink = function(path, callback) {\n  callback = makeCallback(callback);\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.unlink(pathModule._makeLong(path), req);\n};\n\nfs.unlinkSync = function(path) {\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  return binding.unlink(pathModule._makeLong(path));\n};\n\nfs.fchmod = function(fd, mode, callback) {\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.fchmod(fd, modeNum(mode), req);\n};\n\nfs.fchmodSync = function(fd, mode) {\n  return binding.fchmod(fd, modeNum(mode));\n};\n\nif (constants.O_SYMLINK !== undefined) {\n  fs.lchmod = function(path, mode, callback) {\n    callback = maybeCallback(callback);\n    fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, function(err, fd) {\n      if (err) {\n        callback(err);\n        return;\n      }\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      fs.fchmod(fd, mode, function(err) {\n        fs.close(fd, function(err2) {\n          callback(err || err2);\n        });\n      });\n    });\n  };\n\n  fs.lchmodSync = function(path, mode) {\n    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK);\n\n    // prefer to return the chmod error, if one occurs,\n    // but still try to close, and report closing errors if they occur.\n    var err, err2, ret;\n    try {\n      ret = fs.fchmodSync(fd, mode);\n    } catch (er) {\n      err = er;\n    }\n    try {\n      fs.closeSync(fd);\n    } catch (er) {\n      err2 = er;\n    }\n    if (err || err2) throw (err || err2);\n    return ret;\n  };\n}\n\n\nfs.chmod = function(path, mode, callback) {\n  callback = makeCallback(callback);\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.chmod(pathModule._makeLong(path),\n                modeNum(mode),\n                req);\n};\n\nfs.chmodSync = function(path, mode) {\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  return binding.chmod(pathModule._makeLong(path), modeNum(mode));\n};\n\nif (constants.O_SYMLINK !== undefined) {\n  fs.lchown = function(path, uid, gid, callback) {\n    callback = maybeCallback(callback);\n    fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, function(err, fd) {\n      if (err) {\n        callback(err);\n        return;\n      }\n      fs.fchown(fd, uid, gid, callback);\n    });\n  };\n\n  fs.lchownSync = function(path, uid, gid) {\n    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK);\n    return fs.fchownSync(fd, uid, gid);\n  };\n}\n\nfs.fchown = function(fd, uid, gid, callback) {\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.fchown(fd, uid, gid, req);\n};\n\nfs.fchownSync = function(fd, uid, gid) {\n  return binding.fchown(fd, uid, gid);\n};\n\nfs.chown = function(path, uid, gid, callback) {\n  callback = makeCallback(callback);\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.chown(pathModule._makeLong(path), uid, gid, req);\n};\n\nfs.chownSync = function(path, uid, gid) {\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  return binding.chown(pathModule._makeLong(path), uid, gid);\n};\n\n// converts Date or number to a fractional UNIX timestamp\nfunction toUnixTimestamp(time) {\n  // eslint-disable-next-line eqeqeq\n  if (typeof time === 'string' && +time == time) {\n    return +time;\n  }\n  if (Number.isFinite(time)) {\n    if (time < 0) {\n      return Date.now() / 1000;\n    }\n    return time;\n  }\n  if (util.isDate(time)) {\n    // convert to 123.456 UNIX timestamp\n    return time.getTime() / 1000;\n  }\n  throw new Error('Cannot parse time: ' + time);\n}\n\n// exported for unit tests, not for public consumption\nfs._toUnixTimestamp = toUnixTimestamp;\n\nfs.utimes = function(path, atime, mtime, callback) {\n  callback = makeCallback(callback);\n  if (handleError((path = getPathFromURL(path)), callback))\n    return;\n  if (!nullCheck(path, callback)) return;\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n  binding.utimes(pathModule._makeLong(path),\n                 toUnixTimestamp(atime),\n                 toUnixTimestamp(mtime),\n                 req);\n};\n\nfs.utimesSync = function(path, atime, mtime) {\n  handleError((path = getPathFromURL(path)));\n  nullCheck(path);\n  atime = toUnixTimestamp(atime);\n  mtime = toUnixTimestamp(mtime);\n  binding.utimes(pathModule._makeLong(path), atime, mtime);\n};\n\nfs.futimes = function(fd, atime, mtime, callback) {\n  atime = toUnixTimestamp(atime);\n  mtime = toUnixTimestamp(mtime);\n  var req = new FSReqWrap();\n  req.oncomplete = makeCallback(callback);\n  binding.futimes(fd, atime, mtime, req);\n};\n\nfs.futimesSync = function(fd, atime, mtime) {\n  atime = toUnixTimestamp(atime);\n  mtime = toUnixTimestamp(mtime);\n  binding.futimes(fd, atime, mtime);\n};\n\nfunction writeAll(fd, isUserFd, buffer, offset, length, position, callback) {\n  // write(fd, buffer, offset, length, position, callback)\n  fs.write(fd, buffer, offset, length, position, function(writeErr, written) {\n    if (writeErr) {\n      if (isUserFd) {\n        callback(writeErr);\n      } else {\n        fs.close(fd, function() {\n          callback(writeErr);\n        });\n      }\n    } else {\n      if (written === length) {\n        if (isUserFd) {\n          callback(null);\n        } else {\n          fs.close(fd, callback);\n        }\n      } else {\n        offset += written;\n        length -= written;\n        if (position !== null) {\n          position += written;\n        }\n        writeAll(fd, isUserFd, buffer, offset, length, position, callback);\n      }\n    }\n  });\n}\n\nfs.writeFile = function(path, data, options, callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'w' });\n  const flag = options.flag || 'w';\n\n  if (isFd(path)) {\n    writeFd(path, true);\n    return;\n  }\n\n  fs.open(path, flag, options.mode, function(openErr, fd) {\n    if (openErr) {\n      callback(openErr);\n    } else {\n      writeFd(fd, false);\n    }\n  });\n\n  function writeFd(fd, isUserFd) {\n    var buffer = isUint8Array(data) ?\n        data : Buffer.from('' + data, options.encoding || 'utf8');\n    var position = /a/.test(flag) ? null : 0;\n\n    writeAll(fd, isUserFd, buffer, 0, buffer.length, position, callback);\n  }\n};\n\nfs.writeFileSync = function(path, data, options) {\n  options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'w' });\n  const flag = options.flag || 'w';\n\n  var isUserFd = isFd(path); // file descriptor ownership\n  var fd = isUserFd ? path : fs.openSync(path, flag, options.mode);\n\n  if (!isUint8Array(data)) {\n    data = Buffer.from('' + data, options.encoding || 'utf8');\n  }\n  var offset = 0;\n  var length = data.length;\n  var position = /a/.test(flag) ? null : 0;\n  try {\n    while (length > 0) {\n      var written = fs.writeSync(fd, data, offset, length, position);\n      offset += written;\n      length -= written;\n      if (position !== null) {\n        position += written;\n      }\n    }\n  } finally {\n    if (!isUserFd) fs.closeSync(fd);\n  }\n};\n\nfs.appendFile = function(path, data, options, callback) {\n  callback = maybeCallback(arguments[arguments.length - 1]);\n  options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'a' });\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  // force append behavior when using a supplied file descriptor\n  if (!options.flag || isFd(path))\n    options.flag = 'a';\n\n  fs.writeFile(path, data, options, callback);\n};\n\nfs.appendFileSync = function(path, data, options) {\n  options = getOptions(options, { encoding: 'utf8', mode: 0o666, flag: 'a' });\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  // force append behavior when using a supplied file descriptor\n  if (!options.flag || isFd(path))\n    options.flag = 'a';\n\n  fs.writeFileSync(path, data, options);\n};\n\nfunction FSWatcher() {\n  EventEmitter.call(this);\n\n  var self = this;\n  this._handle = new FSEvent();\n  this._handle.owner = this;\n\n  this._handle.onchange = function(status, eventType, filename) {\n    if (status < 0) {\n      self._handle.close();\n      const error = !filename ?\n          errnoException(status, 'Error watching file for changes:') :\n          errnoException(status,\n                         `Error watching file ${filename} for changes:`);\n      error.filename = filename;\n      self.emit('error', error);\n    } else {\n      self.emit('change', eventType, filename);\n    }\n  };\n}\nutil.inherits(FSWatcher, EventEmitter);\n\nFSWatcher.prototype.start = function(filename,\n                                     persistent,\n                                     recursive,\n                                     encoding) {\n  handleError((filename = getPathFromURL(filename)));\n  nullCheck(filename);\n  var err = this._handle.start(pathModule._makeLong(filename),\n                               persistent,\n                               recursive,\n                               encoding);\n  if (err) {\n    this._handle.close();\n    const error = errnoException(err, `watch ${filename}`);\n    error.filename = filename;\n    throw error;\n  }\n};\n\nFSWatcher.prototype.close = function() {\n  this._handle.close();\n};\n\nfs.watch = function(filename, options, listener) {\n  handleError((filename = getPathFromURL(filename)));\n  nullCheck(filename);\n\n  if (typeof options === 'function') {\n    listener = options;\n  }\n  options = getOptions(options, {});\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  if (options.persistent === undefined) options.persistent = true;\n  if (options.recursive === undefined) options.recursive = false;\n\n  const watcher = new FSWatcher();\n  watcher.start(filename,\n                options.persistent,\n                options.recursive,\n                options.encoding);\n\n  if (listener) {\n    watcher.addListener('change', listener);\n  }\n\n  return watcher;\n};\n\n\n// Stat Change Watchers\n\nfunction emitStop(self) {\n  self.emit('stop');\n}\n\nfunction statsFromPrevValues() {\n  return new Stats(statValues[14], statValues[15], statValues[16],\n                   statValues[17], statValues[18], statValues[19],\n                   statValues[20] < 0 ? undefined : statValues[20],\n                   statValues[21], statValues[22],\n                   statValues[23] < 0 ? undefined : statValues[23],\n                   statValues[24], statValues[25], statValues[26],\n                   statValues[27]);\n}\nfunction StatWatcher() {\n  EventEmitter.call(this);\n\n  var self = this;\n  this._handle = new binding.StatWatcher();\n\n  // uv_fs_poll is a little more powerful than ev_stat but we curb it for\n  // the sake of backwards compatibility\n  var oldStatus = -1;\n\n  this._handle.onchange = function(newStatus) {\n    if (oldStatus === -1 &&\n        newStatus === -1 &&\n        statValues[2/*new nlink*/] === statValues[16/*old nlink*/]) return;\n\n    oldStatus = newStatus;\n    self.emit('change', statsFromValues(), statsFromPrevValues());\n  };\n\n  this._handle.onstop = function() {\n    process.nextTick(emitStop, self);\n  };\n}\nutil.inherits(StatWatcher, EventEmitter);\n\n\nStatWatcher.prototype.start = function(filename, persistent, interval) {\n  handleError((filename = getPathFromURL(filename)));\n  nullCheck(filename);\n  this._handle.start(pathModule._makeLong(filename), persistent, interval);\n};\n\n\nStatWatcher.prototype.stop = function() {\n  this._handle.stop();\n};\n\n\nconst statWatchers = new Map();\n\nfs.watchFile = function(filename, options, listener) {\n  handleError((filename = getPathFromURL(filename)));\n  nullCheck(filename);\n  filename = pathModule.resolve(filename);\n  var stat;\n\n  var defaults = {\n    // Poll interval in milliseconds. 5007 is what libev used to use. It's\n    // a little on the slow side but let's stick with it for now to keep\n    // behavioral changes to a minimum.\n    interval: 5007,\n    persistent: true\n  };\n\n  if (options !== null && typeof options === 'object') {\n    options = util._extend(defaults, options);\n  } else {\n    listener = options;\n    options = defaults;\n  }\n\n  if (typeof listener !== 'function') {\n    throw new Error('\"watchFile()\" requires a listener function');\n  }\n\n  stat = statWatchers.get(filename);\n\n  if (stat === undefined) {\n    stat = new StatWatcher();\n    stat.start(filename, options.persistent, options.interval);\n    statWatchers.set(filename, stat);\n  }\n\n  stat.addListener('change', listener);\n  return stat;\n};\n\nfs.unwatchFile = function(filename, listener) {\n  handleError((filename = getPathFromURL(filename)));\n  nullCheck(filename);\n  filename = pathModule.resolve(filename);\n  var stat = statWatchers.get(filename);\n\n  if (stat === undefined) return;\n\n  if (typeof listener === 'function') {\n    stat.removeListener('change', listener);\n  } else {\n    stat.removeAllListeners('change');\n  }\n\n  if (stat.listenerCount('change') === 0) {\n    stat.stop();\n    statWatchers.delete(filename);\n  }\n};\n\n\nvar splitRoot;\nif (isWindows) {\n  // Regex to find the device root on Windows (e.g. 'c:\\\\'), including trailing\n  // slash.\n  const splitRootRe = /^(?:[a-zA-Z]:|[\\\\/]{2}[^\\\\/]+[\\\\/][^\\\\/]+)?[\\\\/]*/;\n  splitRoot = function splitRoot(str) {\n    return splitRootRe.exec(str)[0];\n  };\n} else {\n  splitRoot = function splitRoot(str) {\n    for (var i = 0; i < str.length; ++i) {\n      if (str.charCodeAt(i) !== 47/*'/'*/)\n        return str.slice(0, i);\n    }\n    return str;\n  };\n}\n\nfunction encodeRealpathResult(result, options) {\n  if (!options || !options.encoding || options.encoding === 'utf8')\n    return result;\n  const asBuffer = Buffer.from(result);\n  if (options.encoding === 'buffer') {\n    return asBuffer;\n  } else {\n    return asBuffer.toString(options.encoding);\n  }\n}\n\n// Finds the next portion of a (partial) path, up to the next path delimiter\nvar nextPart;\nif (isWindows) {\n  nextPart = function nextPart(p, i) {\n    for (; i < p.length; ++i) {\n      const ch = p.charCodeAt(i);\n      if (ch === 92/*'\\'*/ || ch === 47/*'/'*/)\n        return i;\n    }\n    return -1;\n  };\n} else {\n  nextPart = function nextPart(p, i) { return p.indexOf('/', i); };\n}\n\nconst emptyObj = Object.create(null);\nfs.realpathSync = function realpathSync(p, options) {\n  if (!options)\n    options = emptyObj;\n  else\n    options = getOptions(options, emptyObj);\n  if (typeof p !== 'string') {\n    handleError((p = getPathFromURL(p)));\n    if (typeof p !== 'string')\n      p += '';\n  }\n  nullCheck(p);\n  p = pathModule.resolve(p);\n\n  const cache = options[internalFS.realpathCacheKey];\n  const maybeCachedResult = cache && cache.get(p);\n  if (maybeCachedResult) {\n    return maybeCachedResult;\n  }\n\n  const seenLinks = Object.create(null);\n  const knownHard = Object.create(null);\n  const original = p;\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  // Skip over roots\n  current = base = splitRoot(p);\n  pos = current.length;\n\n  // On windows, check that the root exists. On unix there is no need.\n  if (isWindows && !knownHard[base]) {\n    binding.lstat(pathModule._makeLong(base));\n    knownHard[base] = true;\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    var result = nextPart(p, pos);\n    previous = current;\n    if (result === -1) {\n      var last = p.slice(pos);\n      current += last;\n      base = previous + last;\n      pos = p.length;\n    } else {\n      current += p.slice(pos, result + 1);\n      base = previous + p.slice(pos, result);\n      pos = result + 1;\n    }\n\n    // continue if not a symlink, break if a pipe/socket\n    if (knownHard[base] || (cache && cache.get(base) === base)) {\n      if ((statValues[1/*mode*/] & S_IFMT) === S_IFIFO ||\n          (statValues[1/*mode*/] & S_IFMT) === S_IFSOCK) {\n        break;\n      }\n      continue;\n    }\n\n    var resolvedLink;\n    var maybeCachedResolved = cache && cache.get(base);\n    if (maybeCachedResolved) {\n      resolvedLink = maybeCachedResolved;\n    } else {\n      // Use stats array directly to avoid creating an fs.Stats instance just\n      // for our internal use.\n\n      var baseLong = pathModule._makeLong(base);\n      binding.lstat(baseLong);\n\n      if ((statValues[1/*mode*/] & S_IFMT) !== S_IFLNK) {\n        knownHard[base] = true;\n        if (cache) cache.set(base, base);\n        continue;\n      }\n\n      // read the link if it wasn't read before\n      // dev/ino always return 0 on windows, so skip the check.\n      var linkTarget = null;\n      var id;\n      if (!isWindows) {\n        var dev = statValues[0/*dev*/].toString(32);\n        var ino = statValues[7/*ino*/].toString(32);\n        id = `${dev}:${ino}`;\n        if (seenLinks[id]) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        binding.stat(baseLong);\n        linkTarget = binding.readlink(baseLong);\n      }\n      resolvedLink = pathModule.resolve(previous, linkTarget);\n\n      if (cache) cache.set(base, resolvedLink);\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n\n    // Skip over roots\n    current = base = splitRoot(p);\n    pos = current.length;\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      binding.lstat(pathModule._makeLong(base));\n      knownHard[base] = true;\n    }\n  }\n\n  if (cache) cache.set(original, p);\n  return encodeRealpathResult(p, options);\n};\n\n\nfs.realpath = function realpath(p, options, callback) {\n  callback = maybeCallback(typeof options === 'function' ? options : callback);\n  if (!options)\n    options = emptyObj;\n  else\n    options = getOptions(options, emptyObj);\n  if (typeof p !== 'string') {\n    if (handleError((p = getPathFromURL(p)), callback))\n      return;\n    if (typeof p !== 'string')\n      p += '';\n  }\n  if (!nullCheck(p, callback))\n    return;\n  p = pathModule.resolve(p);\n\n  const seenLinks = Object.create(null);\n  const knownHard = Object.create(null);\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  current = base = splitRoot(p);\n  pos = current.length;\n\n  // On windows, check that the root exists. On unix there is no need.\n  if (isWindows && !knownHard[base]) {\n    fs.lstat(base, function(err) {\n      if (err) return callback(err);\n      knownHard[base] = true;\n      LOOP();\n    });\n  } else {\n    process.nextTick(LOOP);\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  function LOOP() {\n    // stop if scanned past end of path\n    if (pos >= p.length) {\n      return callback(null, encodeRealpathResult(p, options));\n    }\n\n    // find the next part\n    var result = nextPart(p, pos);\n    previous = current;\n    if (result === -1) {\n      var last = p.slice(pos);\n      current += last;\n      base = previous + last;\n      pos = p.length;\n    } else {\n      current += p.slice(pos, result + 1);\n      base = previous + p.slice(pos, result);\n      pos = result + 1;\n    }\n\n    // continue if not a symlink, break if a pipe/socket\n    if (knownHard[base]) {\n      if ((statValues[1/*mode*/] & S_IFMT) === S_IFIFO ||\n          (statValues[1/*mode*/] & S_IFMT) === S_IFSOCK) {\n        return callback(null, encodeRealpathResult(p, options));\n      }\n      return process.nextTick(LOOP);\n    }\n\n    return fs.lstat(base, gotStat);\n  }\n\n  function gotStat(err) {\n    if (err) return callback(err);\n\n    // Use stats array directly to avoid creating an fs.Stats instance just for\n    // our internal use.\n\n    // if not a symlink, skip to the next path part\n    if ((statValues[1/*mode*/] & S_IFMT) !== S_IFLNK) {\n      knownHard[base] = true;\n      return process.nextTick(LOOP);\n    }\n\n    // stat & read the link if not read before\n    // call gotTarget as soon as the link target is known\n    // dev/ino always return 0 on windows, so skip the check.\n    let id;\n    if (!isWindows) {\n      var dev = statValues[0/*ino*/].toString(32);\n      var ino = statValues[7/*ino*/].toString(32);\n      id = `${dev}:${ino}`;\n      if (seenLinks[id]) {\n        return gotTarget(null, seenLinks[id], base);\n      }\n    }\n    fs.stat(base, function(err) {\n      if (err) return callback(err);\n\n      fs.readlink(base, function(err, target) {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err, target);\n      });\n    });\n  }\n\n  function gotTarget(err, target, base) {\n    if (err) return callback(err);\n\n    var resolvedLink = pathModule.resolve(previous, target);\n    gotResolvedLink(resolvedLink);\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    current = base = splitRoot(p);\n    pos = current.length;\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base, function(err) {\n        if (err) return callback(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n};\n\nfs.mkdtemp = function(prefix, options, callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options, {});\n  if (!prefix || typeof prefix !== 'string')\n    throw new TypeError('filename prefix is required');\n  if (!nullCheck(prefix, callback)) {\n    return;\n  }\n\n  var req = new FSReqWrap();\n  req.oncomplete = callback;\n\n  binding.mkdtemp(prefix + 'XXXXXX', options.encoding, req);\n};\n\n\nfs.mkdtempSync = function(prefix, options) {\n  if (!prefix || typeof prefix !== 'string')\n    throw new TypeError('filename prefix is required');\n  options = getOptions(options, {});\n  nullCheck(prefix);\n  return binding.mkdtemp(prefix + 'XXXXXX', options.encoding);\n};\n\n\nvar pool;\n\nfunction allocNewPool(poolSize) {\n  pool = Buffer.allocUnsafe(poolSize);\n  pool.used = 0;\n}\n\n\nfs.createReadStream = function(path, options) {\n  return new ReadStream(path, options);\n};\n\nutil.inherits(ReadStream, Readable);\nfs.ReadStream = ReadStream;\n\nfunction ReadStream(path, options) {\n  if (!(this instanceof ReadStream))\n    return new ReadStream(path, options);\n\n  // a little bit bigger buffer and water marks by default\n  options = copyObject(getOptions(options, {}));\n  if (options.highWaterMark === undefined)\n    options.highWaterMark = 64 * 1024;\n\n  Readable.call(this, options);\n\n  handleError((this.path = getPathFromURL(path)));\n  this.fd = options.fd === undefined ? null : options.fd;\n  this.flags = options.flags === undefined ? 'r' : options.flags;\n  this.mode = options.mode === undefined ? 0o666 : options.mode;\n\n  this.start = options.start;\n  this.end = options.end;\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n  this.pos = undefined;\n  this.bytesRead = 0;\n\n  if (this.start !== undefined) {\n    if (typeof this.start !== 'number') {\n      throw new TypeError('\"start\" option must be a Number');\n    }\n    if (this.end === undefined) {\n      this.end = Infinity;\n    } else if (typeof this.end !== 'number') {\n      throw new TypeError('\"end\" option must be a Number');\n    }\n\n    if (this.start > this.end) {\n      throw new Error('\"start\" option must be <= \"end\" option');\n    }\n\n    this.pos = this.start;\n  }\n\n  if (typeof this.fd !== 'number')\n    this.open();\n\n  this.on('end', function() {\n    if (this.autoClose) {\n      this.destroy();\n    }\n  });\n}\n\nfs.FileReadStream = fs.ReadStream; // support the legacy name\n\nReadStream.prototype.open = function() {\n  var self = this;\n  fs.open(this.path, this.flags, this.mode, function(er, fd) {\n    if (er) {\n      if (self.autoClose) {\n        self.destroy();\n      }\n      self.emit('error', er);\n      return;\n    }\n\n    self.fd = fd;\n    self.emit('open', fd);\n    // start the flow of data.\n    self.read();\n  });\n};\n\nReadStream.prototype._read = function(n) {\n  if (typeof this.fd !== 'number')\n    return this.once('open', function() {\n      this._read(n);\n    });\n\n  if (this.destroyed)\n    return;\n\n  if (!pool || pool.length - pool.used < kMinPoolSpace) {\n    // discard the old pool.\n    allocNewPool(this._readableState.highWaterMark);\n  }\n\n  // Grab another reference to the pool in the case that while we're\n  // in the thread pool another read() finishes up the pool, and\n  // allocates a new one.\n  var thisPool = pool;\n  var toRead = Math.min(pool.length - pool.used, n);\n  var start = pool.used;\n\n  if (this.pos !== undefined)\n    toRead = Math.min(this.end - this.pos + 1, toRead);\n\n  // already read everything we were supposed to read!\n  // treat as EOF.\n  if (toRead <= 0)\n    return this.push(null);\n\n  // the actual read.\n  var self = this;\n  fs.read(this.fd, pool, pool.used, toRead, this.pos, onread);\n\n  // move the pool positions, and internal position for reading.\n  if (this.pos !== undefined)\n    this.pos += toRead;\n  pool.used += toRead;\n\n  function onread(er, bytesRead) {\n    if (er) {\n      if (self.autoClose) {\n        self.destroy();\n      }\n      self.emit('error', er);\n    } else {\n      var b = null;\n      if (bytesRead > 0) {\n        self.bytesRead += bytesRead;\n        b = thisPool.slice(start, start + bytesRead);\n      }\n\n      self.push(b);\n    }\n  }\n};\n\n\nReadStream.prototype._destroy = function(err, cb) {\n  this.close(function(err2) {\n    cb(err || err2);\n  });\n};\n\n\nReadStream.prototype.close = function(cb) {\n  if (cb)\n    this.once('close', cb);\n\n  if (this.closed || typeof this.fd !== 'number') {\n    if (typeof this.fd !== 'number') {\n      this.once('open', this.close.bind(this, null));\n      return;\n    }\n    return process.nextTick(() => this.emit('close'));\n  }\n\n  this.closed = true;\n\n  fs.close(this.fd, (er) => {\n    if (er)\n      this.emit('error', er);\n    else\n      this.emit('close');\n  });\n\n  this.fd = null;\n};\n\n\nfs.createWriteStream = function(path, options) {\n  return new WriteStream(path, options);\n};\n\nutil.inherits(WriteStream, Writable);\nfs.WriteStream = WriteStream;\nfunction WriteStream(path, options) {\n  if (!(this instanceof WriteStream))\n    return new WriteStream(path, options);\n\n  options = copyObject(getOptions(options, {}));\n\n  Writable.call(this, options);\n\n  handleError((this.path = getPathFromURL(path)));\n  this.fd = options.fd === undefined ? null : options.fd;\n  this.flags = options.flags === undefined ? 'w' : options.flags;\n  this.mode = options.mode === undefined ? 0o666 : options.mode;\n\n  this.start = options.start;\n  this.autoClose = options.autoClose === undefined ? true : !!options.autoClose;\n  this.pos = undefined;\n  this.bytesWritten = 0;\n\n  if (this.start !== undefined) {\n    if (typeof this.start !== 'number') {\n      throw new TypeError('\"start\" option must be a Number');\n    }\n    if (this.start < 0) {\n      throw new Error('\"start\" must be >= zero');\n    }\n\n    this.pos = this.start;\n  }\n\n  if (options.encoding)\n    this.setDefaultEncoding(options.encoding);\n\n  if (typeof this.fd !== 'number')\n    this.open();\n\n  // dispose on finish.\n  this.once('finish', function() {\n    if (this.autoClose) {\n      this.close();\n    }\n  });\n}\n\nfs.FileWriteStream = fs.WriteStream; // support the legacy name\n\n\nWriteStream.prototype.open = function() {\n  fs.open(this.path, this.flags, this.mode, function(er, fd) {\n    if (er) {\n      if (this.autoClose) {\n        this.destroy();\n      }\n      this.emit('error', er);\n      return;\n    }\n\n    this.fd = fd;\n    this.emit('open', fd);\n  }.bind(this));\n};\n\n\nWriteStream.prototype._write = function(data, encoding, cb) {\n  if (!(data instanceof Buffer))\n    return this.emit('error', new Error('Invalid data'));\n\n  if (typeof this.fd !== 'number')\n    return this.once('open', function() {\n      this._write(data, encoding, cb);\n    });\n\n  var self = this;\n  fs.write(this.fd, data, 0, data.length, this.pos, function(er, bytes) {\n    if (er) {\n      if (self.autoClose) {\n        self.destroy();\n      }\n      return cb(er);\n    }\n    self.bytesWritten += bytes;\n    cb();\n  });\n\n  if (this.pos !== undefined)\n    this.pos += data.length;\n};\n\n\nfunction writev(fd, chunks, position, callback) {\n  function wrapper(err, written) {\n    // Retain a reference to chunks so that they can't be GC'ed too soon.\n    callback(err, written || 0, chunks);\n  }\n\n  const req = new FSReqWrap();\n  req.oncomplete = wrapper;\n  binding.writeBuffers(fd, chunks, position, req);\n}\n\n\nWriteStream.prototype._writev = function(data, cb) {\n  if (typeof this.fd !== 'number')\n    return this.once('open', function() {\n      this._writev(data, cb);\n    });\n\n  const self = this;\n  const len = data.length;\n  const chunks = new Array(len);\n  var size = 0;\n\n  for (var i = 0; i < len; i++) {\n    var chunk = data[i].chunk;\n\n    chunks[i] = chunk;\n    size += chunk.length;\n  }\n\n  writev(this.fd, chunks, this.pos, function(er, bytes) {\n    if (er) {\n      self.destroy();\n      return cb(er);\n    }\n    self.bytesWritten += bytes;\n    cb();\n  });\n\n  if (this.pos !== undefined)\n    this.pos += size;\n};\n\n\nWriteStream.prototype._destroy = ReadStream.prototype._destroy;\nWriteStream.prototype.close = ReadStream.prototype.close;\n\n// There is no shutdown() for files.\nWriteStream.prototype.destroySoon = WriteStream.prototype.end;\n\n// SyncWriteStream is internal. DO NOT USE.\n// This undocumented API was never intended to be made public.\nvar SyncWriteStream = internalFS.SyncWriteStream;\nObject.defineProperty(fs, 'SyncWriteStream', {\n  configurable: true,\n  get: internalUtil.deprecate(() => SyncWriteStream,\n                              'fs.SyncWriteStream is deprecated.', 'DEP0061'),\n  set: internalUtil.deprecate((val) => { SyncWriteStream = val; },\n                              'fs.SyncWriteStream is deprecated.', 'DEP0061')\n});\n\n});"},
    {"fileId":3, "filename":"util.js", "source":"(function (exports, require, module, __filename, __dirname) { // Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst uv = process.binding('uv');\nconst Buffer = require('buffer').Buffer;\nconst internalUtil = require('internal/util');\nconst binding = process.binding('util');\n\nconst isError = internalUtil.isError;\n\nconst inspectDefaultOptions = Object.seal({\n  showHidden: false,\n  depth: 2,\n  colors: false,\n  customInspect: true,\n  showProxy: false,\n  maxArrayLength: 100,\n  breakLength: 60\n});\n\nvar CIRCULAR_ERROR_MESSAGE;\nvar Debug;\n\nfunction tryStringify(arg) {\n  try {\n    return JSON.stringify(arg);\n  } catch (err) {\n    // Populate the circular error message lazily\n    if (!CIRCULAR_ERROR_MESSAGE) {\n      try {\n        const a = {}; a.a = a; JSON.stringify(a);\n      } catch (err) {\n        CIRCULAR_ERROR_MESSAGE = err.message;\n      }\n    }\n    if (err.name === 'TypeError' && err.message === CIRCULAR_ERROR_MESSAGE)\n      return '[Circular]';\n    throw err;\n  }\n}\n\nexports.format = function(f) {\n  if (typeof f !== 'string') {\n    const objects = new Array(arguments.length);\n    for (var index = 0; index < arguments.length; index++) {\n      objects[index] = inspect(arguments[index]);\n    }\n    return objects.join(' ');\n  }\n\n  var argLen = arguments.length;\n\n  if (argLen === 1) return f;\n\n  var str = '';\n  var a = 1;\n  var lastPos = 0;\n  for (var i = 0; i < f.length;) {\n    if (f.charCodeAt(i) === 37/*'%'*/ && i + 1 < f.length) {\n      switch (f.charCodeAt(i + 1)) {\n        case 100: // 'd'\n          if (a >= argLen)\n            break;\n          if (lastPos < i)\n            str += f.slice(lastPos, i);\n          str += Number(arguments[a++]);\n          lastPos = i = i + 2;\n          continue;\n        case 105: // 'i'\n          if (a >= argLen)\n            break;\n          if (lastPos < i)\n            str += f.slice(lastPos, i);\n          str += parseInt(arguments[a++]);\n          lastPos = i = i + 2;\n          continue;\n        case 102: // 'f'\n          if (a >= argLen)\n            break;\n          if (lastPos < i)\n            str += f.slice(lastPos, i);\n          str += parseFloat(arguments[a++]);\n          lastPos = i = i + 2;\n          continue;\n        case 106: // 'j'\n          if (a >= argLen)\n            break;\n          if (lastPos < i)\n            str += f.slice(lastPos, i);\n          str += tryStringify(arguments[a++]);\n          lastPos = i = i + 2;\n          continue;\n        case 115: // 's'\n          if (a >= argLen)\n            break;\n          if (lastPos < i)\n            str += f.slice(lastPos, i);\n          str += String(arguments[a++]);\n          lastPos = i = i + 2;\n          continue;\n        case 37: // '%'\n          if (lastPos < i)\n            str += f.slice(lastPos, i);\n          str += '%';\n          lastPos = i = i + 2;\n          continue;\n      }\n    }\n    ++i;\n  }\n  if (lastPos === 0)\n    str = f;\n  else if (lastPos < f.length)\n    str += f.slice(lastPos);\n  while (a < argLen) {\n    const x = arguments[a++];\n    if (x === null || (typeof x !== 'object' && typeof x !== 'symbol')) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\nexports.deprecate = internalUtil.deprecate;\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (debugEnviron === undefined)\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp(`\\\\b${set}\\\\b`, 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Tries to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3 && arguments[2] !== undefined) {\n    ctx.depth = arguments[2];\n  }\n  if (arguments.length >= 4 && arguments[3] !== undefined) {\n    ctx.colors = arguments[3];\n  }\n  if (typeof opts === 'boolean') {\n    // legacy...\n    ctx.showHidden = opts;\n  }\n  // Set default and user-specified options\n  ctx = Object.assign({}, inspect.defaultOptions, ctx, opts);\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;\n  return formatValue(ctx, obj, ctx.depth);\n}\n\nObject.defineProperty(inspect, 'defaultOptions', {\n  get: function() {\n    return inspectDefaultOptions;\n  },\n  set: function(options) {\n    if (options === null || typeof options !== 'object') {\n      throw new TypeError('\"options\" must be an object');\n    }\n    Object.assign(inspectDefaultOptions, options);\n    return inspectDefaultOptions;\n  }\n});\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = Object.assign(Object.create(null), {\n  'bold': [1, 22],\n  'italic': [3, 23],\n  'underline': [4, 24],\n  'inverse': [7, 27],\n  'white': [37, 39],\n  'grey': [90, 39],\n  'black': [30, 39],\n  'blue': [34, 39],\n  'cyan': [36, 39],\n  'green': [32, 39],\n  'magenta': [35, 39],\n  'red': [31, 39],\n  'yellow': [33, 39]\n});\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = Object.assign(Object.create(null), {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'symbol': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n});\n\nconst customInspectSymbol = internalUtil.customInspectSymbol;\n\nexports.inspect = inspect;\nexports.inspect.custom = customInspectSymbol;\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return `\\u001b[${inspect.colors[style][0]}m${str}` +\n           `\\u001b[${inspect.colors[style][1]}m`;\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = Object.create(null);\n\n  for (var i = 0; i < array.length; i++) {\n    var val = array[i];\n    hash[val] = true;\n  }\n\n  return hash;\n}\n\n\nfunction ensureDebugIsInitialized() {\n  if (Debug === undefined) {\n    const runInDebugContext = require('vm').runInDebugContext;\n    Debug = runInDebugContext('Debug');\n  }\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  if (ctx.showProxy &&\n      ((typeof value === 'object' && value !== null) ||\n       typeof value === 'function')) {\n    var proxy = undefined;\n    var proxyCache = ctx.proxyCache;\n    if (!proxyCache)\n      proxyCache = ctx.proxyCache = new Map();\n    // Determine if we've already seen this object and have\n    // determined that it either is or is not a proxy.\n    if (proxyCache.has(value)) {\n      // We've seen it, if the value is not undefined, it's a Proxy.\n      proxy = proxyCache.get(value);\n    } else {\n      // Haven't seen it. Need to check.\n      // If it's not a Proxy, this will return undefined.\n      // Otherwise, it'll return an array. The first item\n      // is the target, the second item is the handler.\n      // We ignore (and do not return) the Proxy isRevoked property.\n      proxy = binding.getProxyDetails(value);\n      if (proxy) {\n        // We know for a fact that this isn't a Proxy.\n        // Mark it as having already been evaluated.\n        // We do this because this object is passed\n        // recursively to formatValue below in order\n        // for it to get proper formatting, and because\n        // the target and handle objects also might be\n        // proxies... it's unfortunate but necessary.\n        proxyCache.set(proxy, undefined);\n      }\n      // If the object is not a Proxy, then this stores undefined.\n      // This tells the code above that we've already checked and\n      // ruled it out. If the object is a proxy, this caches the\n      // results of the getProxyDetails call.\n      proxyCache.set(value, proxy);\n    }\n    if (proxy) {\n      return 'Proxy ' + formatValue(ctx, proxy, recurseTimes);\n    }\n  }\n\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect && value) {\n    const maybeCustomInspect = value[customInspectSymbol] || value.inspect;\n\n    if (typeof maybeCustomInspect === 'function' &&\n        // Filter out the util module, its inspect function is special\n        maybeCustomInspect !== exports.inspect &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      let ret = maybeCustomInspect.call(value, recurseTimes, ctx);\n\n      // If the custom inspection method returned `this`, don't go into\n      // infinite recursion.\n      if (ret !== value) {\n        if (typeof ret !== 'string') {\n          ret = formatValue(ctx, ret, recurseTimes);\n        }\n        return ret;\n      }\n    }\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n  const symbolKeys = Object.getOwnPropertySymbols(value);\n  const enumSymbolKeys = symbolKeys\n      .filter((key) => Object.prototype.propertyIsEnumerable.call(value, key));\n  keys = keys.concat(enumSymbolKeys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value).concat(symbolKeys);\n  }\n\n  // This could be a boxed primitive (new String(), etc.), check valueOf()\n  // NOTE: Avoid calling `valueOf` on `Date` instance because it will return\n  // a number which, when object has some additional user-stored `keys`,\n  // will be printed out.\n  var formatted;\n  var raw = value;\n  try {\n    // the .valueOf() call can fail for a multitude of reasons\n    if (!isDate(value))\n      raw = value.valueOf();\n  } catch (e) {\n    // ignore...\n  }\n\n  if (typeof raw === 'string') {\n    // for boxed Strings, we have to remove the 0-n indexed entries,\n    // since they just noisy up the output and are redundant\n    keys = keys.filter(function(key) {\n      if (typeof key === 'symbol') {\n        return true;\n      }\n\n      return !(key >= 0 && key < raw.length);\n    });\n  }\n\n  var constructor = internalUtil.getConstructorOf(value);\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (typeof value === 'function') {\n      const ctorName = constructor ? constructor.name : 'Function';\n      return ctx.stylize(\n          `[${ctorName}${value.name ? `: ${value.name}` : ''}]`, 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      if (Number.isNaN(value.getTime())) {\n        return ctx.stylize(value.toString(), 'date');\n      } else {\n        return ctx.stylize(Date.prototype.toISOString.call(value), 'date');\n      }\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n    // now check the `raw` value to handle boxed primitives\n    if (typeof raw === 'string') {\n      formatted = formatPrimitiveNoColor(ctx, raw);\n      return ctx.stylize(`[String: ${formatted}]`, 'string');\n    }\n    if (typeof raw === 'symbol') {\n      formatted = formatPrimitiveNoColor(ctx, raw);\n      return ctx.stylize(`[Symbol: ${formatted}]`, 'symbol');\n    }\n    if (typeof raw === 'number') {\n      formatted = formatPrimitiveNoColor(ctx, raw);\n      return ctx.stylize(`[Number: ${formatted}]`, 'number');\n    }\n    if (typeof raw === 'boolean') {\n      formatted = formatPrimitiveNoColor(ctx, raw);\n      return ctx.stylize(`[Boolean: ${formatted}]`, 'boolean');\n    }\n    // Fast path for ArrayBuffer and SharedArrayBuffer.\n    // Can't do the same for DataView because it has a non-primitive\n    // .buffer property that we need to recurse for.\n    if (binding.isAnyArrayBuffer(value)) {\n      return `${constructor.name}` +\n             ` { byteLength: ${formatNumber(ctx, value.byteLength)} }`;\n    }\n    if (binding.isExternal(value)) {\n      return ctx.stylize('[External]', 'special');\n    }\n  }\n\n  var base = '';\n  var empty = false;\n  var formatter = formatObject;\n  var braces;\n\n  // We can't compare constructors for various objects using a comparison like\n  // `constructor === Array` because the object could have come from a different\n  // context and thus the constructor won't match. Instead we check the\n  // constructor names (including those up the prototype chain where needed) to\n  // determine object types.\n  if (Array.isArray(value)) {\n    // Unset the constructor to prevent \"Array [...]\" for ordinary arrays.\n    if (constructor && constructor.name === 'Array')\n      constructor = null;\n    braces = ['[', ']'];\n    empty = value.length === 0;\n    formatter = formatArray;\n  } else if (binding.isSet(value)) {\n    braces = ['{', '}'];\n    // With `showHidden`, `length` will display as a hidden property for\n    // arrays. For consistency's sake, do the same for `size`, even though this\n    // property isn't selected by Object.getOwnPropertyNames().\n    if (ctx.showHidden)\n      keys.unshift('size');\n    empty = value.size === 0;\n    formatter = formatSet;\n  } else if (binding.isMap(value)) {\n    braces = ['{', '}'];\n    // Ditto.\n    if (ctx.showHidden)\n      keys.unshift('size');\n    empty = value.size === 0;\n    formatter = formatMap;\n  } else if (binding.isAnyArrayBuffer(value)) {\n    braces = ['{', '}'];\n    keys.unshift('byteLength');\n    visibleKeys.byteLength = true;\n  } else if (binding.isDataView(value)) {\n    braces = ['{', '}'];\n    // .buffer goes last, it's not a primitive like the others.\n    keys.unshift('byteLength', 'byteOffset', 'buffer');\n    visibleKeys.byteLength = true;\n    visibleKeys.byteOffset = true;\n    visibleKeys.buffer = true;\n  } else if (binding.isTypedArray(value)) {\n    braces = ['[', ']'];\n    formatter = formatTypedArray;\n    if (ctx.showHidden) {\n      // .buffer goes last, it's not a primitive like the others.\n      keys.unshift('BYTES_PER_ELEMENT',\n                   'length',\n                   'byteLength',\n                   'byteOffset',\n                   'buffer');\n    }\n  } else if (binding.isPromise(value)) {\n    braces = ['{', '}'];\n    formatter = formatPromise;\n  } else if (binding.isMapIterator(value)) {\n    constructor = { name: 'MapIterator' };\n    braces = ['{', '}'];\n    empty = false;\n    formatter = formatCollectionIterator;\n  } else if (binding.isSetIterator(value)) {\n    constructor = { name: 'SetIterator' };\n    braces = ['{', '}'];\n    empty = false;\n    formatter = formatCollectionIterator;\n  } else {\n    // Unset the constructor to prevent \"Object {...}\" for ordinary objects.\n    if (constructor && constructor.name === 'Object')\n      constructor = null;\n    braces = ['{', '}'];\n    empty = true;  // No other data than keys.\n  }\n\n  empty = empty === true && keys.length === 0;\n\n  // Make functions say that they are functions\n  if (typeof value === 'function') {\n    const ctorName = constructor ? constructor.name : 'Function';\n    base = ` [${ctorName}${value.name ? `: ${value.name}` : ''}]`;\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toISOString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  // Make boxed primitive Strings look like such\n  if (typeof raw === 'string') {\n    formatted = formatPrimitiveNoColor(ctx, raw);\n    base = ` [String: ${formatted}]`;\n  }\n\n  // Make boxed primitive Numbers look like such\n  if (typeof raw === 'number') {\n    formatted = formatPrimitiveNoColor(ctx, raw);\n    base = ` [Number: ${formatted}]`;\n  }\n\n  // Make boxed primitive Booleans look like such\n  if (typeof raw === 'boolean') {\n    formatted = formatPrimitiveNoColor(ctx, raw);\n    base = ` [Boolean: ${formatted}]`;\n  }\n\n  // Add constructor name if available\n  if (base === '' && constructor)\n    braces[0] = `${constructor.name} ${braces[0]}`;\n\n  if (empty === true) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else if (Array.isArray(value)) {\n      return ctx.stylize('[Array]', 'special');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output = formatter(ctx, value, recurseTimes, visibleKeys, keys);\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces, ctx.breakLength);\n}\n\n\nfunction formatNumber(ctx, value) {\n  // Format -0 as '-0'. Strict equality won't distinguish 0 from -0.\n  if (Object.is(value, -0))\n    return ctx.stylize('-0', 'number');\n  return ctx.stylize('' + value, 'number');\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (value === undefined)\n    return ctx.stylize('undefined', 'undefined');\n\n  // For some reason typeof null is \"object\", so special case here.\n  if (value === null)\n    return ctx.stylize('null', 'null');\n\n  var type = typeof value;\n\n  if (type === 'string') {\n    var simple = '\\'' +\n                 JSON.stringify(value)\n                     .replace(/^\"|\"$/g, '')\n                     .replace(/'/g, \"\\\\'\")\n                     .replace(/\\\\\"/g, '\"') +\n                 '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (type === 'number')\n    return formatNumber(ctx, value);\n  if (type === 'boolean')\n    return ctx.stylize('' + value, 'boolean');\n  // es6 symbol primitive\n  if (type === 'symbol')\n    return ctx.stylize(value.toString(), 'symbol');\n}\n\n\nfunction formatPrimitiveNoColor(ctx, value) {\n  var stylize = ctx.stylize;\n  ctx.stylize = stylizeNoColor;\n  var str = formatPrimitive(ctx, value);\n  ctx.stylize = stylize;\n  return str;\n}\n\n\nfunction formatError(value) {\n  return value.stack || `[${Error.prototype.toString.call(value)}]`;\n}\n\n\nfunction formatObject(ctx, value, recurseTimes, visibleKeys, keys) {\n  return keys.map(function(key) {\n    return formatProperty(ctx, value, recurseTimes, visibleKeys, key, false);\n  });\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  let visibleLength = 0;\n  let index = 0;\n  while (index < value.length && visibleLength < ctx.maxArrayLength) {\n    let emptyItems = 0;\n    while (index < value.length && !hasOwnProperty(value, String(index))) {\n      emptyItems++;\n      index++;\n    }\n    if (emptyItems > 0) {\n      const ending = emptyItems > 1 ? 's' : '';\n      const message = `<${emptyItems} empty item${ending}>`;\n      output.push(ctx.stylize(message, 'undefined'));\n    } else {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n                                 String(index), true));\n      index++;\n    }\n    visibleLength++;\n  }\n  var remaining = value.length - index;\n  if (remaining > 0) {\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  for (var n = 0; n < keys.length; n++) {\n    var key = keys[n];\n    if (typeof key === 'symbol' || !key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n                                 key, true));\n    }\n  }\n  return output;\n}\n\n\nfunction formatTypedArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), value.length);\n  const remaining = value.length - maxLength;\n  var output = new Array(maxLength);\n  for (var i = 0; i < maxLength; ++i)\n    output[i] = formatNumber(ctx, value[i]);\n  if (remaining > 0) {\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  for (const key of keys) {\n    if (typeof key === 'symbol' || !key.match(/^\\d+$/)) {\n      output.push(\n          formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));\n    }\n  }\n  return output;\n}\n\n\nfunction formatSet(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  value.forEach(function(v) {\n    var nextRecurseTimes = recurseTimes === null ? null : recurseTimes - 1;\n    var str = formatValue(ctx, v, nextRecurseTimes);\n    output.push(str);\n  });\n  for (var n = 0; n < keys.length; n++) {\n    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n                               keys[n], false));\n  }\n  return output;\n}\n\n\nfunction formatMap(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  value.forEach(function(v, k) {\n    var nextRecurseTimes = recurseTimes === null ? null : recurseTimes - 1;\n    var str = formatValue(ctx, k, nextRecurseTimes);\n    str += ' => ';\n    str += formatValue(ctx, v, nextRecurseTimes);\n    output.push(str);\n  });\n  for (var n = 0; n < keys.length; n++) {\n    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n                               keys[n], false));\n  }\n  return output;\n}\n\nfunction formatCollectionIterator(ctx, value, recurseTimes, visibleKeys, keys) {\n  ensureDebugIsInitialized();\n  const mirror = Debug.MakeMirror(value, true);\n  var nextRecurseTimes = recurseTimes === null ? null : recurseTimes - 1;\n  var vals = mirror.preview();\n  var output = [];\n  for (const o of vals) {\n    output.push(formatValue(ctx, o, nextRecurseTimes));\n  }\n  return output;\n}\n\nfunction formatPromise(ctx, value, recurseTimes, visibleKeys, keys) {\n  const output = [];\n  const [state, result] = binding.getPromiseDetails(value);\n\n  if (state === binding.kPending) {\n    output.push('<pending>');\n  } else {\n    var nextRecurseTimes = recurseTimes === null ? null : recurseTimes - 1;\n    var str = formatValue(ctx, result, nextRecurseTimes);\n    if (state === binding.kRejected) {\n      output.push('<rejected> ' + str);\n    } else {\n      output.push(str);\n    }\n  }\n  for (var n = 0; n < keys.length; n++) {\n    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n                               keys[n], false));\n  }\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    if (typeof key === 'symbol') {\n      name = `[${ctx.stylize(key.toString(), 'symbol')}]`;\n    } else {\n      name = `[${key}]`;\n    }\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (recurseTimes === null) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.replace(/\\n/g, '\\n  ');\n        } else {\n          str = str.replace(/(^|\\n)/g, '\\n   ');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (name === undefined) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\")\n                 .replace(/\\\\\\\\/g, '\\\\');\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return `${name}: ${str}`;\n}\n\n\nfunction reduceToSingleString(output, base, braces, breakLength) {\n  var length = output.reduce(function(prev, cur) {\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > breakLength) {\n    return braces[0] +\n           // If the opening \"brace\" is too large, like in the case of \"Set {\",\n           // we need to force the first item to be on the next line or the\n           // items will not line up correctly.\n           (base === '' && braces[0].length === 1 ? '' : base + '\\n ') +\n           ` ${output.join(',\\n  ')} ${braces[1]}`;\n  }\n\n  return `${braces[0]}${base} ${output.join(', ')} ${braces[1]}`;\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nexports.isArray = Array.isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg === null || arg === undefined;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === undefined;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return binding.isRegExp(re);\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return arg !== null && typeof arg === 'object';\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return binding.isDate(d);\n}\nexports.isDate = isDate;\n\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg !== 'object' && typeof arg !== 'function';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nconst months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n                'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n * @throws {TypeError} Will error if either constructor is null, or if\n *     the super constructor lacks a prototype.\n */\nexports.inherits = function(ctor, superCtor) {\n\n  if (ctor === undefined || ctor === null)\n    throw new TypeError('The constructor to \"inherits\" must not be ' +\n                        'null or undefined');\n\n  if (superCtor === undefined || superCtor === null)\n    throw new TypeError('The super constructor to \"inherits\" must not ' +\n                        'be null or undefined');\n\n  if (superCtor.prototype === undefined)\n    throw new TypeError('The super constructor to \"inherits\" must ' +\n                        'have a prototype');\n\n  ctor.super_ = superCtor;\n  Object.setPrototypeOf(ctor.prototype, superCtor.prototype);\n};\n\nexports._extend = function(target, source) {\n  // Don't do anything if source isn't an object\n  if (source === null || typeof source !== 'object') return target;\n\n  var keys = Object.keys(source);\n  var i = keys.length;\n  while (i--) {\n    target[keys[i]] = source[keys[i]];\n  }\n  return target;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n\n// Deprecated old stuff.\n\nexports.print = internalUtil.deprecate(function() {\n  for (var i = 0, len = arguments.length; i < len; ++i) {\n    process.stdout.write(String(arguments[i]));\n  }\n}, 'util.print is deprecated. Use console.log instead.', 'DEP0026');\n\n\nexports.puts = internalUtil.deprecate(function() {\n  for (var i = 0, len = arguments.length; i < len; ++i) {\n    process.stdout.write(arguments[i] + '\\n');\n  }\n}, 'util.puts is deprecated. Use console.log instead.', 'DEP0027');\n\n\nexports.debug = internalUtil.deprecate(function(x) {\n  process.stderr.write(`DEBUG: ${x}\\n`);\n}, 'util.debug is deprecated. Use console.error instead.', 'DEP0028');\n\n\nexports.error = internalUtil.deprecate(function(x) {\n  for (var i = 0, len = arguments.length; i < len; ++i) {\n    process.stderr.write(arguments[i] + '\\n');\n  }\n}, 'util.error is deprecated. Use console.error instead.', 'DEP0029');\n\n\nexports._errnoException = function(err, syscall, original) {\n  var errname = uv.errname(err);\n  var message = `${syscall} ${errname}`;\n  if (original)\n    message += ' ' + original;\n  var e = new Error(message);\n  e.code = errname;\n  e.errno = errname;\n  e.syscall = syscall;\n  return e;\n};\n\n\nexports._exceptionWithHostPort = function(err,\n                                          syscall,\n                                          address,\n                                          port,\n                                          additional) {\n  var details;\n  if (port && port > 0) {\n    details = `${address}:${port}`;\n  } else {\n    details = address;\n  }\n\n  if (additional) {\n    details += ` - Local (${additional})`;\n  }\n  var ex = exports._errnoException(err, syscall, details);\n  ex.address = address;\n  if (port) {\n    ex.port = port;\n  }\n  return ex;\n};\n\n// process.versions needs a custom function as some values are lazy-evaluated.\nprocess.versions[exports.inspect.custom] =\n  (depth) => exports.format(JSON.parse(JSON.stringify(process.versions)));\n\nexports.promisify = internalUtil.promisify;\n\n});"},
    {"fileId":4, "filename":"internal/process/warning.js", "source":"(function (exports, require, module, __filename, __dirname) { 'use strict';\n\nconst config = process.binding('config');\nconst prefix = `(${process.release.name}:${process.pid}) `;\n\nexports.setup = setupProcessWarnings;\n\nvar errors;\nvar fs;\nvar cachedFd;\nvar acquiringFd = false;\nfunction nop() {}\n\nfunction lazyErrors() {\n  if (!errors)\n    errors = require('internal/errors');\n  return errors;\n}\n\nfunction lazyFs() {\n  if (!fs)\n    fs = require('fs');\n  return fs;\n}\n\nfunction writeOut(message) {\n  if (console && typeof console.error === 'function')\n    return console.error(message);\n  process._rawDebug(message);\n}\n\nfunction onClose(fd) {\n  return function() {\n    lazyFs().close(fd, nop);\n  };\n}\n\nfunction onOpen(cb) {\n  return function(err, fd) {\n    acquiringFd = false;\n    if (fd !== undefined) {\n      cachedFd = fd;\n      process.on('exit', onClose(fd));\n    }\n    cb(err, fd);\n    process.emit('_node_warning_fd_acquired', err, fd);\n  };\n}\n\nfunction onAcquired(message) {\n  // make a best effort attempt at writing the message\n  // to the fd. Errors are ignored at this point.\n  return function(err, fd) {\n    if (err)\n      return writeOut(message);\n    lazyFs().appendFile(fd, `${message}\\n`, nop);\n  };\n}\n\nfunction acquireFd(cb) {\n  if (cachedFd === undefined && !acquiringFd) {\n    acquiringFd = true;\n    lazyFs().open(config.warningFile, 'a', onOpen(cb));\n  } else if (cachedFd !== undefined && !acquiringFd) {\n    cb(null, cachedFd);\n  } else {\n    process.once('_node_warning_fd_acquired', cb);\n  }\n}\n\nfunction output(message) {\n  if (typeof config.warningFile === 'string') {\n    acquireFd(onAcquired(message));\n    return;\n  }\n  writeOut(message);\n}\n\nfunction doEmitWarning(warning) {\n  return function() {\n    process.emit('warning', warning);\n  };\n}\n\nfunction setupProcessWarnings() {\n  if (!process.noProcessWarnings && process.env.NODE_NO_WARNINGS !== '1') {\n    process.on('warning', (warning) => {\n      if (!(warning instanceof Error)) return;\n      const isDeprecation = warning.name === 'DeprecationWarning';\n      if (isDeprecation && process.noDeprecation) return;\n      const trace = process.traceProcessWarnings ||\n                    (isDeprecation && process.traceDeprecation);\n      let msg = `${prefix}`;\n      if (warning.code)\n        msg += `[${warning.code}] `;\n      if (trace && warning.stack) {\n        msg += `${warning.stack}`;\n      } else {\n        const toString =\n          typeof warning.toString === 'function' ?\n            warning.toString : Error.prototype.toString;\n        msg += `${toString.apply(warning)}`;\n      }\n      if (typeof warning.detail === 'string') {\n        msg += `\\n${warning.detail}`;\n      }\n      output(msg);\n    });\n  }\n\n  // process.emitWarning(error)\n  // process.emitWarning(str[, type[, code]][, ctor])\n  // process.emitWarning(str[, options])\n  process.emitWarning = function(warning, type, code, ctor) {\n    const errors = lazyErrors();\n    var detail;\n    if (type !== null && typeof type === 'object' && !Array.isArray(type)) {\n      ctor = type.ctor;\n      code = type.code;\n      if (typeof type.detail === 'string')\n        detail = type.detail;\n      type = type.type || 'Warning';\n    } else if (typeof type === 'function') {\n      ctor = type;\n      code = undefined;\n      type = 'Warning';\n    }\n    if (typeof code === 'function') {\n      ctor = code;\n      code = undefined;\n    }\n    if (code !== undefined && typeof code !== 'string')\n      throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 'code', 'string');\n    if (type !== undefined && typeof type !== 'string')\n      throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 'type', 'string');\n    if (warning === undefined || typeof warning === 'string') {\n      warning = new Error(warning);\n      warning.name = String(type || 'Warning');\n      if (code !== undefined) warning.code = code;\n      if (detail !== undefined) warning.detail = detail;\n      Error.captureStackTrace(warning, ctor || process.emitWarning);\n    }\n    if (!(warning instanceof Error)) {\n      throw new errors.TypeError('ERR_INVALID_ARG_TYPE',\n                                 'warning', ['Error', 'string']);\n    }\n    if (warning.name === 'DeprecationWarning') {\n      if (process.noDeprecation)\n        return;\n      if (process.throwDeprecation)\n        throw warning;\n    }\n    process.nextTick(doEmitWarning(warning));\n  };\n}\n\n});"},
    {"fileId":5, "filename":"_stream_writable.js", "source":"(function (exports, require, module, __filename, __dirname) { // Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\nWritable.WritableState = WritableState;\n\nconst util = require('util');\nconst internalUtil = require('internal/util');\nconst Stream = require('stream');\nconst Buffer = require('buffer').Buffer;\nconst destroyImpl = require('internal/streams/destroy');\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  options = options || {};\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Stream.Duplex)\n    this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = onwrite.bind(undefined, stream);\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  var corkReq = { next: null, entry: null, finish: undefined };\n  corkReq.finish = onCorkedFinish.bind(undefined, corkReq, this);\n  this.corkedRequestsFree = corkReq;\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\nObject.defineProperty(WritableState.prototype, 'buffer', {\n  get: internalUtil.deprecate(function() {\n    return this.getBuffer();\n  }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' +\n     'instead.', 'DEP0003')\n});\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance) {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function(object) {\n      if (realHasInstance.call(this, object))\n        return true;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function(object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!(realHasInstance.call(Writable, this)) &&\n      !(this instanceof Stream.Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function')\n      this._write = options.write;\n\n    if (typeof options.writev === 'function')\n      this._writev = options.writev;\n\n    if (typeof options.destroy === 'function')\n      this._destroy = options.destroy;\n\n    if (typeof options.final === 'function')\n      this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  process.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' &&\n             chunk !== undefined &&\n             !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    process.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = (chunk instanceof Buffer);\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf)\n    encoding = 'buffer';\n  else if (!encoding)\n    encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function')\n    cb = nop;\n\n  if (state.ended)\n    writeAfterEnd(this, cb);\n  else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function() {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function() {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing &&\n        !state.corked &&\n        !state.finished &&\n        !state.bufferProcessing &&\n        state.bufferedRequest)\n      clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string')\n    encoding = encoding.toLowerCase();\n  if (!Buffer.isEncoding(encoding))\n    throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &&\n      state.decodeStrings !== false &&\n      typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk,\n      encoding,\n      isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev)\n    stream._writev(chunk, state.onwrite);\n  else\n    stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync)\n    process.nextTick(afterError, stream, state, cb, er);\n  else\n    afterError(stream, state, cb, er);\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction afterError(stream, state, cb, err) {\n  cb(err);\n  finishMaybe(stream, state);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er)\n    onwriteError(stream, state, sync, er, cb);\n  else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished &&\n        !state.corked &&\n        !state.bufferProcessing &&\n        state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished)\n    onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf)\n        allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      var corkReq = { next: null, entry: null, finish: undefined };\n      corkReq.finish = onCorkedFinish.bind(undefined, corkReq, state);\n      state.corkedRequestsFree = corkReq;\n    }\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null)\n      state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequestCount = 0;\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined)\n    this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished)\n    endWritable(this, state, cb);\n};\n\n\nfunction needFinish(state) {\n  return (state.ending &&\n          state.length === 0 &&\n          state.bufferedRequest === null &&\n          !state.finished &&\n          !state.writing);\n}\nfunction callFinal(stream, state) {\n  stream._final((err) => {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished)\n      process.nextTick(cb);\n    else\n      stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function(err, cb) {\n  this.end();\n  cb(err);\n};\n\n});"},
    {"fileId":6, "filename":"_stream_duplex.js", "source":"(function (exports, require, module, __filename, __dirname) { // Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\nmodule.exports = Duplex;\n\nconst util = require('util');\nconst Readable = require('_stream_readable');\nconst Writable = require('_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nvar keys = Object.keys(Writable.prototype);\nfor (var v = 0; v < keys.length; v++) {\n  var method = keys[v];\n  if (!Duplex.prototype[method])\n    Duplex.prototype[method] = Writable.prototype[method];\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false)\n    this.readable = false;\n\n  if (options && options.writable === false)\n    this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false)\n    this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended)\n    return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get() {\n    if (this._readableState === undefined ||\n        this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined ||\n        this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function(err, cb) {\n  this.push(null);\n  this.end();\n\n  process.nextTick(cb, err);\n};\n\n});"},
    {"fileId":7, "filename":"module.js", "source":"(function (exports, require, module, __filename, __dirname) { // Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst NativeModule = require('native_module');\nconst util = require('util');\nconst internalModule = require('internal/module');\nconst vm = require('vm');\nconst assert = require('assert').ok;\nconst fs = require('fs');\nconst internalFS = require('internal/fs');\nconst path = require('path');\nconst internalModuleReadFile = process.binding('fs').internalModuleReadFile;\nconst internalModuleStat = process.binding('fs').internalModuleStat;\nconst preserveSymlinks = !!process.binding('config').preserveSymlinks;\n\nfunction stat(filename) {\n  filename = path._makeLong(filename);\n  const cache = stat.cache;\n  if (cache !== null) {\n    const result = cache.get(filename);\n    if (result !== undefined) return result;\n  }\n  const result = internalModuleStat(filename);\n  if (cache !== null) cache.set(filename, result);\n  return result;\n}\nstat.cache = null;\n\n\nfunction Module(id, parent) {\n  this.id = id;\n  this.exports = {};\n  this.parent = parent;\n  if (parent && parent.children) {\n    parent.children.push(this);\n  }\n\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n}\nmodule.exports = Module;\n\nModule._cache = Object.create(null);\nModule._pathCache = Object.create(null);\nModule._extensions = Object.create(null);\nvar modulePaths = [];\nModule.globalPaths = [];\n\nModule.wrapper = NativeModule.wrapper;\nModule.wrap = NativeModule.wrap;\nModule._debug = util.debuglog('module');\n\n// We use this alias for the preprocessor that filters it out\nconst debug = Module._debug;\n\n\n// given a module name, and a list of paths to test, returns the first\n// matching file in the following precedence.\n//\n// require(\"a.<ext>\")\n//   -> a.<ext>\n//\n// require(\"a\")\n//   -> a\n//   -> a.<ext>\n//   -> a/index.<ext>\n\n// check if the directory is a package.json dir\nconst packageMainCache = Object.create(null);\n\nfunction readPackage(requestPath) {\n  const entry = packageMainCache[requestPath];\n  if (entry)\n    return entry;\n\n  const jsonPath = path.resolve(requestPath, 'package.json');\n  const json = internalModuleReadFile(path._makeLong(jsonPath));\n\n  if (json === undefined) {\n    return false;\n  }\n\n  try {\n    var pkg = packageMainCache[requestPath] = JSON.parse(json).main;\n  } catch (e) {\n    e.path = jsonPath;\n    e.message = 'Error parsing ' + jsonPath + ': ' + e.message;\n    throw e;\n  }\n  return pkg;\n}\n\nfunction tryPackage(requestPath, exts, isMain) {\n  var pkg = readPackage(requestPath);\n\n  if (!pkg) return false;\n\n  var filename = path.resolve(requestPath, pkg);\n  return tryFile(filename, isMain) ||\n         tryExtensions(filename, exts, isMain) ||\n         tryExtensions(path.resolve(filename, 'index'), exts, isMain);\n}\n\n// In order to minimize unnecessary lstat() calls,\n// this cache is a list of known-real paths.\n// Set to an empty Map to reset.\nconst realpathCache = new Map();\n\n// check if the file exists and is not a directory\n// if using --preserve-symlinks and isMain is false,\n// keep symlinks intact, otherwise resolve to the\n// absolute realpath.\nfunction tryFile(requestPath, isMain) {\n  const rc = stat(requestPath);\n  if (preserveSymlinks && !isMain) {\n    return rc === 0 && path.resolve(requestPath);\n  }\n  return rc === 0 && toRealPath(requestPath);\n}\n\nfunction toRealPath(requestPath) {\n  return fs.realpathSync(requestPath, {\n    [internalFS.realpathCacheKey]: realpathCache\n  });\n}\n\n// given a path check a the file exists with any of the set extensions\nfunction tryExtensions(p, exts, isMain) {\n  for (var i = 0; i < exts.length; i++) {\n    const filename = tryFile(p + exts[i], isMain);\n\n    if (filename) {\n      return filename;\n    }\n  }\n  return false;\n}\n\nvar warned = false;\nModule._findPath = function(request, paths, isMain) {\n  if (path.isAbsolute(request)) {\n    paths = [''];\n  } else if (!paths || paths.length === 0) {\n    return false;\n  }\n\n  var cacheKey = request + '\\x00' +\n                (paths.length === 1 ? paths[0] : paths.join('\\x00'));\n  var entry = Module._pathCache[cacheKey];\n  if (entry)\n    return entry;\n\n  var exts;\n  var trailingSlash = request.length > 0 &&\n                      request.charCodeAt(request.length - 1) === 47/*/*/;\n\n  // For each path\n  for (var i = 0; i < paths.length; i++) {\n    // Don't search further if path doesn't exist\n    const curPath = paths[i];\n    if (curPath && stat(curPath) < 1) continue;\n    var basePath = path.resolve(curPath, request);\n    var filename;\n\n    var rc = stat(basePath);\n    if (!trailingSlash) {\n      if (rc === 0) {  // File.\n        if (preserveSymlinks && !isMain) {\n          filename = path.resolve(basePath);\n        } else {\n          filename = toRealPath(basePath);\n        }\n      } else if (rc === 1) {  // Directory.\n        if (exts === undefined)\n          exts = Object.keys(Module._extensions);\n        filename = tryPackage(basePath, exts, isMain);\n      }\n\n      if (!filename) {\n        // try it with each of the extensions\n        if (exts === undefined)\n          exts = Object.keys(Module._extensions);\n        filename = tryExtensions(basePath, exts, isMain);\n      }\n    }\n\n    if (!filename && rc === 1) {  // Directory.\n      if (exts === undefined)\n        exts = Object.keys(Module._extensions);\n      filename = tryPackage(basePath, exts, isMain);\n    }\n\n    if (!filename && rc === 1) {  // Directory.\n      // try it with each of the extensions at \"index\"\n      if (exts === undefined)\n        exts = Object.keys(Module._extensions);\n      filename = tryExtensions(path.resolve(basePath, 'index'), exts, isMain);\n    }\n\n    if (filename) {\n      // Warn once if '.' resolved outside the module dir\n      if (request === '.' && i > 0) {\n        if (!warned) {\n          warned = true;\n          process.emitWarning(\n            'warning: require(\\'.\\') resolved outside the package ' +\n            'directory. This functionality is deprecated and will be removed ' +\n            'soon.',\n            'DeprecationWarning', 'DEP0019');\n        }\n      }\n\n      Module._pathCache[cacheKey] = filename;\n      return filename;\n    }\n  }\n  return false;\n};\n\n// 'node_modules' character codes reversed\nvar nmChars = [ 115, 101, 108, 117, 100, 111, 109, 95, 101, 100, 111, 110 ];\nvar nmLen = nmChars.length;\nif (process.platform === 'win32') {\n  // 'from' is the __dirname of the module.\n  Module._nodeModulePaths = function(from) {\n    // guarantee that 'from' is absolute.\n    from = path.resolve(from);\n\n    // note: this approach *only* works when the path is guaranteed\n    // to be absolute.  Doing a fully-edge-case-correct path.split\n    // that works on both Windows and Posix is non-trivial.\n\n    // return root node_modules when path is 'D:\\\\'.\n    // path.resolve will make sure from.length >=3 in Windows.\n    if (from.charCodeAt(from.length - 1) === 92/*\\*/ &&\n        from.charCodeAt(from.length - 2) === 58/*:*/)\n      return [from + 'node_modules'];\n\n    const paths = [];\n    var p = 0;\n    var last = from.length;\n    for (var i = from.length - 1; i >= 0; --i) {\n      const code = from.charCodeAt(i);\n      // The path segment separator check ('\\' and '/') was used to get\n      // node_modules path for every path segment.\n      // Use colon as an extra condition since we can get node_modules\n      // path for drive root like 'C:\\node_modules' and don't need to\n      // parse drive name.\n      if (code === 92/*\\*/ || code === 47/*/*/ || code === 58/*:*/) {\n        if (p !== nmLen)\n          paths.push(from.slice(0, last) + '\\\\node_modules');\n        last = i;\n        p = 0;\n      } else if (p !== -1) {\n        if (nmChars[p] === code) {\n          ++p;\n        } else {\n          p = -1;\n        }\n      }\n    }\n\n    return paths;\n  };\n} else { // posix\n  // 'from' is the __dirname of the module.\n  Module._nodeModulePaths = function(from) {\n    // guarantee that 'from' is absolute.\n    from = path.resolve(from);\n    // Return early not only to avoid unnecessary work, but to *avoid* returning\n    // an array of two items for a root: [ '//node_modules', '/node_modules' ]\n    if (from === '/')\n      return ['/node_modules'];\n\n    // note: this approach *only* works when the path is guaranteed\n    // to be absolute.  Doing a fully-edge-case-correct path.split\n    // that works on both Windows and Posix is non-trivial.\n    const paths = [];\n    var p = 0;\n    var last = from.length;\n    for (var i = from.length - 1; i >= 0; --i) {\n      const code = from.charCodeAt(i);\n      if (code === 47/*/*/) {\n        if (p !== nmLen)\n          paths.push(from.slice(0, last) + '/node_modules');\n        last = i;\n        p = 0;\n      } else if (p !== -1) {\n        if (nmChars[p] === code) {\n          ++p;\n        } else {\n          p = -1;\n        }\n      }\n    }\n\n    // Append /node_modules to handle root paths.\n    paths.push('/node_modules');\n\n    return paths;\n  };\n}\n\n\n// 'index.' character codes\nvar indexChars = [ 105, 110, 100, 101, 120, 46 ];\nvar indexLen = indexChars.length;\nModule._resolveLookupPaths = function(request, parent, newReturn) {\n  if (NativeModule.nonInternalExists(request)) {\n    debug('looking for %j in []', request);\n    return (newReturn ? null : [request, []]);\n  }\n\n  // Check for relative path\n  if (request.length < 2 ||\n      request.charCodeAt(0) !== 46/*.*/ ||\n      (request.charCodeAt(1) !== 46/*.*/ &&\n       request.charCodeAt(1) !== 47/*/*/)) {\n    var paths = modulePaths;\n    if (parent) {\n      if (!parent.paths)\n        paths = parent.paths = [];\n      else\n        paths = parent.paths.concat(paths);\n    }\n\n    // Maintain backwards compat with certain broken uses of require('.')\n    // by putting the module's directory in front of the lookup paths.\n    if (request === '.') {\n      if (parent && parent.filename) {\n        paths.unshift(path.dirname(parent.filename));\n      } else {\n        paths.unshift(path.resolve(request));\n      }\n    }\n\n    debug('looking for %j in %j', request, paths);\n    return (newReturn ? (paths.length > 0 ? paths : null) : [request, paths]);\n  }\n\n  // with --eval, parent.id is not set and parent.filename is null\n  if (!parent || !parent.id || !parent.filename) {\n    // make require('./path/to/foo') work - normally the path is taken\n    // from realpath(__filename) but with eval there is no filename\n    var mainPaths = ['.'].concat(Module._nodeModulePaths('.'), modulePaths);\n\n    debug('looking for %j in %j', request, mainPaths);\n    return (newReturn ? mainPaths : [request, mainPaths]);\n  }\n\n  // Is the parent an index module?\n  // We can assume the parent has a valid extension,\n  // as it already has been accepted as a module.\n  const base = path.basename(parent.filename);\n  var parentIdPath;\n  if (base.length > indexLen) {\n    var i = 0;\n    for (; i < indexLen; ++i) {\n      if (indexChars[i] !== base.charCodeAt(i))\n        break;\n    }\n    if (i === indexLen) {\n      // We matched 'index.', let's validate the rest\n      for (; i < base.length; ++i) {\n        const code = base.charCodeAt(i);\n        if (code !== 95/*_*/ &&\n            (code < 48/*0*/ || code > 57/*9*/) &&\n            (code < 65/*A*/ || code > 90/*Z*/) &&\n            (code < 97/*a*/ || code > 122/*z*/))\n          break;\n      }\n      if (i === base.length) {\n        // Is an index module\n        parentIdPath = parent.id;\n      } else {\n        // Not an index module\n        parentIdPath = path.dirname(parent.id);\n      }\n    } else {\n      // Not an index module\n      parentIdPath = path.dirname(parent.id);\n    }\n  } else {\n    // Not an index module\n    parentIdPath = path.dirname(parent.id);\n  }\n  var id = path.resolve(parentIdPath, request);\n\n  // make sure require('./path') and require('path') get distinct ids, even\n  // when called from the toplevel js file\n  if (parentIdPath === '.' && id.indexOf('/') === -1) {\n    id = './' + id;\n  }\n\n  debug('RELATIVE: requested: %s set ID to: %s from %s', request, id,\n        parent.id);\n\n  var parentDir = [path.dirname(parent.filename)];\n  debug('looking for %j in %j', id, parentDir);\n  return (newReturn ? parentDir : [id, parentDir]);\n};\n\n\n// Check the cache for the requested file.\n// 1. If a module already exists in the cache: return its exports object.\n// 2. If the module is native: call `NativeModule.require()` with the\n//    filename and return the result.\n// 3. Otherwise, create a new module for the file and save it to the cache.\n//    Then have it load  the file contents before returning its exports\n//    object.\nModule._load = function(request, parent, isMain) {\n  if (parent) {\n    debug('Module._load REQUEST %s parent: %s', request, parent.id);\n  }\n\n  var filename = Module._resolveFilename(request, parent, isMain);\n\n  var cachedModule = Module._cache[filename];\n  if (cachedModule) {\n    return cachedModule.exports;\n  }\n\n  if (NativeModule.nonInternalExists(filename)) {\n    debug('load native module %s', request);\n    return NativeModule.require(filename);\n  }\n\n  var module = new Module(filename, parent);\n\n  if (isMain) {\n    process.mainModule = module;\n    module.id = '.';\n  }\n\n  Module._cache[filename] = module;\n\n  tryModuleLoad(module, filename);\n\n  return module.exports;\n};\n\nfunction tryModuleLoad(module, filename) {\n  var threw = true;\n  try {\n    module.load(filename);\n    threw = false;\n  } finally {\n    if (threw) {\n      delete Module._cache[filename];\n    }\n  }\n}\n\nModule._resolveFilename = function(request, parent, isMain) {\n  if (NativeModule.nonInternalExists(request)) {\n    return request;\n  }\n\n  var paths = Module._resolveLookupPaths(request, parent, true);\n\n  // look up the filename first, since that's the cache key.\n  var filename = Module._findPath(request, paths, isMain);\n  if (!filename) {\n    var err = new Error(`Cannot find module '${request}'`);\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  }\n  return filename;\n};\n\n\n// Given a file name, pass it to the proper extension handler.\nModule.prototype.load = function(filename) {\n  debug('load %j for module %j', filename, this.id);\n\n  assert(!this.loaded);\n  this.filename = filename;\n  this.paths = Module._nodeModulePaths(path.dirname(filename));\n\n  var extension = path.extname(filename) || '.js';\n  if (!Module._extensions[extension]) extension = '.js';\n  Module._extensions[extension](this, filename);\n  this.loaded = true;\n};\n\n\n// Loads a module at the given file path. Returns that module's\n// `exports` property.\nModule.prototype.require = function(path) {\n  assert(path, 'missing path');\n  assert(typeof path === 'string', 'path must be a string');\n  return Module._load(path, this, /* isMain */ false);\n};\n\n\n// Resolved path to process.argv[1] will be lazily placed here\n// (needed for setting breakpoint when called with --inspect-brk)\nvar resolvedArgv;\n\n\n// Run the file contents in the correct scope or sandbox. Expose\n// the correct helper variables (require, module, exports) to\n// the file.\n// Returns exception, if any.\nModule.prototype._compile = function(content, filename) {\n\n  content = internalModule.stripShebang(content);\n\n  // create wrapper function\n  var wrapper = Module.wrap(content);\n\n  var compiledWrapper = vm.runInThisContext(wrapper, {\n    filename: filename,\n    lineOffset: 0,\n    displayErrors: true\n  });\n\n  var inspectorWrapper = null;\n  if (process._debugWaitConnect && process._eval == null) {\n    if (!resolvedArgv) {\n      // we enter the repl if we're not given a filename argument.\n      if (process.argv[1]) {\n        resolvedArgv = Module._resolveFilename(process.argv[1], null, false);\n      } else {\n        resolvedArgv = 'repl';\n      }\n    }\n\n    // Set breakpoint on module start\n    if (filename === resolvedArgv) {\n      delete process._debugWaitConnect;\n      inspectorWrapper = process.binding('inspector').callAndPauseOnStart;\n      if (!inspectorWrapper) {\n        const Debug = vm.runInDebugContext('Debug');\n        Debug.setBreakPoint(compiledWrapper, 0, 0);\n      }\n    }\n  }\n  var dirname = path.dirname(filename);\n  var require = internalModule.makeRequireFunction(this);\n  var depth = internalModule.requireDepth;\n  if (depth === 0) stat.cache = new Map();\n  var result;\n  if (inspectorWrapper) {\n    result = inspectorWrapper(compiledWrapper, this.exports, this.exports,\n                              require, this, filename, dirname);\n  } else {\n    result = compiledWrapper.call(this.exports, this.exports, require, this,\n                                  filename, dirname);\n  }\n  if (depth === 0) stat.cache = null;\n  return result;\n};\n\n\n// Native extension for .js\nModule._extensions['.js'] = function(module, filename) {\n  var content = fs.readFileSync(filename, 'utf8');\n  module._compile(internalModule.stripBOM(content), filename);\n};\n\n\n// Native extension for .json\nModule._extensions['.json'] = function(module, filename) {\n  var content = fs.readFileSync(filename, 'utf8');\n  try {\n    module.exports = JSON.parse(internalModule.stripBOM(content));\n  } catch (err) {\n    err.message = filename + ': ' + err.message;\n    throw err;\n  }\n};\n\n\n//Native extension for .node\nModule._extensions['.node'] = function(module, filename) {\n  return process.dlopen(module, path._makeLong(filename));\n};\n\n\n// bootstrap main module.\nModule.runMain = function() {\n  // Load the main module--the command line argument.\n  Module._load(process.argv[1], null, true);\n  // Handle any nextTicks added in the first tick of the program\n  process._tickCallback();\n};\n\nModule._initPaths = function() {\n  const isWindows = process.platform === 'win32';\n\n  var homeDir;\n  if (isWindows) {\n    homeDir = process.env.USERPROFILE;\n  } else {\n    homeDir = process.env.HOME;\n  }\n\n  // $PREFIX/lib/node, where $PREFIX is the root of the Node.js installation.\n  var prefixDir;\n  // process.execPath is $PREFIX/bin/node except on Windows where it is\n  // $PREFIX\\node.exe.\n  if (isWindows) {\n    prefixDir = path.resolve(process.execPath, '..');\n  } else {\n    prefixDir = path.resolve(process.execPath, '..', '..');\n  }\n  var paths = [path.resolve(prefixDir, 'lib', 'node')];\n\n  if (homeDir) {\n    paths.unshift(path.resolve(homeDir, '.node_libraries'));\n    paths.unshift(path.resolve(homeDir, '.node_modules'));\n  }\n\n  var nodePath = process.env['NODE_PATH'];\n  if (nodePath) {\n    paths = nodePath.split(path.delimiter).filter(function(path) {\n      return !!path;\n    }).concat(paths);\n  }\n\n  modulePaths = paths;\n\n  // clone as a shallow copy, for introspection.\n  Module.globalPaths = modulePaths.slice(0);\n};\n\nModule._preloadModules = function(requests) {\n  if (!Array.isArray(requests))\n    return;\n\n  // Preloaded modules have a dummy parent module which is deemed to exist\n  // in the current working directory. This seeds the search path for\n  // preloaded modules.\n  var parent = new Module('internal/preload', null);\n  try {\n    parent.paths = Module._nodeModulePaths(process.cwd());\n  } catch (e) {\n    if (e.code !== 'ENOENT') {\n      throw e;\n    }\n  }\n  for (var n = 0; n < requests.length; n++)\n    parent.require(requests[n]);\n};\n\nModule._initPaths();\n\n// backwards compatibility\nModule.Module = Module;\n\n});"},
    {"fileId":8, "filename":"chakra_shim.js", "source":"// Copyright Microsoft. All rights reserved.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files(the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and / or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions :\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n/* eslint-disable strict */\n(function(keepAlive) {\n  // Save original builtIns\n  var\n    Function_prototype_toString = Function.prototype.toString,\n    Object_defineProperty = Object.defineProperty,\n    Object_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,\n    Object_getOwnPropertyNames = Object.getOwnPropertyNames,\n    Object_keys = Object.keys,\n    Object_prototype_toString = Object.prototype.toString,\n    Object_setPrototypeOf = Object.setPrototypeOf,\n    Reflect_apply = Reflect.apply,\n    Reflect_construct = Reflect.construct,\n    Map_keys = Map.prototype.keys,\n    Map_values = Map.prototype.values,\n    Map_entries = Map.prototype.entries,\n    Set_entries = Set.prototype.entries,\n    Set_values = Set.prototype.values,\n    Symbol_keyFor = Symbol.keyFor,\n    Symbol_for = Symbol.for,\n    Global_ParseInt = parseInt;\n  var BuiltInError = Error;\n  var global = this;\n\n  // Simulate V8 JavaScript stack trace API\n  function StackFrame(func, funcName, fileName, lineNumber, columnNumber) {\n    this.column = columnNumber;\n    this.lineNumber = lineNumber;\n    this.scriptName = fileName;\n    this.functionName = funcName;\n    this.function = func;\n  }\n\n  StackFrame.prototype.getFunction = function() {\n    // TODO: Fix if .stack is called from different callsite\n    // from where Error() or Error.captureStackTrace was called\n    return this.function;\n  };\n\n  StackFrame.prototype.getTypeName = function() {\n    //TODO : Fix this\n    return this.functionName;\n  };\n\n  StackFrame.prototype.getMethodName = function() {\n    return this.functionName;\n  };\n\n  StackFrame.prototype.getFunctionName = function() {\n    return this.functionName;\n  };\n\n  StackFrame.prototype.getFileName = function() {\n    return this.scriptName;\n  };\n\n  StackFrame.prototype.getLineNumber = function() {\n    return this.lineNumber;\n  };\n\n  StackFrame.prototype.getColumnNumber = function() {\n    return this.column;\n  };\n\n  StackFrame.prototype.isEval = function() {\n    // TODO\n    return false;\n  };\n\n  StackFrame.prototype.isToplevel = function() {\n    // TODO\n    return false;\n  };\n\n  StackFrame.prototype.isNative = function() {\n    // TODO\n    return false;\n  };\n\n  StackFrame.prototype.isConstructor = function() {\n    // TODO\n    return false;\n  };\n\n  StackFrame.prototype.toString = function() {\n    return (this.functionName || 'Anonymous function') + ' (' +\n      this.scriptName + ':' + this.lineNumber + ':' + this.column + ')';\n  };\n\n  // default StackTrace stringify function\n  function prepareStackTrace(error, stack) {\n    var stackString = (error.name || 'Error') + ': ' + (error.message || '');\n\n    for (var i = 0; i < stack.length; i++) {\n      stackString += '\\n   at ' + stack[i].toString();\n    }\n\n    return stackString;\n  }\n\n  // Parse 'stack' string into StackTrace frames. Skip top 'skipDepth' frames,\n  // and optionally skip top to 'startName' function frames.\n  function parseStack(stack, skipDepth, startName) {\n    var stackSplitter = /\\)\\s*at/;\n    var reStackDetails = /\\s(?:at\\s)?(.*)\\s\\((.*)/;\n    var fileDetailsSplitter = /:(\\d+)/;\n\n    var curr = parseStack;\n    var splittedStack = stack.split(stackSplitter);\n    var errstack = [];\n\n    for (var i = 0; i < splittedStack.length; i++) {\n      // parseStack has 1 frame lesser than skipDepth. So skip calling .caller\n      // once. After that, continue calling .caller\n      if (skipDepth !== 1 && curr) {\n        try {\n          curr = curr.caller;\n        } catch (e) {\n          curr = undefined;  // .caller might not be allowed in curr's context\n        }\n      }\n\n      if (skipDepth-- > 0) {\n        continue;\n      }\n\n      var func = curr;\n      var stackDetails = reStackDetails.exec(splittedStack[i]);\n      var funcName = stackDetails[1];\n\n      if (startName) {\n        if (funcName === startName) {\n          startName = undefined;\n        }\n        continue;\n      }\n      if (funcName === 'Anonymous function') {\n        funcName = null;\n      }\n\n      var fileDetails = stackDetails[2].split(fileDetailsSplitter);\n\n      var fileName = fileDetails[0];\n      var lineNumber = fileDetails[1] ? fileDetails[1] : 0;\n      var columnNumber = fileDetails[3] ? fileDetails[3] : 0;\n\n      errstack.push(\n          new StackFrame(func, funcName, fileName, lineNumber, columnNumber));\n    }\n    return errstack;\n  }\n\n  function findFuncDepth(func) {\n    if (!func) {\n      return 0;\n    }\n\n    try {\n      var curr = privateCaptureStackTrace.caller;\n      var limit = Error.stackTraceLimit;\n      var skipDepth = 0;\n      while (curr) {\n        skipDepth++;\n        if (curr === func) {\n          return skipDepth;\n        }\n        if (skipDepth > limit) {\n          return 0;\n        }\n        curr = curr.caller;\n      }\n    } catch (e) {\n      // Strict mode may throw on .caller. Will try to match by function name.\n      return -1;\n    }\n\n    return 0;\n  }\n\n  function withStackTraceLimitOffset(offset, f) {\n    var oldLimit = BuiltInError.stackTraceLimit;\n    if (typeof oldLimit === 'number') {\n      BuiltInError.stackTraceLimit = oldLimit + offset;\n    }\n    try {\n      return f();\n    } finally {\n      BuiltInError.stackTraceLimit = oldLimit;\n    }\n  }\n\n  function captureStackTrace(err, func) {\n    // skip 3 frames: lambda, withStackTraceLimitOffset, this frame\n    return privateCaptureStackTrace(\n      err, func,\n      withStackTraceLimitOffset(3, () => new BuiltInError()),\n      3);\n  }\n\n  // private captureStackTrace implementation\n  //  err, func -- args from Error.captureStackTrace\n  //  e -- a new Error object which already captured stack\n  //  skipDepth -- known number of top frames to be skipped\n  function privateCaptureStackTrace(err, func, e, skipDepth) {\n    var currentStack = e;\n    var isPrepared = false;\n    var oldStackDesc = Object_getOwnPropertyDescriptor(e, 'stack');\n\n    var funcSkipDepth = findFuncDepth(func);\n    var startFuncName = (func && funcSkipDepth < 0) ? func.name : undefined;\n    skipDepth += Math.max(funcSkipDepth - 1, 0);\n\n    var currentStackTrace;\n    function ensureStackTrace() {\n      if (!currentStackTrace) {\n        currentStackTrace = parseStack(\n          Reflect_apply(oldStackDesc.get, e, []) || '', // Call saved old getter\n          skipDepth, startFuncName);\n      }\n      return currentStackTrace;\n    }\n\n    function stackGetter() {\n      if (!isPrepared) {\n        var prep = Error.prepareStackTrace || prepareStackTrace;\n        stackSetter(prep(err, ensureStackTrace()));\n      }\n      return currentStack;\n    }\n    function stackSetter(value) {\n      currentStack = value;\n      isPrepared = true;\n      // Notify original Error object of this setter call. Without knowing\n      // this Chakra runtime would reset stack at throw time.\n      Reflect_apply(oldStackDesc.set, e, [value]);\n    }\n\n    // To retain overriden stackAccessors below,notify Chakra runtime to not\n    // reset stack for this error object.\n    if (e !== err) {\n      Reflect_apply(oldStackDesc.set, err, ['']);\n    }\n\n    Object_defineProperty(err, 'stack', {\n      get: stackGetter, set: stackSetter, configurable: true, enumerable: false\n    });\n\n    return ensureStackTrace; // For chakrashim native to get stack frames\n  }\n\n  // patch Error types to hook with Error.captureStackTrace/prepareStackTrace\n  function patchErrorTypes() {\n    // save a map from wrapper to builtin native types\n    var typeToNative = new Map();\n\n    // patch all these builtin Error types\n    [\n      Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError,\n      URIError\n    ].forEach(function(type) {\n      function newType() {\n        var e = withStackTraceLimitOffset(\n          3, () => Reflect_construct(type, arguments, new.target || newType));\n        // skip 3 frames: lambda, withStackTraceLimitOffset, this frame\n        privateCaptureStackTrace(e, undefined, e, 3);\n        return e;\n      }\n\n      Object_defineProperty(newType, 'name', {\n        value: type.name,\n        writable: false, enumerable: false, configurable: true\n      });\n      newType.prototype = type.prototype;\n      newType.prototype.constructor = newType;\n      if (type !== BuiltInError) {\n        Object_setPrototypeOf(newType, Error);\n      }\n      global[type.name] = newType;\n      typeToNative.set(newType, type);\n    });\n\n    // Delegate Error.stackTraceLimit to builtin Error constructor\n    Object_defineProperty(Error, 'stackTraceLimit', {\n      enumerable: false,\n      configurable: true,\n      get: function() { return BuiltInError.stackTraceLimit; },\n      set: function(value) { BuiltInError.stackTraceLimit = value; }\n    });\n\n    Function.prototype.toString = function toString() {\n      return Reflect_apply(Function_prototype_toString,\n                           typeToNative.get(this) || this, arguments);\n    };\n    typeToNative.set(Function.prototype.toString, Function_prototype_toString);\n  }\n\n  function patchErrorStack() {\n    Error.captureStackTrace = captureStackTrace;\n  }\n\n  var mapIteratorProperty = 'MapIteratorIndicator';\n  function patchMapIterator() {\n    var originalMapMethods = [];\n    originalMapMethods.push(['entries', Map_entries]);\n    originalMapMethods.push(['values', Map_values]);\n    originalMapMethods.push(['keys', Map_keys]);\n\n    originalMapMethods.forEach(function(pair) {\n      Map.prototype[pair[0]] = function() {\n        var result = pair[1].apply(this);\n        Object_defineProperty(result, mapIteratorProperty,\n          { value: true, enumerable: false, writable: false });\n        return result;\n      };\n    });\n  }\n\n  var setIteratorProperty = 'SetIteratorIndicator';\n  function patchSetIterator() {\n    var originalSetMethods = [];\n    originalSetMethods.push(['entries', Set_entries]);\n    originalSetMethods.push(['values', Set_values]);\n\n    originalSetMethods.forEach(function(pair) {\n      Set.prototype[pair[0]] = function() {\n        var result = pair[1].apply(this);\n        Object_defineProperty(result, setIteratorProperty,\n          { value: true, enumerable: false, writable: false });\n        return result;\n      };\n    });\n  }\n\n  // Ensure global Debug object if not already exists, and patch it.\n  function ensureDebug(otherGlobal) {\n    if (!global.Debug) {\n      Object_defineProperty(global, 'Debug', {\n        value: {}, enumerable: false, configurable: false, writable: false\n      });\n    }\n\n    otherProcess = otherGlobal.process;\n    patchDebug(global.Debug);\n  }\n\n  var otherProcess;\n\n  function patchDebug(Debug) {\n    if (!Debug || Debug.MakeMirror) {\n      return;\n    }\n\n    class Mirror {\n      constructor(type) {\n        this.type_ = type;\n      }\n      type() {\n        return this.type_;\n      }\n    }\n\n    class ValueMirror extends Mirror {\n      constructor(type, value) {\n        super(type);\n        this.value_ = value;\n      }\n      value() {\n        return this.value_;\n      }\n    }\n\n    class UndefinedMirror extends ValueMirror {\n      constructor() {\n        super('undefined', undefined);\n      }\n    }\n    const undefinedMirror = new UndefinedMirror();\n\n    class ObjectMirror extends ValueMirror {\n      constructor(type, value) {\n        super(type || 'object', value);\n      }\n    }\n\n    class PromiseMirror extends ObjectMirror {\n      constructor(value) {\n        super('promise', value);\n      }\n      status() {\n        return '<unknown>';\n      }\n      promiseValue() {\n        return new ValueMirror('<unknown>', '<unknown>');\n      }\n    }\n\n    const util = otherProcess.binding('util');\n\n    Debug.MakeMirror = (value) => {\n      if (util.isPromise(value)) {\n        return new PromiseMirror(value);\n      }\n\n      // Not supporting other types\n      return undefinedMirror;\n    };\n  }\n\n  // Simulate v8 micro tasks queue\n  var microTasks = [];\n\n  function patchUtils(utils) {\n    var isUintRegex = /^(0|[1-9]\\d*)$/;\n\n    function isUint(value) {\n      var result = isUintRegex.test(value);\n      isUintRegex.lastIndex = 0;\n      return result;\n    }\n    utils.cloneObject = function(source, target) {\n      Object_getOwnPropertyNames(source).forEach(function(key) {\n        try {\n          var desc = Object_getOwnPropertyDescriptor(source, key);\n          if (desc.value === source) desc.value = target;\n          Object_defineProperty(target, key, desc);\n        } catch (e) {\n          // Catch sealed properties errors\n        }\n      });\n    };\n    utils.getPropertyNames = function(a) {\n      var names = [];\n      for (var propertyName in a) {\n        if (isUint(propertyName)) {\n          names.push(Global_ParseInt(propertyName));\n        } else {\n          names.push(propertyName);\n        }\n      }\n      return names;\n    };\n    utils.getEnumerableNamedProperties = function(obj) {\n      var props = [];\n      for (var key in obj) {\n        if (!isUint(key))\n          props.push(key);\n      }\n      return props;\n    };\n    utils.getEnumerableIndexedProperties = function(obj) {\n      var props = [];\n      for (var key in obj) {\n        if (isUint(key))\n          props.push(key);\n      }\n      return props;\n    };\n    utils.createEnumerationIterator = function(props) {\n      var i = 0;\n      return {\n        next: function() {\n          if (i === props.length)\n            return { done: true };\n          return { value: props[i++] };\n        }\n      };\n    };\n    utils.createPropertyDescriptorsEnumerationIterator = function(props) {\n      var i = 0;\n      return {\n        next: function() {\n          if (i === props.length) return { done: true };\n          return { name: props[i++], enumerable: true };\n        }\n      };\n    };\n    utils.getNamedOwnKeys = function(obj) {\n      var props = [];\n      Object_keys(obj).forEach(function(item) {\n        if (!isUint(item))\n          props.push(item);\n      });\n      return props;\n    };\n    utils.getIndexedOwnKeys = function(obj) {\n      var props = [];\n      Object_keys(obj).forEach(function(item) {\n        if (isUint(item))\n          props.push(item);\n      });\n      return props;\n    };\n    utils.getStackTrace = function() {\n      return captureStackTrace({}, undefined)();\n    };\n    utils.isMapIterator = function(value) {\n      return value[mapIteratorProperty] === true;\n    };\n    utils.isSetIterator = function(value) {\n      return value[setIteratorProperty] === true;\n    };\n    function compareType(o, expectedType) {\n      return Object_prototype_toString.call(o) === '[object ' +\n            expectedType + ']';\n    }\n    utils.isBooleanObject = function(obj) {\n      return compareType(obj, 'Boolean');\n    };\n    utils.isDate = function(obj) {\n      return compareType(obj, 'Date');\n    };\n    utils.isMap = function(obj) {\n      return compareType(obj, 'Map');\n    };\n    utils.isNativeError = function(obj) {\n      return compareType(obj, 'Error') ||\n        obj instanceof Error ||\n        obj instanceof EvalError ||\n        obj instanceof RangeError ||\n        obj instanceof ReferenceError ||\n        obj instanceof SyntaxError ||\n        obj instanceof TypeError ||\n        obj instanceof URIError;\n    };\n    utils.isPromise = function(obj) {\n      return compareType(obj, 'Object') && obj instanceof Promise;\n    };\n    utils.isRegExp = function(obj) {\n      return compareType(obj, 'RegExp');\n    };\n    utils.isAsyncFunction = function(obj) {\n      // CHAKRA-TODO\n      return false;\n    };\n    utils.isSet = function(obj) {\n      return compareType(obj, 'Set');\n    };\n    utils.isStringObject = function(obj) {\n      return compareType(obj, 'String');\n    };\n    utils.isNumberObject = function(obj) {\n      return compareType(obj, 'Number');\n    };\n    utils.isArgumentsObject = function(obj) {\n      return compareType(obj, 'Arguments');\n    };\n    utils.isGeneratorObject = function(obj) {\n      return compareType(obj, 'Generator');\n    };\n    utils.isWeakMap = function(obj) {\n      return compareType(obj, 'WeakMap');\n    };\n    utils.isWeakSet = function(obj) {\n      return compareType(obj, 'WeakSet');\n    };\n    utils.isSymbolObject = function(obj) {\n      return compareType(obj, 'Symbol');\n    };\n    utils.isName = function(obj) {\n      return compareType(obj, 'String') || compareType(obj, 'Symbol');\n    };\n    utils.getSymbolKeyFor = function(symbol) {\n      return Symbol_keyFor(symbol);\n    };\n    utils.getSymbolFor = function(key) {\n      return Symbol_for(key);\n    };\n    utils.ensureDebug = ensureDebug;\n    utils.enqueueMicrotask = function(task) {\n      microTasks.push(task);\n    };\n    utils.dequeueMicrotask = function(task) {\n      return microTasks.shift();\n    };\n    utils.isProxy = function(value) {\n      // CHAKRA-TODO: Need to add JSRT API to detect this\n      return false;\n    };\n    utils.getPropertyAttributes = function(object, value) {\n      var descriptor = Object_getOwnPropertyDescriptor(object, value);\n      if (descriptor === undefined) {\n        return -1;\n      }\n\n      var attributes = 0;\n      // taken from v8.h. Update if this changes in future\n      const ReadOnly = 1,\n        DontEnum = 2,\n        DontDelete = 4;\n\n      if (!descriptor.writable) {\n        attributes |= ReadOnly;\n      }\n      if (!descriptor.enumerable) {\n        attributes |= DontEnum;\n      }\n      if (!descriptor.configurable) {\n        attributes |= DontDelete;\n      }\n      return attributes;\n    };\n    utils.getOwnPropertyNames = function(obj) {\n      var ownPropertyNames = Object_getOwnPropertyNames(obj);\n      var i = 0;\n      while (i < ownPropertyNames.length) {\n        var item = ownPropertyNames[i];\n        if (isUint(item)) {\n          ownPropertyNames[i] = Global_ParseInt(item);\n          i++;\n          continue;\n        }\n        // As per spec, getOwnPropertyNames() first include\n        // numeric properties followed by non-numeric\n        break;\n      }\n      return ownPropertyNames;\n    };\n  }\n\n  patchErrorTypes();\n  patchErrorStack();\n  patchMapIterator();\n  patchSetIterator();\n\n  patchUtils(keepAlive);\n});\n"},
    {"fileId":9, "filename":"internal/url.js", "source":"(function (exports, require, module, __filename, __dirname) { 'use strict';\n\nconst util = require('util');\nconst {\n  hexTable,\n  isHexTable\n} = require('internal/querystring');\n\nconst { getConstructorOf } = require('internal/util');\nconst errors = require('internal/errors');\nconst querystring = require('querystring');\n\nconst { platform } = process;\nconst isWindows = platform === 'win32';\n\nconst {\n  domainToASCII: _domainToASCII,\n  domainToUnicode: _domainToUnicode,\n  encodeAuth,\n  toUSVString: _toUSVString,\n  parse: _parse,\n  setURLConstructor,\n  URL_FLAGS_CANNOT_BE_BASE,\n  URL_FLAGS_HAS_FRAGMENT,\n  URL_FLAGS_HAS_HOST,\n  URL_FLAGS_HAS_PASSWORD,\n  URL_FLAGS_HAS_PATH,\n  URL_FLAGS_HAS_QUERY,\n  URL_FLAGS_HAS_USERNAME,\n  URL_FLAGS_SPECIAL,\n  kFragment,\n  kHost,\n  kHostname,\n  kPathStart,\n  kPort,\n  kQuery,\n  kSchemeStart\n} = process.binding('url');\n\nconst context = Symbol('context');\nconst cannotBeBase = Symbol('cannot-be-base');\nconst cannotHaveUsernamePasswordPort =\n    Symbol('cannot-have-username-password-port');\nconst special = Symbol('special');\nconst searchParams = Symbol('query');\nconst kFormat = Symbol('format');\n\n// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object\nconst IteratorPrototype = Object.getPrototypeOf(\n  Object.getPrototypeOf([][Symbol.iterator]())\n);\n\nconst unpairedSurrogateRe =\n    /([^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])/;\nfunction toUSVString(val) {\n  const str = `${val}`;\n  // As of V8 5.5, `str.search()` (and `unpairedSurrogateRe[@@search]()`) are\n  // slower than `unpairedSurrogateRe.exec()`.\n  const match = unpairedSurrogateRe.exec(str);\n  if (!match)\n    return str;\n  return _toUSVString(str, match.index);\n}\n\n// Refs: https://html.spec.whatwg.org/multipage/browsers.html#concept-origin-opaque\nconst kOpaqueOrigin = 'null';\n\n// Refs: https://html.spec.whatwg.org/multipage/browsers.html#ascii-serialisation-of-an-origin\nfunction serializeTupleOrigin(scheme, host, port) {\n  return `${scheme}//${host}${port === null ? '' : `:${port}`}`;\n}\n\n// This class provides the internal state of a URL object. An instance of this\n// class is stored in every URL object and is accessed internally by setters\n// and getters. It roughly corresponds to the concept of a URL record in the\n// URL Standard, with a few differences. It is also the object transported to\n// the C++ binding.\n// Refs: https://url.spec.whatwg.org/#concept-url\nclass URLContext {\n  constructor() {\n    this.flags = 0;\n    this.scheme = ':';\n    this.username = '';\n    this.password = '';\n    this.host = null;\n    this.port = null;\n    this.path = [];\n    this.query = null;\n    this.fragment = null;\n  }\n}\n\nfunction onParseComplete(flags, protocol, username, password,\n                         host, port, path, query, fragment) {\n  var ctx = this[context];\n  ctx.flags = flags;\n  ctx.scheme = protocol;\n  ctx.username = (flags & URL_FLAGS_HAS_USERNAME) !== 0 ? username : '';\n  ctx.password = (flags & URL_FLAGS_HAS_PASSWORD) !== 0 ? password : '';\n  ctx.port = port;\n  ctx.path = (flags & URL_FLAGS_HAS_PATH) !== 0 ? path : [];\n  ctx.query = query;\n  ctx.fragment = fragment;\n  ctx.host = host;\n  if (!this[searchParams]) { // invoked from URL constructor\n    this[searchParams] = new URLSearchParams();\n    this[searchParams][context] = this;\n  }\n  initSearchParams(this[searchParams], query);\n}\n\nfunction onParseError(flags, input) {\n  const error = new errors.TypeError('ERR_INVALID_URL', input);\n  error.input = input;\n  throw error;\n}\n\n// Reused by URL constructor and URL#href setter.\nfunction parse(url, input, base) {\n  const base_context = base ? base[context] : undefined;\n  url[context] = new URLContext();\n  _parse(input.trim(), -1, base_context, undefined,\n         onParseComplete.bind(url), onParseError);\n}\n\nfunction onParseProtocolComplete(flags, protocol, username, password,\n                                 host, port, path, query, fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_SPECIAL) !== 0) {\n    ctx.flags |= URL_FLAGS_SPECIAL;\n  } else {\n    ctx.flags &= ~URL_FLAGS_SPECIAL;\n  }\n  ctx.scheme = protocol;\n}\n\nfunction onParseHostComplete(flags, protocol, username, password,\n                             host, port, path, query, fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_HAS_HOST) !== 0) {\n    ctx.host = host;\n    ctx.flags |= URL_FLAGS_HAS_HOST;\n  } else {\n    ctx.host = null;\n    ctx.flags &= ~URL_FLAGS_HAS_HOST;\n  }\n  if (port !== null)\n    ctx.port = port;\n}\n\nfunction onParseHostnameComplete(flags, protocol, username, password,\n                                 host, port, path, query, fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_HAS_HOST) !== 0) {\n    ctx.host = host;\n    ctx.flags |= URL_FLAGS_HAS_HOST;\n  } else {\n    ctx.host = null;\n    ctx.flags &= ~URL_FLAGS_HAS_HOST;\n  }\n}\n\nfunction onParsePortComplete(flags, protocol, username, password,\n                             host, port, path, query, fragment) {\n  this[context].port = port;\n}\n\nfunction onParsePathComplete(flags, protocol, username, password,\n                             host, port, path, query, fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_HAS_PATH) !== 0) {\n    ctx.path = path;\n    ctx.flags |= URL_FLAGS_HAS_PATH;\n  } else {\n    ctx.path = [];\n    ctx.flags &= ~URL_FLAGS_HAS_PATH;\n  }\n\n  // The C++ binding may set host to empty string.\n  if ((flags & URL_FLAGS_HAS_HOST) !== 0) {\n    ctx.host = host;\n    ctx.flags |= URL_FLAGS_HAS_HOST;\n  }\n}\n\nfunction onParseSearchComplete(flags, protocol, username, password,\n                               host, port, path, query, fragment) {\n  this[context].query = query;\n}\n\nfunction onParseHashComplete(flags, protocol, username, password,\n                             host, port, path, query, fragment) {\n  this[context].fragment = fragment;\n}\n\nclass URL {\n  constructor(input, base) {\n    // toUSVString is not needed.\n    input = `${input}`;\n    if (base !== undefined &&\n        (!base[searchParams] || !base[searchParams][searchParams])) {\n      base = new URL(base);\n    }\n    parse(this, input, base);\n  }\n\n  get [special]() {\n    return (this[context].flags & URL_FLAGS_SPECIAL) !== 0;\n  }\n\n  get [cannotBeBase]() {\n    return (this[context].flags & URL_FLAGS_CANNOT_BE_BASE) !== 0;\n  }\n\n  // https://url.spec.whatwg.org/#cannot-have-a-username-password-port\n  get [cannotHaveUsernamePasswordPort]() {\n    const { host, scheme } = this[context];\n    return ((host == null || host === '') ||\n            this[cannotBeBase] ||\n            scheme === 'file:');\n  }\n\n  [util.inspect.custom](depth, opts) {\n    if (this == null ||\n        Object.getPrototypeOf(this[context]) !== URLContext.prototype) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URL');\n    }\n\n    if (typeof depth === 'number' && depth < 0)\n      return opts.stylize('[Object]', 'special');\n\n    var ctor = getConstructorOf(this);\n\n    var obj = Object.create({\n      constructor: ctor === null ? URL : ctor\n    });\n\n    obj.href = this.href;\n    obj.origin = this.origin;\n    obj.protocol = this.protocol;\n    obj.username = this.username;\n    obj.password = this.password;\n    obj.host = this.host;\n    obj.hostname = this.hostname;\n    obj.port = this.port;\n    obj.pathname = this.pathname;\n    obj.search = this.search;\n    obj.searchParams = this.searchParams;\n    obj.hash = this.hash;\n\n    if (opts.showHidden) {\n      obj.cannotBeBase = this[cannotBeBase];\n      obj.special = this[special];\n      obj[context] = this[context];\n    }\n\n    return util.inspect(obj, opts);\n  }\n}\n\nObject.defineProperties(URL.prototype, {\n  [kFormat]: {\n    enumerable: false,\n    configurable: false,\n    // eslint-disable-next-line func-name-matching\n    value: function format(options) {\n      if (options && typeof options !== 'object')\n        throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 'options', 'object');\n      options = Object.assign({\n        fragment: true,\n        unicode: false,\n        search: true,\n        auth: true\n      }, options);\n      const ctx = this[context];\n      var ret = ctx.scheme;\n      if (ctx.host !== null) {\n        ret += '//';\n        const has_username = ctx.username !== '';\n        const has_password = ctx.password !== '';\n        if (options.auth && (has_username || has_password)) {\n          if (has_username)\n            ret += ctx.username;\n          if (has_password)\n            ret += `:${ctx.password}`;\n          ret += '@';\n        }\n        ret += options.unicode ?\n          domainToUnicode(this.host) : this.host;\n      } else if (ctx.scheme === 'file:') {\n        ret += '//';\n      }\n      if (this.pathname)\n        ret += this.pathname;\n      if (options.search && ctx.query !== null)\n        ret += `?${ctx.query}`;\n      if (options.fragment && ctx.fragment !== null)\n        ret += `#${ctx.fragment}`;\n      return ret;\n    }\n  },\n  [Symbol.toStringTag]: {\n    configurable: true,\n    value: 'URL'\n  },\n  toString: {\n    // https://heycam.github.io/webidl/#es-stringifier\n    writable: true,\n    enumerable: true,\n    configurable: true,\n    // eslint-disable-next-line func-name-matching\n    value: function toString() {\n      return this[kFormat]({});\n    }\n  },\n  href: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      return this[kFormat]({});\n    },\n    set(input) {\n      // toUSVString is not needed.\n      input = `${input}`;\n      parse(this, input);\n    }\n  },\n  origin: {  // readonly\n    enumerable: true,\n    configurable: true,\n    get() {\n      // Refs: https://url.spec.whatwg.org/#concept-url-origin\n      const ctx = this[context];\n      switch (ctx.scheme) {\n        case 'blob:':\n          if (ctx.path.length > 0) {\n            try {\n              return (new URL(ctx.path[0])).origin;\n            } catch (err) {\n              // fall through... do nothing\n            }\n          }\n          return kOpaqueOrigin;\n        case 'ftp:':\n        case 'gopher:':\n        case 'http:':\n        case 'https:':\n        case 'ws:':\n        case 'wss:':\n          return serializeTupleOrigin(ctx.scheme, ctx.host, ctx.port);\n      }\n      return kOpaqueOrigin;\n    }\n  },\n  protocol: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      return this[context].scheme;\n    },\n    set(scheme) {\n      // toUSVString is not needed.\n      scheme = `${scheme}`;\n      if (scheme.length === 0)\n        return;\n      const ctx = this[context];\n      if (ctx.scheme === 'file:' &&\n          (ctx.host === '' || ctx.host === null)) {\n        return;\n      }\n      _parse(scheme, kSchemeStart, null, ctx,\n             onParseProtocolComplete.bind(this));\n    }\n  },\n  username: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      return this[context].username;\n    },\n    set(username) {\n      // toUSVString is not needed.\n      username = `${username}`;\n      if (this[cannotHaveUsernamePasswordPort])\n        return;\n      const ctx = this[context];\n      if (username === '') {\n        ctx.username = '';\n        ctx.flags &= ~URL_FLAGS_HAS_USERNAME;\n        return;\n      }\n      ctx.username = encodeAuth(username);\n      ctx.flags |= URL_FLAGS_HAS_USERNAME;\n    }\n  },\n  password: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      return this[context].password;\n    },\n    set(password) {\n      // toUSVString is not needed.\n      password = `${password}`;\n      if (this[cannotHaveUsernamePasswordPort])\n        return;\n      const ctx = this[context];\n      if (password === '') {\n        ctx.password = '';\n        ctx.flags &= ~URL_FLAGS_HAS_PASSWORD;\n        return;\n      }\n      ctx.password = encodeAuth(password);\n      ctx.flags |= URL_FLAGS_HAS_PASSWORD;\n    }\n  },\n  host: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      const ctx = this[context];\n      var ret = ctx.host || '';\n      if (ctx.port !== null)\n        ret += `:${ctx.port}`;\n      return ret;\n    },\n    set(host) {\n      const ctx = this[context];\n      // toUSVString is not needed.\n      host = `${host}`;\n      if (this[cannotBeBase]) {\n        // Cannot set the host if cannot-be-base is set\n        return;\n      }\n      _parse(host, kHost, null, ctx, onParseHostComplete.bind(this));\n    }\n  },\n  hostname: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      return this[context].host || '';\n    },\n    set(host) {\n      const ctx = this[context];\n      // toUSVString is not needed.\n      host = `${host}`;\n      if (this[cannotBeBase]) {\n        // Cannot set the host if cannot-be-base is set\n        return;\n      }\n      _parse(host, kHostname, null, ctx, onParseHostnameComplete.bind(this));\n    }\n  },\n  port: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      const port = this[context].port;\n      return port === null ? '' : String(port);\n    },\n    set(port) {\n      // toUSVString is not needed.\n      port = `${port}`;\n      if (this[cannotHaveUsernamePasswordPort])\n        return;\n      const ctx = this[context];\n      if (port === '') {\n        ctx.port = null;\n        return;\n      }\n      _parse(port, kPort, null, ctx, onParsePortComplete.bind(this));\n    }\n  },\n  pathname: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      const ctx = this[context];\n      if (this[cannotBeBase])\n        return ctx.path[0];\n      if (ctx.path.length === 0)\n        return '';\n      return `/${ctx.path.join('/')}`;\n    },\n    set(path) {\n      // toUSVString is not needed.\n      path = `${path}`;\n      if (this[cannotBeBase])\n        return;\n      _parse(path, kPathStart, null, this[context],\n             onParsePathComplete.bind(this));\n    }\n  },\n  search: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      const { query } = this[context];\n      if (query === null || query === '')\n        return '';\n      return `?${query}`;\n    },\n    set(search) {\n      const ctx = this[context];\n      search = toUSVString(search);\n      if (search === '') {\n        ctx.query = null;\n        ctx.flags &= ~URL_FLAGS_HAS_QUERY;\n      } else {\n        if (search[0] === '?') search = search.slice(1);\n        ctx.query = '';\n        ctx.flags |= URL_FLAGS_HAS_QUERY;\n        if (search) {\n          _parse(search, kQuery, null, ctx, onParseSearchComplete.bind(this));\n        }\n      }\n      initSearchParams(this[searchParams], search);\n    }\n  },\n  searchParams: {  // readonly\n    enumerable: true,\n    configurable: true,\n    get() {\n      return this[searchParams];\n    }\n  },\n  hash: {\n    enumerable: true,\n    configurable: true,\n    get() {\n      const { fragment } = this[context];\n      if (fragment === null || fragment === '')\n        return '';\n      return `#${fragment}`;\n    },\n    set(hash) {\n      const ctx = this[context];\n      // toUSVString is not needed.\n      hash = `${hash}`;\n      if (!hash) {\n        ctx.fragment = null;\n        ctx.flags &= ~URL_FLAGS_HAS_FRAGMENT;\n        return;\n      }\n      if (hash[0] === '#') hash = hash.slice(1);\n      ctx.fragment = '';\n      ctx.flags |= URL_FLAGS_HAS_FRAGMENT;\n      _parse(hash, kFragment, null, ctx, onParseHashComplete.bind(this));\n    }\n  },\n  toJSON: {\n    writable: true,\n    enumerable: true,\n    configurable: true,\n    // eslint-disable-next-line func-name-matching\n    value: function toJSON() {\n      return this[kFormat]({});\n    }\n  }\n});\n\nfunction update(url, params) {\n  if (!url)\n    return;\n\n  const ctx = url[context];\n  const serializedParams = params.toString();\n  if (serializedParams) {\n    ctx.query = serializedParams;\n    ctx.flags |= URL_FLAGS_HAS_QUERY;\n  } else {\n    ctx.query = null;\n    ctx.flags &= ~URL_FLAGS_HAS_QUERY;\n  }\n}\n\nfunction initSearchParams(url, init) {\n  if (!init) {\n    url[searchParams] = [];\n    return;\n  }\n  url[searchParams] = parseParams(init);\n}\n\n// application/x-www-form-urlencoded parser\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-parser\nfunction parseParams(qs) {\n  const out = [];\n  var pairStart = 0;\n  var lastPos = 0;\n  var seenSep = false;\n  var buf = '';\n  var encoded = false;\n  var encodeCheck = 0;\n  var i;\n  for (i = 0; i < qs.length; ++i) {\n    const code = qs.charCodeAt(i);\n\n    // Try matching key/value pair separator\n    if (code === 38/*&*/) {\n      if (pairStart === i) {\n        // We saw an empty substring between pair separators\n        lastPos = pairStart = i + 1;\n        continue;\n      }\n\n      if (lastPos < i)\n        buf += qs.slice(lastPos, i);\n      if (encoded)\n        buf = querystring.unescape(buf);\n      out.push(buf);\n\n      // If `buf` is the key, add an empty value.\n      if (!seenSep)\n        out.push('');\n\n      seenSep = false;\n      buf = '';\n      encoded = false;\n      encodeCheck = 0;\n      lastPos = pairStart = i + 1;\n      continue;\n    }\n\n    // Try matching key/value separator (e.g. '=') if we haven't already\n    if (!seenSep && code === 61/*=*/) {\n      // Key/value separator match!\n      if (lastPos < i)\n        buf += qs.slice(lastPos, i);\n      if (encoded)\n        buf = querystring.unescape(buf);\n      out.push(buf);\n\n      seenSep = true;\n      buf = '';\n      encoded = false;\n      encodeCheck = 0;\n      lastPos = i + 1;\n      continue;\n    }\n\n    // Handle + and percent decoding.\n    if (code === 43/*+*/) {\n      if (lastPos < i)\n        buf += qs.slice(lastPos, i);\n      buf += ' ';\n      lastPos = i + 1;\n    } else if (!encoded) {\n      // Try to match an (valid) encoded byte (once) to minimize unnecessary\n      // calls to string decoding functions\n      if (code === 37/*%*/) {\n        encodeCheck = 1;\n      } else if (encodeCheck > 0) {\n        // eslint-disable-next-line no-extra-boolean-cast\n        if (!!isHexTable[code]) {\n          if (++encodeCheck === 3)\n            encoded = true;\n        } else {\n          encodeCheck = 0;\n        }\n      }\n    }\n  }\n\n  // Deal with any leftover key or value data\n\n  // There is a trailing &. No more processing is needed.\n  if (pairStart === i)\n    return out;\n\n  if (lastPos < i)\n    buf += qs.slice(lastPos, i);\n  if (encoded)\n    buf = querystring.unescape(buf);\n  out.push(buf);\n\n  // If `buf` is the key, add an empty value.\n  if (!seenSep)\n    out.push('');\n\n  return out;\n}\n\n// Adapted from querystring's implementation.\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-byte-serializer\nconst noEscape = [\n//0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0x00 - 0x0F\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0x10 - 0x1F\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, // 0x20 - 0x2F\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 0x30 - 0x3F\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 0x40 - 0x4F\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, // 0x50 - 0x5F\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 0x60 - 0x6F\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0  // 0x70 - 0x7F\n];\n\n// Special version of hexTable that uses `+` for U+0020 SPACE.\nconst paramHexTable = hexTable.slice();\nparamHexTable[0x20] = '+';\n\nfunction escapeParam(str) {\n  const len = str.length;\n  if (len === 0)\n    return '';\n\n  var out = '';\n  var lastPos = 0;\n\n  for (var i = 0; i < len; i++) {\n    var c = str.charCodeAt(i);\n\n    // ASCII\n    if (c < 0x80) {\n      if (noEscape[c] === 1)\n        continue;\n      if (lastPos < i)\n        out += str.slice(lastPos, i);\n      lastPos = i + 1;\n      out += paramHexTable[c];\n      continue;\n    }\n\n    if (lastPos < i)\n      out += str.slice(lastPos, i);\n\n    // Multi-byte characters ...\n    if (c < 0x800) {\n      lastPos = i + 1;\n      out += paramHexTable[0xC0 | (c >> 6)] +\n             paramHexTable[0x80 | (c & 0x3F)];\n      continue;\n    }\n    if (c < 0xD800 || c >= 0xE000) {\n      lastPos = i + 1;\n      out += paramHexTable[0xE0 | (c >> 12)] +\n             paramHexTable[0x80 | ((c >> 6) & 0x3F)] +\n             paramHexTable[0x80 | (c & 0x3F)];\n      continue;\n    }\n    // Surrogate pair\n    ++i;\n    var c2;\n    if (i < len)\n      c2 = str.charCodeAt(i) & 0x3FF;\n    else {\n      // This branch should never happen because all URLSearchParams entries\n      // should already be converted to USVString. But, included for\n      // completion's sake anyway.\n      c2 = 0;\n    }\n    lastPos = i + 1;\n    c = 0x10000 + (((c & 0x3FF) << 10) | c2);\n    out += paramHexTable[0xF0 | (c >> 18)] +\n           paramHexTable[0x80 | ((c >> 12) & 0x3F)] +\n           paramHexTable[0x80 | ((c >> 6) & 0x3F)] +\n           paramHexTable[0x80 | (c & 0x3F)];\n  }\n  if (lastPos === 0)\n    return str;\n  if (lastPos < len)\n    return out + str.slice(lastPos);\n  return out;\n}\n\n// application/x-www-form-urlencoded serializer\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-serializer\nfunction serializeParams(array) {\n  const len = array.length;\n  if (len === 0)\n    return '';\n\n  var output = `${escapeParam(array[0])}=${escapeParam(array[1])}`;\n  for (var i = 2; i < len; i += 2)\n    output += `&${escapeParam(array[i])}=${escapeParam(array[i + 1])}`;\n  return output;\n}\n\n// Mainly to mitigate func-name-matching ESLint rule\nfunction defineIDLClass(proto, classStr, obj) {\n  // https://heycam.github.io/webidl/#dfn-class-string\n  Object.defineProperty(proto, Symbol.toStringTag, {\n    writable: false,\n    enumerable: false,\n    configurable: true,\n    value: classStr\n  });\n\n  // https://heycam.github.io/webidl/#es-operations\n  for (const key of Object.keys(obj)) {\n    Object.defineProperty(proto, key, {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: obj[key]\n    });\n  }\n  for (const key of Object.getOwnPropertySymbols(obj)) {\n    Object.defineProperty(proto, key, {\n      writable: true,\n      enumerable: false,\n      configurable: true,\n      value: obj[key]\n    });\n  }\n}\n\nclass URLSearchParams {\n  // URL Standard says the default value is '', but as undefined and '' have\n  // the same result, undefined is used to prevent unnecessary parsing.\n  // Default parameter is necessary to keep URLSearchParams.length === 0 in\n  // accordance with Web IDL spec.\n  constructor(init = undefined) {\n    if (init === null || init === undefined) {\n      this[searchParams] = [];\n    } else if (typeof init === 'object') {\n      const method = init[Symbol.iterator];\n      if (method === this[Symbol.iterator]) {\n        // While the spec does not have this branch, we can use it as a\n        // shortcut to avoid having to go through the costly generic iterator.\n        const childParams = init[searchParams];\n        this[searchParams] = childParams.slice();\n      } else if (method !== null && method !== undefined) {\n        if (typeof method !== 'function') {\n          throw new errors.TypeError('ERR_ARG_NOT_ITERABLE', 'Query pairs');\n        }\n\n        // sequence<sequence<USVString>>\n        // Note: per spec we have to first exhaust the lists then process them\n        const pairs = [];\n        for (const pair of init) {\n          if (typeof pair !== 'object' ||\n              typeof pair[Symbol.iterator] !== 'function') {\n            throw new errors.TypeError('ERR_INVALID_TUPLE', 'Each query pair',\n                                       '[name, value]');\n          }\n          pairs.push(Array.from(pair));\n        }\n\n        this[searchParams] = [];\n        for (const pair of pairs) {\n          if (pair.length !== 2) {\n            throw new errors.TypeError('ERR_INVALID_TUPLE', 'Each query pair',\n                                       '[name, value]');\n          }\n          const key = toUSVString(pair[0]);\n          const value = toUSVString(pair[1]);\n          this[searchParams].push(key, value);\n        }\n      } else {\n        // record<USVString, USVString>\n        this[searchParams] = [];\n        for (var key of Object.keys(init)) {\n          key = toUSVString(key);\n          const value = toUSVString(init[key]);\n          this[searchParams].push(key, value);\n        }\n      }\n    } else {\n      // USVString\n      init = toUSVString(init);\n      if (init[0] === '?') init = init.slice(1);\n      initSearchParams(this, init);\n    }\n\n    // \"associated url object\"\n    this[context] = null;\n  }\n\n  [util.inspect.custom](recurseTimes, ctx) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n\n    if (typeof recurseTimes === 'number' && recurseTimes < 0)\n      return ctx.stylize('[Object]', 'special');\n\n    var separator = ', ';\n    var innerOpts = Object.assign({}, ctx);\n    if (recurseTimes !== null) {\n      innerOpts.depth = recurseTimes - 1;\n    }\n    var innerInspect = (v) => util.inspect(v, innerOpts);\n\n    var list = this[searchParams];\n    var output = [];\n    for (var i = 0; i < list.length; i += 2)\n      output.push(`${innerInspect(list[i])} => ${innerInspect(list[i + 1])}`);\n\n    var colorRe = /\\u001b\\[\\d\\d?m/g;\n    var length = output.reduce(\n      (prev, cur) => prev + cur.replace(colorRe, '').length + separator.length,\n      -separator.length\n    );\n    if (length > ctx.breakLength) {\n      return `${this.constructor.name} {\\n  ${output.join(',\\n  ')} }`;\n    } else if (output.length) {\n      return `${this.constructor.name} { ${output.join(separator)} }`;\n    } else {\n      return `${this.constructor.name} {}`;\n    }\n  }\n}\n\n// for merge sort\nfunction merge(out, start, mid, end, lBuffer, rBuffer) {\n  const sizeLeft = mid - start;\n  const sizeRight = end - mid;\n  var l, r, o;\n\n  for (l = 0; l < sizeLeft; l++)\n    lBuffer[l] = out[start + l];\n  for (r = 0; r < sizeRight; r++)\n    rBuffer[r] = out[mid + r];\n\n  l = 0;\n  r = 0;\n  o = start;\n  while (l < sizeLeft && r < sizeRight) {\n    if (lBuffer[l] <= rBuffer[r]) {\n      out[o++] = lBuffer[l++];\n      out[o++] = lBuffer[l++];\n    } else {\n      out[o++] = rBuffer[r++];\n      out[o++] = rBuffer[r++];\n    }\n  }\n  while (l < sizeLeft)\n    out[o++] = lBuffer[l++];\n  while (r < sizeRight)\n    out[o++] = rBuffer[r++];\n}\n\ndefineIDLClass(URLSearchParams.prototype, 'URLSearchParams', {\n  append(name, value) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n    if (arguments.length < 2) {\n      throw new errors.TypeError('ERR_MISSING_ARGS', 'name', 'value');\n    }\n\n    name = toUSVString(name);\n    value = toUSVString(value);\n    this[searchParams].push(name, value);\n    update(this[context], this);\n  },\n\n  delete(name) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n    if (arguments.length < 1) {\n      throw new errors.TypeError('ERR_MISSING_ARGS', 'name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (var i = 0; i < list.length;) {\n      const cur = list[i];\n      if (cur === name) {\n        list.splice(i, 2);\n      } else {\n        i += 2;\n      }\n    }\n    update(this[context], this);\n  },\n\n  get(name) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n    if (arguments.length < 1) {\n      throw new errors.TypeError('ERR_MISSING_ARGS', 'name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (var i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        return list[i + 1];\n      }\n    }\n    return null;\n  },\n\n  getAll(name) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n    if (arguments.length < 1) {\n      throw new errors.TypeError('ERR_MISSING_ARGS', 'name');\n    }\n\n    const list = this[searchParams];\n    const values = [];\n    name = toUSVString(name);\n    for (var i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        values.push(list[i + 1]);\n      }\n    }\n    return values;\n  },\n\n  has(name) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n    if (arguments.length < 1) {\n      throw new errors.TypeError('ERR_MISSING_ARGS', 'name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (var i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  set(name, value) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n    if (arguments.length < 2) {\n      throw new errors.TypeError('ERR_MISSING_ARGS', 'name', 'value');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    value = toUSVString(value);\n\n    // If there are any name-value pairs whose name is `name`, in `list`, set\n    // the value of the first such name-value pair to `value` and remove the\n    // others.\n    var found = false;\n    for (var i = 0; i < list.length;) {\n      const cur = list[i];\n      if (cur === name) {\n        if (!found) {\n          list[i + 1] = value;\n          found = true;\n          i += 2;\n        } else {\n          list.splice(i, 2);\n        }\n      } else {\n        i += 2;\n      }\n    }\n\n    // Otherwise, append a new name-value pair whose name is `name` and value\n    // is `value`, to `list`.\n    if (!found) {\n      list.push(name, value);\n    }\n\n    update(this[context], this);\n  },\n\n  sort() {\n    const a = this[searchParams];\n    const len = a.length;\n    if (len <= 2) {\n      return;\n    }\n\n    // arbitrary number found through testing\n    if (len < 100) {\n      // Simple stable in-place insertion sort\n      // Derived from v8/src/js/array.js\n      for (var i = 2; i < len; i += 2) {\n        var curKey = a[i];\n        var curVal = a[i + 1];\n        var j;\n        for (j = i - 2; j >= 0; j -= 2) {\n          if (a[j] > curKey) {\n            a[j + 2] = a[j];\n            a[j + 3] = a[j + 1];\n          } else {\n            break;\n          }\n        }\n        a[j + 2] = curKey;\n        a[j + 3] = curVal;\n      }\n    } else {\n      // Bottom-up iterative stable merge sort\n      const lBuffer = new Array(len);\n      const rBuffer = new Array(len);\n      for (var step = 2; step < len; step *= 2) {\n        for (var start = 0; start < len - 2; start += 2 * step) {\n          var mid = start + step;\n          var end = mid + step;\n          end = end < len ? end : len;\n          if (mid > end)\n            continue;\n          merge(a, start, mid, end, lBuffer, rBuffer);\n        }\n      }\n    }\n\n    update(this[context], this);\n  },\n\n  // https://heycam.github.io/webidl/#es-iterators\n  // Define entries here rather than [Symbol.iterator] as the function name\n  // must be set to `entries`.\n  entries() {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n\n    return createSearchParamsIterator(this, 'key+value');\n  },\n\n  forEach(callback, thisArg = undefined) {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n    if (typeof callback !== 'function') {\n      throw new errors.TypeError('ERR_INVALID_CALLBACK');\n    }\n\n    let list = this[searchParams];\n\n    var i = 0;\n    while (i < list.length) {\n      const key = list[i];\n      const value = list[i + 1];\n      callback.call(thisArg, value, key, this);\n      // in case the URL object's `search` is updated\n      list = this[searchParams];\n      i += 2;\n    }\n  },\n\n  // https://heycam.github.io/webidl/#es-iterable\n  keys() {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n\n    return createSearchParamsIterator(this, 'key');\n  },\n\n  values() {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n\n    return createSearchParamsIterator(this, 'value');\n  },\n\n  // https://heycam.github.io/webidl/#es-stringifier\n  // https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior\n  toString() {\n    if (!this || !this[searchParams] || this[searchParams][searchParams]) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParams');\n    }\n\n    return serializeParams(this[searchParams]);\n  }\n});\n\n// https://heycam.github.io/webidl/#es-iterable-entries\nObject.defineProperty(URLSearchParams.prototype, Symbol.iterator, {\n  writable: true,\n  configurable: true,\n  value: URLSearchParams.prototype.entries\n});\n\n// https://heycam.github.io/webidl/#dfn-default-iterator-object\nfunction createSearchParamsIterator(target, kind) {\n  const iterator = Object.create(URLSearchParamsIteratorPrototype);\n  iterator[context] = {\n    target,\n    kind,\n    index: 0\n  };\n  return iterator;\n}\n\n// https://heycam.github.io/webidl/#dfn-iterator-prototype-object\nconst URLSearchParamsIteratorPrototype = Object.create(IteratorPrototype);\n\ndefineIDLClass(URLSearchParamsIteratorPrototype, 'URLSearchParamsIterator', {\n  next() {\n    if (!this ||\n        Object.getPrototypeOf(this) !== URLSearchParamsIteratorPrototype) {\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParamsIterator');\n    }\n\n    const {\n      target,\n      kind,\n      index\n    } = this[context];\n    const values = target[searchParams];\n    const len = values.length;\n    if (index >= len) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    const name = values[index];\n    const value = values[index + 1];\n    this[context].index = index + 2;\n\n    let result;\n    if (kind === 'key') {\n      result = name;\n    } else if (kind === 'value') {\n      result = value;\n    } else {\n      result = [name, value];\n    }\n\n    return {\n      value: result,\n      done: false\n    };\n  },\n  [util.inspect.custom](recurseTimes, ctx) {\n    if (this == null || this[context] == null || this[context].target == null)\n      throw new errors.TypeError('ERR_INVALID_THIS', 'URLSearchParamsIterator');\n\n    if (typeof recurseTimes === 'number' && recurseTimes < 0)\n      return ctx.stylize('[Object]', 'special');\n\n    const innerOpts = Object.assign({}, ctx);\n    if (recurseTimes !== null) {\n      innerOpts.depth = recurseTimes - 1;\n    }\n    const {\n      target,\n      kind,\n      index\n    } = this[context];\n    const output = target[searchParams].slice(index).reduce((prev, cur, i) => {\n      const key = i % 2 === 0;\n      if (kind === 'key' && key) {\n        prev.push(cur);\n      } else if (kind === 'value' && !key) {\n        prev.push(cur);\n      } else if (kind === 'key+value' && !key) {\n        prev.push([target[searchParams][index + i - 1], cur]);\n      }\n      return prev;\n    }, []);\n    const breakLn = util.inspect(output, innerOpts).includes('\\n');\n    const outputStrs = output.map((p) => util.inspect(p, innerOpts));\n    let outputStr;\n    if (breakLn) {\n      outputStr = `\\n  ${outputStrs.join(',\\n  ')}`;\n    } else {\n      outputStr = ` ${outputStrs.join(', ')}`;\n    }\n    return `${this[Symbol.toStringTag]} {${outputStr} }`;\n  }\n});\n\nfunction domainToASCII(domain) {\n  if (arguments.length < 1)\n    throw new errors.TypeError('ERR_MISSING_ARGS', 'domain');\n\n  // toUSVString is not needed.\n  return _domainToASCII(`${domain}`);\n}\n\nfunction domainToUnicode(domain) {\n  if (arguments.length < 1)\n    throw new errors.TypeError('ERR_MISSING_ARGS', 'domain');\n\n  // toUSVString is not needed.\n  return _domainToUnicode(`${domain}`);\n}\n\n// Utility function that converts a URL object into an ordinary\n// options object as expected by the http.request and https.request\n// APIs.\nfunction urlToOptions(url) {\n  var options = {\n    protocol: url.protocol,\n    host: url.host,\n    hostname: url.hostname,\n    hash: url.hash,\n    search: url.search,\n    pathname: url.pathname,\n    path: `${url.pathname}${url.search}`,\n    href: url.href\n  };\n  if (url.port !== '') {\n    options.port = Number(url.port);\n  }\n  if (url.username || url.password) {\n    options.auth = `${url.username}:${url.password}`;\n  }\n  return options;\n}\n\nfunction getPathFromURLWin32(url) {\n  var hostname = url.hostname;\n  var pathname = url.pathname;\n  for (var n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      var third = pathname.codePointAt(n + 2) | 0x20;\n      if ((pathname[n + 1] === '2' && third === 102) || // 2f 2F /\n          (pathname[n + 1] === '5' && third === 99)) {  // 5c 5C \\\n        return new errors.TypeError(\n          'ERR_INVALID_FILE_URL_PATH',\n          'must not include encoded \\\\ or / characters');\n      }\n    }\n  }\n  pathname = decodeURIComponent(pathname);\n  if (hostname !== '') {\n    // If hostname is set, then we have a UNC path\n    // Pass the hostname through domainToUnicode just in case\n    // it is an IDN using punycode encoding. We do not need to worry\n    // about percent encoding because the URL parser will have\n    // already taken care of that for us. Note that this only\n    // causes IDNs with an appropriate `xn--` prefix to be decoded.\n    return `//${domainToUnicode(hostname)}${pathname}`;\n  } else {\n    // Otherwise, it's a local path that requires a drive letter\n    var letter = pathname.codePointAt(1) | 0x20;\n    var sep = pathname[2];\n    if (letter < 97 || letter > 122 ||   // a..z A..Z\n        (sep !== ':')) {\n      return new errors.TypeError('ERR_INVALID_FILE_URL_PATH',\n                                  'must be absolute');\n    }\n    return pathname.slice(1);\n  }\n}\n\nfunction getPathFromURLPosix(url) {\n  if (url.hostname !== '') {\n    return new errors.TypeError('ERR_INVALID_FILE_URL_HOST',\n                                `must be \"localhost\" or empty on ${platform}`);\n  }\n  var pathname = url.pathname;\n  for (var n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      var third = pathname.codePointAt(n + 2) | 0x20;\n      if (pathname[n + 1] === '2' && third === 102) {\n        return new errors.TypeError('ERR_INVALID_FILE_URL_PATH',\n                                    'must not include encoded / characters');\n      }\n    }\n  }\n  return decodeURIComponent(pathname);\n}\n\nfunction getPathFromURL(path) {\n  if (path == null || !path[searchParams] ||\n      !path[searchParams][searchParams]) {\n    return path;\n  }\n  if (path.protocol !== 'file:')\n    return new errors.TypeError('ERR_INVALID_URL_SCHEME', 'file');\n  return isWindows ? getPathFromURLWin32(path) : getPathFromURLPosix(path);\n}\n\nfunction NativeURL(ctx) {\n  this[context] = ctx;\n}\nNativeURL.prototype = URL.prototype;\n\nfunction constructUrl(flags, protocol, username, password,\n                      host, port, path, query, fragment) {\n  var ctx = new URLContext();\n  ctx.flags = flags;\n  ctx.scheme = protocol;\n  ctx.username = (flags & URL_FLAGS_HAS_USERNAME) !== 0 ? username : '';\n  ctx.password = (flags & URL_FLAGS_HAS_PASSWORD) !== 0 ? password : '';\n  ctx.port = port;\n  ctx.path = (flags & URL_FLAGS_HAS_PATH) !== 0 ? path : [];\n  ctx.query = query;\n  ctx.fragment = fragment;\n  ctx.host = host;\n  const url = new NativeURL(ctx);\n  url[searchParams] = new URLSearchParams();\n  url[searchParams][context] = url;\n  initSearchParams(url[searchParams], query);\n  return url;\n}\nsetURLConstructor(constructUrl);\n\nmodule.exports = {\n  toUSVString,\n  getPathFromURL,\n  URL,\n  URLSearchParams,\n  domainToASCII,\n  domainToUnicode,\n  urlToOptions,\n  formatSymbol: kFormat,\n  searchParamsSymbol: searchParams\n};\n\n});"},
    {"fileId":10, "filename":"assert.js", "source":"(function (exports, require, module, __filename, __dirname) { // Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// UTILITY\nconst compare = process.binding('buffer').compare;\nconst util = require('util');\nconst { isSet, isMap } = process.binding('util');\nconst objectToString = require('internal/util').objectToString;\nconst Buffer = require('buffer').Buffer;\n\nconst trace_mgr = require('trace_mgr'); //ENABLE_TTD\n\nvar errors;\nfunction lazyErrors() {\n  if (!errors)\n    errors = require('internal/errors');\n  return errors;\n}\n\n// The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nconst assert = module.exports = ok;\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  trace_mgr.emitTrace('emitOnAssert'); //ENABLE_TTD\n\n  if (arguments.length === 1)\n    message = actual;\n  if (arguments.length === 2)\n    operator = '!=';\n  const errors = lazyErrors();\n  throw new errors.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// The AssertionError is defined in internal/error.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected });\nassert.AssertionError = lazyErrors().AssertionError;\n\n\n// Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n/* eslint-disable no-restricted-properties */\nassert.equal = function equal(actual, expected, message) {\n  // eslint-disable-next-line eqeqeq\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// The non-equality assertion tests for whether two objects are not\n// equal with !=.\n// assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  // eslint-disable-next-line eqeqeq\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n/* eslint-enable */\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);\n  }\n};\n\nfunction areSimilarRegExps(a, b) {\n  return a.source === b.source && a.flags === b.flags;\n}\n\nfunction areSimilarTypedArrays(a, b) {\n  return compare(Buffer.from(a.buffer,\n                             a.byteOffset,\n                             a.byteLength),\n                 Buffer.from(b.buffer,\n                             b.byteOffset,\n                             b.byteLength)) === 0;\n}\n\nfunction isNullOrNonObj(object) {\n  return object === null || typeof object !== 'object';\n}\n\nfunction isFloatTypedArrayTag(tag) {\n  return tag === '[object Float32Array]' || tag === '[object Float64Array]';\n}\n\nfunction isArguments(tag) {\n  return tag === '[object Arguments]';\n}\n\nfunction _deepEqual(actual, expected, strict, memos) {\n  // All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  }\n\n  // For primitives / functions\n  // (determined by typeof value !== 'object'),\n  // or null, equivalence is determined by === or ==.\n  if (isNullOrNonObj(actual) && isNullOrNonObj(expected)) {\n    // eslint-disable-next-line eqeqeq\n    return strict ? actual === expected : actual == expected;\n  }\n\n  // If they bypass the previous check, then at least\n  // one of them must be an non-null object.\n  // If the other one is null or undefined, they must not be equal.\n  if (actual === null || actual === undefined ||\n      expected === null || expected === undefined)\n    return false;\n\n  // Notes: Type tags are historical [[Class]] properties that can be set by\n  // FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS\n  // and retrieved using Object.prototype.toString.call(obj) in JS\n  // See https://tc39.github.io/ecma262/#sec-object.prototype.tostring\n  // for a list of tags pre-defined in the spec.\n  // There are some unspecified tags in the wild too (e.g. typed array tags).\n  // Since tags can be altered, they only serve fast failures\n  const actualTag = objectToString(actual);\n  const expectedTag = objectToString(expected);\n\n  // Passing null or undefined to Object.getPrototypeOf() will throw\n  // so this must done after previous checks.\n  // For strict comparison, objects should have\n  // a) The same prototypes.\n  // b) The same built-in type tags\n  if (strict) {\n    if (Object.getPrototypeOf(actual) !== Object.getPrototypeOf(expected)) {\n      return false;\n    }\n\n    if (actualTag !== expectedTag) {\n      return false;\n    }\n  }\n\n  // Do fast checks for builtin types.\n  // If they don't match, they must not be equal.\n  // If they match, return true for non-strict comparison.\n  // For strict comparison we need to exam further.\n\n  // If both values are Date objects,\n  // check if the time underneath are equal first.\n  if (util.isDate(actual) && util.isDate(expected)) {\n    if (actual.getTime() !== expected.getTime()) {\n      return false;\n    } else if (!strict) {\n      return true;  // Skip further checks for non-strict comparison.\n    }\n  }\n\n  // If both values are RegExp, check if they have\n  // the same source and flags first\n  if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    if (!areSimilarRegExps(actual, expected)) {\n      return false;\n    } else if (!strict) {\n      return true;  // Skip further checks for non-strict comparison.\n    }\n  }\n\n  // Ensure reflexivity of deepEqual with `arguments` objects.\n  // See https://github.com/nodejs/node-v0.x-archive/pull/7178\n  if (isArguments(actualTag) !== isArguments(expectedTag)) {\n    return false;\n  }\n\n  // Check typed arrays and buffers by comparing the content in their\n  // underlying ArrayBuffer. This optimization requires that it's\n  // reasonable to interpret their underlying memory in the same way,\n  // which is checked by comparing their type tags.\n  // (e.g. a Uint8Array and a Uint16Array with the same memory content\n  // could still be different because they will be interpreted differently)\n  // Never perform binary comparisons for Float*Arrays, though,\n  // since e.g. +0 === -0 is true despite the two values' bit patterns\n  // not being identical.\n  if (ArrayBuffer.isView(actual) && ArrayBuffer.isView(expected) &&\n      actualTag === expectedTag && !isFloatTypedArrayTag(actualTag)) {\n    if (!areSimilarTypedArrays(actual, expected)) {\n      return false;\n    } else if (!strict) {\n      return true;  // Skip further checks for non-strict comparison.\n    }\n\n    // Buffer.compare returns true, so actual.length === expected.length\n    // if they both only contain numeric keys, we don't need to exam further\n    if (Object.keys(actual).length === actual.length &&\n        Object.keys(expected).length === expected.length) {\n      return true;\n    }\n  }\n\n  // For all other Object pairs, including Array objects and Maps,\n  // equivalence is determined by having:\n  // a) The same number of owned enumerable properties\n  // b) The same set of keys/indexes (although not necessarily the same order)\n  // c) Equivalent values for every corresponding key/index\n  // d) For Sets and Maps, equal contents\n  // Note: this accounts for both named and indexed properties on Arrays.\n\n  // Use memos to handle cycles.\n  if (!memos) {\n    memos = {\n      actual: { map: new Map(), position: 0 },\n      expected: { map: new Map(), position: 0 }\n    };\n  }\n\n  const actualPosition = memos.actual.map.get(actual);\n  if (actualPosition !== undefined) {\n    if (actualPosition === memos.expected.map.get(expected)) {\n      return true;\n    }\n  } else {\n    memos.actual.map.set(actual, memos.actual.position++);\n  }\n  if (!memos.expected.map.has(expected)) {\n    memos.expected.map.set(expected, memos.expected.position++);\n  }\n\n  return objEquiv(actual, expected, strict, memos);\n}\n\nfunction setHasSimilarElement(set, val1, strict, memo) {\n  if (set.has(val1))\n    return true;\n\n  // In strict mode the only things which can match a primitive or a function\n  // will already be detected by set.has(val1).\n  if (strict && (util.isPrimitive(val1) || util.isFunction(val1)))\n    return false;\n\n  // Otherwise go looking.\n  for (const val2 of set) {\n    if (_deepEqual(val1, val2, strict, memo))\n      return true;\n  }\n\n  return false;\n}\n\nfunction setEquiv(a, b, strict, memo) {\n  // This code currently returns false for this pair of sets:\n  //   assert.deepEqual(new Set(['1', 1]), new Set([1]))\n  //\n  // In theory, all the items in the first set have a corresponding == value in\n  // the second set, but the sets have different sizes. Its a silly case,\n  // and more evidence that deepStrictEqual should always be preferred over\n  // deepEqual.\n  if (a.size !== b.size)\n    return false;\n\n  for (const val1 of a) {\n    // If the value doesn't exist in the second set by reference, and its an\n    // object or an array we'll need to go hunting for something thats\n    // deep-equal to it. Note that this is O(n^2) complexity, and will get\n    // slower if large, very similar sets / maps are nested inside.\n    // Unfortunately there's no real way around this.\n    if (!setHasSimilarElement(b, val1, strict, memo)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction mapHasSimilarEntry(map, key1, item1, strict, memo) {\n  // To be able to handle cases like:\n  //   Map([[1, 'a'], ['1', 'b']]) vs Map([['1', 'a'], [1, 'b']])\n  // or:\n  //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])\n  // ... we need to consider *all* matching keys, not just the first we find.\n\n  // This check is not strictly necessary. The loop performs this check, but\n  // doing it here improves performance of the common case when reference-equal\n  // keys exist (which includes all primitive-valued keys).\n  if (map.has(key1) && _deepEqual(item1, map.get(key1), strict, memo))\n    return true;\n\n  if (strict && (util.isPrimitive(key1) || util.isFunction(key1)))\n    return false;\n\n  for (const [key2, item2] of map) {\n    // This case is checked above.\n    if (key2 === key1)\n      continue;\n\n    if (_deepEqual(key1, key2, strict, memo) &&\n        _deepEqual(item1, item2, strict, memo)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction mapEquiv(a, b, strict, memo) {\n  // Caveat: In non-strict mode, this implementation does not handle cases\n  // where maps contain two equivalent-but-not-reference-equal keys.\n  //\n  // For example, maps like this are currently considered not equivalent:\n  if (a.size !== b.size)\n    return false;\n\n  for (const [key1, item1] of a) {\n    // Just like setEquiv above, this hunt makes this function O(n^2) when\n    // using objects and lists as keys\n    if (!mapHasSimilarEntry(b, key1, item1, strict, memo))\n      return false;\n  }\n\n  return true;\n}\n\nfunction objEquiv(a, b, strict, actualVisitedObjects) {\n  // If one of them is a primitive, the other must be the same.\n  if (util.isPrimitive(a) || util.isPrimitive(b))\n    return a === b;\n\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n  var key, i;\n\n  // The pair must have the same number of owned properties\n  // (keys incorporates hasOwnProperty).\n  if (aKeys.length !== bKeys.length)\n    return false;\n\n  // The pair must have the same set of keys (although not\n  // necessarily in the same order).\n  aKeys.sort();\n  bKeys.sort();\n  // Cheap key test:\n  for (i = aKeys.length - 1; i >= 0; i--) {\n    if (aKeys[i] !== bKeys[i])\n      return false;\n  }\n\n  // Sets and maps don't have their entries accessible via normal object\n  // properties.\n  if (isSet(a)) {\n    if (!isSet(b) || !setEquiv(a, b, strict, actualVisitedObjects))\n      return false;\n  } else if (isSet(b)) {\n    return false;\n  }\n\n  if (isMap(a)) {\n    if (!isMap(b) || !mapEquiv(a, b, strict, actualVisitedObjects))\n      return false;\n  } else if (isMap(b)) {\n    return false;\n  }\n\n  // The pair must have equivalent values for every corresponding key.\n  // Possibly expensive deep test:\n  for (i = aKeys.length - 1; i >= 0; i--) {\n    key = aKeys[i];\n    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))\n      return false;\n  }\n  return true;\n}\n\n// The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);\n  }\n}\n\n// The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// The strict non-equality assertion tests for strict inequality, as\n// determined by !==.\n// assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  // actual is guaranteed to be an Error object, but we need to check expected.\n  if (!expected) {\n    return false;\n  }\n\n  if (objectToString(expected) === '[object RegExp]') {\n    return expected.test(actual);\n  }\n\n  try {\n    if (actual instanceof expected) {\n      return true;\n    }\n  } catch (e) {\n    // Ignore. The instanceof check doesn't work for arrow functions.\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction _tryBlock(block) {\n  var error;\n  try {\n    block();\n  } catch (e) {\n    error = e;\n  }\n  return error;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof block !== 'function') {\n    const errors = lazyErrors();\n    throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 'block', 'function',\n                               typeof block);\n  }\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  actual = _tryBlock(block);\n\n  message = (expected && expected.name ? ' (' + expected.name + ')' : '') +\n            (message ? ': ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  const userProvidedMessage = typeof message === 'string';\n  const isUnwantedException = !shouldThrow && util.isError(actual);\n  const isUnexpectedException = !shouldThrow && actual && !expected;\n\n  if ((isUnwantedException &&\n      userProvidedMessage &&\n      expectedException(actual, expected)) ||\n      isUnexpectedException) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// Expected to throw an error.\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function throws(block, /*optional*/error, /*optional*/message) {\n  _throws(true, block, error, message);\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = doesNotThrow;\nfunction doesNotThrow(block, /*optional*/error, /*optional*/message) {\n  _throws(false, block, error, message);\n}\n\nassert.ifError = function ifError(err) { if (err) throw err; };\n\n});"},
    {"fileId":11, "filename":"_stream_readable.js", "source":"(function (exports, require, module, __filename, __dirname) { // Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nmodule.exports = Readable;\nReadable.ReadableState = ReadableState;\n\nconst EE = require('events');\nconst Stream = require('stream');\nconst Buffer = require('buffer').Buffer;\nconst util = require('util');\nconst debug = util.debuglog('stream');\nconst BufferList = require('internal/streams/BufferList');\nconst destroyImpl = require('internal/streams/destroy');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nconst kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') {\n    return emitter.prependListener(event, fn);\n  } else {\n    // This is a hack to make sure that our error handler is attached before any\n    // userland ones.  NEVER DO THIS. This is here only because this code needs\n    // to continue to work with older versions of Node.js that do not include\n    // the prependListener() method. The goal is to eventually remove this hack.\n    if (!emitter._events || !emitter._events[event])\n      emitter.on(event, fn);\n    else if (Array.isArray(emitter._events[event]))\n      emitter._events[event].unshift(fn);\n    else\n      emitter._events[event] = [fn, emitter._events[event]];\n  }\n}\n\nfunction ReadableState(options, stream) {\n  options = options || {};\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Stream.Duplex)\n    this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder)\n      StringDecoder = require('string_decoder').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function')\n      this._read = options.read;\n\n    if (typeof options.destroy === 'function')\n      this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function(err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck)\n      er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (addToFront) {\n        if (state.endEmitted)\n          stream.emit('error', new Error('stream.unshift() after end event'));\n        else\n          addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0)\n            addChunk(stream, state, chunk, false);\n          else\n            maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront)\n      state.buffer.unshift(chunk);\n    else\n      state.buffer.push(chunk);\n\n    if (state.needReadable)\n      emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!(chunk instanceof Buffer) &&\n      typeof chunk !== 'string' &&\n      chunk !== undefined &&\n      !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended &&\n         (state.needReadable ||\n          state.length < state.highWaterMark ||\n          state.length === 0);\n}\n\nReadable.prototype.isPaused = function() {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  if (!StringDecoder)\n    StringDecoder = require('string_decoder').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nconst MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || (state.length === 0 && state.ended))\n    return 0;\n  if (state.objectMode)\n    return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length)\n      return state.buffer.head.data.length;\n    else\n      return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark)\n    state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length)\n    return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0)\n    state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended)\n      endReadable(this);\n    else\n      emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading)\n      n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended)\n      state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended)\n      endReadable(this);\n  }\n\n  if (ret !== null)\n    this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync)\n      process.nextTick(emitReadable_, stream);\n    else\n      emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended &&\n         state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n    else\n      len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted)\n    process.nextTick(endFn);\n  else\n    src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain &&\n        (!dest._writableState || dest._writableState.needDrain))\n      ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if (((state.pipesCount === 1 && state.pipes === dest) ||\n           (state.pipesCount > 1 && state.pipes.indexOf(dest) !== -1)) &&\n          !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EE.listenerCount(dest, 'error') === 0)\n      dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain)\n      state.awaitDrain--;\n    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0)\n    return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes)\n      return this;\n\n    if (!dest)\n      dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest)\n      dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++)\n      dests[i].emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // try to find the right one.\n  var index = state.pipes.indexOf(dest);\n  if (index === -1)\n    return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1)\n    state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n  const res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false)\n      this.resume();\n  } else if (ev === 'readable') {\n    const state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading)\n    stream.read(0);\n}\n\nReadable.prototype.pause = function() {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  const state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null);\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function() {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length)\n        self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function(chunk) {\n    debug('wrapped data');\n    if (state.decoder)\n      chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined))\n      return;\n    else if (!state.objectMode && (!chunk || !chunk.length))\n      return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function(method) {\n        return function() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function(n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0)\n    return null;\n\n  var ret;\n  if (state.objectMode)\n    ret = state.buffer.shift();\n  else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder)\n      ret = state.buffer.join('');\n    else if (state.buffer.length === 1)\n      ret = state.buffer.head.data;\n    else\n      ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = (hasStrings ?\n           copyFromBufferString(n, list) :\n           copyFromBuffer(n, list));\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    const str = p.data;\n    const nb = (n > str.length ? str.length : n);\n    if (nb === str.length)\n      ret += str;\n    else\n      ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next)\n          list.head = p.next;\n        else\n          list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  const ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    const buf = p.data;\n    const nb = (n > buf.length ? buf.length : n);\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next)\n          list.head = p.next;\n        else\n          list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0)\n    throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\n});"},
    {"fileId":12, "filename":"buffer.js", "source":"(function (exports, require, module, __filename, __dirname) { // Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst binding = process.binding('buffer');\nconst config = process.binding('config');\nconst { compare: compare_, compareOffset } = binding;\nconst { isAnyArrayBuffer, isUint8Array } = process.binding('util');\nconst bindingObj = {};\nconst internalUtil = require('internal/util');\nconst pendingDeprecation = !!config.pendingDeprecation;\n\nclass FastBuffer extends Uint8Array {\n  constructor(arg1, arg2, arg3) {\n    super(arg1, arg2, arg3);\n  }\n}\nFastBuffer.prototype.constructor = Buffer;\n\nBuffer.prototype = FastBuffer.prototype;\n\nexports.Buffer = Buffer;\nexports.SlowBuffer = SlowBuffer;\nexports.INSPECT_MAX_BYTES = 50;\nexports.kMaxLength = binding.kMaxLength;\n\nconst kFromErrorMsg = 'First argument must be a string, Buffer, ' +\n                      'ArrayBuffer, Array, or array-like object.';\n\nBuffer.poolSize = 8 * 1024;\nvar poolSize, poolOffset, allocPool;\n\n\nbinding.setupBufferJS(Buffer.prototype, bindingObj);\n\n// |binding.zeroFill| can be undefined when running inside an isolate where we\n// do not own the ArrayBuffer allocator.  Zero fill is always on in that case.\nconst zeroFill = bindingObj.zeroFill || [0];\n\nfunction createUnsafeBuffer(size) {\n  return new FastBuffer(createUnsafeArrayBuffer(size));\n}\n\nfunction createUnsafeArrayBuffer(size) {\n  zeroFill[0] = 0;\n  try {\n    return new ArrayBuffer(size);\n  } finally {\n    zeroFill[0] = 1;\n  }\n}\n\nfunction createPool() {\n  poolSize = Buffer.poolSize;\n  allocPool = createUnsafeArrayBuffer(poolSize);\n  poolOffset = 0;\n}\ncreatePool();\n\n\nfunction alignPool() {\n  // Ensure aligned slices\n  if (poolOffset & 0x7) {\n    poolOffset |= 0x7;\n    poolOffset++;\n  }\n}\n\n// Mark a constructor not supporting @@species\nfunction markNoSpeciesConstructor(constructor) {\n  if (Symbol.species) {\n    Object.defineProperty(constructor, Symbol.species, {\n      get: function() { return undefined; },\n      configurable: true,\n    });\n  }\n}\n\nvar bufferWarn = true;\nconst bufferWarning = 'The Buffer() and new Buffer() constructors are not ' +\n                      'recommended for use due to security and usability ' +\n                      'concerns. Please use the new Buffer.alloc(), ' +\n                      'Buffer.allocUnsafe(), or Buffer.from() construction ' +\n                      'methods instead.';\n\nfunction showFlaggedDeprecation() {\n  if (bufferWarn) {\n    // This is a *pending* deprecation warning. It is not emitted by\n    // default unless the --pending-deprecation command-line flag is\n    // used or the NODE_PENDING_DEPRECATION=1 envvar is set.\n    process.emitWarning(bufferWarning, 'DeprecationWarning', 'DEP0005');\n    bufferWarn = false;\n  }\n}\n\nconst doFlaggedDeprecation =\n  pendingDeprecation ?\n    showFlaggedDeprecation :\n    function() {};\n\n/**\n * The Buffer() construtor is deprecated in documentation and should not be\n * used moving forward. Rather, developers should use one of the three new\n * factory APIs: Buffer.from(), Buffer.allocUnsafe() or Buffer.alloc() based on\n * their specific needs. There is no runtime deprecation because of the extent\n * to which the Buffer constructor is used in the ecosystem currently -- a\n * runtime deprecation would introduce too much breakage at this time. It's not\n * likely that the Buffer constructors would ever actually be removed.\n * Deprecation Code: DEP0005\n **/\nfunction Buffer(arg, encodingOrOffset, length) {\n  doFlaggedDeprecation();\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      );\n    }\n    return Buffer.alloc(arg);\n  }\n  return Buffer.from(arg, encodingOrOffset, length);\n}\n\nObject.defineProperty(Buffer, Symbol.species, {\n  enumerable: false,\n  configurable: true,\n  get() { return FastBuffer; }\n});\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function(value, encodingOrOffset, length) {\n  if (typeof value === 'string')\n    return fromString(value, encodingOrOffset);\n\n  if (isAnyArrayBuffer(value))\n    return fromArrayBuffer(value, encodingOrOffset, length);\n\n  var b = fromObject(value);\n  if (b)\n    return b;\n\n  if (typeof value === 'number')\n    throw new TypeError('\"value\" argument must not be a number');\n  throw new TypeError(kFromErrorMsg);\n};\n\nObject.setPrototypeOf(Buffer, Uint8Array);\nmarkNoSpeciesConstructor(Buffer);\n\n// The 'assertSize' method will remove itself from the callstack when an error\n// occurs. This is done simply to keep the internal details of the\n// implementation from bleeding out to users.\nfunction assertSize(size) {\n  let err = null;\n\n  if (typeof size !== 'number')\n    err = new TypeError('\"size\" argument must be a number');\n  else if (size < 0)\n    err = new RangeError('\"size\" argument must not be negative');\n  else if (size > binding.kMaxLength)\n    err = new RangeError('\"size\" argument must not be larger ' +\n                         'than ' + binding.kMaxLength);\n\n  if (err) {\n    Error.captureStackTrace(err, assertSize);\n    throw err;\n  }\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function(size, fill, encoding) {\n  assertSize(size);\n  if (size > 0 && fill !== undefined) {\n    // Since we are filling anyway, don't zero fill initially.\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    if (typeof encoding !== 'string')\n      encoding = undefined;\n    return createUnsafeBuffer(size).fill(fill, encoding);\n  }\n  return new FastBuffer(size);\n};\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer\n * instance. If `--zero-fill-buffers` is set, will zero-fill the buffer.\n **/\nBuffer.allocUnsafe = function(size) {\n  assertSize(size);\n  return allocate(size);\n};\n\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled\n * Buffer instance that is not allocated off the pre-initialized pool.\n * If `--zero-fill-buffers` is set, will zero-fill the buffer.\n **/\nBuffer.allocUnsafeSlow = function(size) {\n  assertSize(size);\n  return createUnsafeBuffer(size);\n};\n\n// If --zero-fill-buffers command line argument is set, a zero-filled\n// buffer is returned.\nfunction SlowBuffer(length) {\n  // eslint-disable-next-line eqeqeq\n  if (+length != length)\n    length = 0;\n  assertSize(+length);\n  return createUnsafeBuffer(+length);\n}\n\nObject.setPrototypeOf(SlowBuffer.prototype, Uint8Array.prototype);\nObject.setPrototypeOf(SlowBuffer, Uint8Array);\nmarkNoSpeciesConstructor(SlowBuffer);\n\n\nfunction allocate(size) {\n  if (size <= 0) {\n    return new FastBuffer();\n  }\n  if (size < (Buffer.poolSize >>> 1)) {\n    if (size > (poolSize - poolOffset))\n      createPool();\n    var b = new FastBuffer(allocPool, poolOffset, size);\n    poolOffset += size;\n    alignPool();\n    return b;\n  } else {\n    return createUnsafeBuffer(size);\n  }\n}\n\n\nfunction fromString(string, encoding) {\n  var length;\n  if (typeof encoding !== 'string' || encoding.length === 0) {\n    encoding = 'utf8';\n    if (string.length === 0)\n      return new FastBuffer();\n    length = binding.byteLengthUtf8(string);\n  } else {\n    length = byteLength(string, encoding, true);\n    if (length === -1)\n      throw new TypeError('\"encoding\" must be a valid string encoding');\n    if (string.length === 0)\n      return new FastBuffer();\n  }\n\n  if (length >= (Buffer.poolSize >>> 1))\n    return binding.createFromString(string, encoding);\n\n  if (length > (poolSize - poolOffset))\n    createPool();\n  var b = new FastBuffer(allocPool, poolOffset, length);\n  const actual = b.write(string, encoding);\n  if (actual !== length) {\n    // byteLength() may overestimate. That's a rare case, though.\n    b = new FastBuffer(allocPool, poolOffset, actual);\n  }\n  poolOffset += actual;\n  alignPool();\n  return b;\n}\n\nfunction fromArrayLike(obj) {\n  const length = obj.length;\n  const b = allocate(length);\n  for (var i = 0; i < length; i++)\n    b[i] = obj[i];\n  return b;\n}\n\nfunction fromArrayBuffer(obj, byteOffset, length) {\n  // convert byteOffset to integer\n  if (byteOffset === undefined) {\n    byteOffset = 0;\n  } else {\n    byteOffset = +byteOffset;\n    // check for NaN\n    if (byteOffset !== byteOffset)\n      byteOffset = 0;\n  }\n\n  const maxLength = obj.byteLength - byteOffset;\n\n  if (maxLength < 0)\n    throw new RangeError(\"'offset' is out of bounds\");\n\n  if (length === undefined) {\n    length = maxLength;\n  } else {\n    // convert length to non-negative integer\n    length = +length;\n    // Check for NaN\n    if (length !== length) {\n      length = 0;\n    } else if (length > 0) {\n      length = (length < Number.MAX_SAFE_INTEGER ?\n                length : Number.MAX_SAFE_INTEGER);\n      if (length > maxLength)\n        throw new RangeError(\"'length' is out of bounds\");\n    } else {\n      length = 0;\n    }\n  }\n\n  return new FastBuffer(obj, byteOffset, length);\n}\n\nfunction fromObject(obj) {\n  if (isUint8Array(obj)) {\n    const b = allocate(obj.length);\n\n    if (b.length === 0)\n      return b;\n\n    binding.copy(obj, b, 0, 0, obj.length);\n    return b;\n  }\n\n  if (obj != null) {\n    if (obj.length !== undefined || isAnyArrayBuffer(obj.buffer)) {\n      if (typeof obj.length !== 'number' || obj.length !== obj.length) {\n        return new FastBuffer();\n      }\n      return fromArrayLike(obj);\n    }\n\n    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n      return fromArrayLike(obj.data);\n    }\n  }\n}\n\n\n// Static methods\n\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer;\n};\n\n\nBuffer.compare = function compare(a, b) {\n  if (!isUint8Array(a) || !isUint8Array(b)) {\n    throw new TypeError('Arguments must be Buffers or Uint8Arrays');\n  }\n\n  if (a === b) {\n    return 0;\n  }\n\n  return binding.compare(a, b);\n};\n\n\nBuffer.isEncoding = function(encoding) {\n  return typeof encoding === 'string' &&\n         typeof internalUtil.normalizeEncoding(encoding) === 'string';\n};\nBuffer[internalUtil.kIsEncodingSymbol] = Buffer.isEncoding;\n\nconst kConcatErrMsg = '\"list\" argument must be an Array ' +\n                      'of Buffer or Uint8Array instances';\n\nBuffer.concat = function(list, length) {\n  var i;\n  if (!Array.isArray(list))\n    throw new TypeError(kConcatErrMsg);\n\n  if (list.length === 0)\n    return new FastBuffer();\n\n  if (length === undefined) {\n    length = 0;\n    for (i = 0; i < list.length; i++)\n      length += list[i].length;\n  } else {\n    length = length >>> 0;\n  }\n\n  var buffer = Buffer.allocUnsafe(length);\n  var pos = 0;\n  for (i = 0; i < list.length; i++) {\n    var buf = list[i];\n    if (!isUint8Array(buf))\n      throw new TypeError(kConcatErrMsg);\n    binding.copy(buf, buffer, pos);\n    pos += buf.length;\n  }\n\n  // Note: `length` is always equal to `buffer.length` at this point\n  if (pos < length) {\n    // Zero-fill the remaining bytes if the specified `length` was more than\n    // the actual total length, i.e. if we have some remaining allocated bytes\n    // there were not initialized.\n    buffer.fill(0, pos, length);\n  }\n\n  return buffer;\n};\n\n\nfunction base64ByteLength(str, bytes) {\n  // Handle padding\n  if (str.charCodeAt(bytes - 1) === 0x3D)\n    bytes--;\n  if (bytes > 1 && str.charCodeAt(bytes - 1) === 0x3D)\n    bytes--;\n\n  // Base64 ratio: 3/4\n  return (bytes * 3) >>> 2;\n}\n\n\nfunction byteLength(string, encoding) {\n  if (typeof string !== 'string') {\n    if (ArrayBuffer.isView(string) || isAnyArrayBuffer(string)) {\n      return string.byteLength;\n    }\n\n    throw new TypeError('\"string\" must be a string, Buffer, or ArrayBuffer');\n  }\n\n  const len = string.length;\n  const mustMatch = (arguments.length > 2 && arguments[2] === true);\n  if (!mustMatch && len === 0)\n    return 0;\n\n  if (!encoding)\n    return (mustMatch ? -1 : binding.byteLengthUtf8(string));\n\n  encoding += '';\n  switch (encoding.length) {\n    case 4:\n      if (encoding === 'utf8') return binding.byteLengthUtf8(string);\n      if (encoding === 'ucs2') return len * 2;\n      encoding = encoding.toLowerCase();\n      if (encoding === 'utf8') return binding.byteLengthUtf8(string);\n      if (encoding === 'ucs2') return len * 2;\n      break;\n    case 5:\n      if (encoding === 'utf-8') return binding.byteLengthUtf8(string);\n      if (encoding === 'ascii') return len;\n      if (encoding === 'ucs-2') return len * 2;\n      encoding = encoding.toLowerCase();\n      if (encoding === 'utf-8') return binding.byteLengthUtf8(string);\n      if (encoding === 'ascii') return len;\n      if (encoding === 'ucs-2') return len * 2;\n      break;\n    case 7:\n      if (encoding === 'utf16le' || encoding.toLowerCase() === 'utf16le')\n        return len * 2;\n      break;\n    case 8:\n      if (encoding === 'utf-16le' || encoding.toLowerCase() === 'utf-16le')\n        return len * 2;\n      break;\n    case 6:\n      if (encoding === 'latin1' || encoding === 'binary') return len;\n      if (encoding === 'base64') return base64ByteLength(string, len);\n      encoding = encoding.toLowerCase();\n      if (encoding === 'latin1' || encoding === 'binary') return len;\n      if (encoding === 'base64') return base64ByteLength(string, len);\n      break;\n    case 3:\n      if (encoding === 'hex' || encoding.toLowerCase() === 'hex')\n        return len >>> 1;\n      break;\n  }\n  return (mustMatch ? -1 : binding.byteLengthUtf8(string));\n}\n\nBuffer.byteLength = byteLength;\n\n\n// For backwards compatibility.\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function() {\n    if (!(this instanceof Buffer))\n      return undefined;\n    return this.buffer;\n  }\n});\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function() {\n    if (!(this instanceof Buffer))\n      return undefined;\n    return this.byteOffset;\n  }\n});\n\n\nfunction stringSlice(buf, encoding, start, end) {\n  if (encoding === undefined) return buf.utf8Slice(start, end);\n  encoding += '';\n  switch (encoding.length) {\n    case 4:\n      if (encoding === 'utf8') return buf.utf8Slice(start, end);\n      if (encoding === 'ucs2') return buf.ucs2Slice(start, end);\n      encoding = encoding.toLowerCase();\n      if (encoding === 'utf8') return buf.utf8Slice(start, end);\n      if (encoding === 'ucs2') return buf.ucs2Slice(start, end);\n      break;\n    case 5:\n      if (encoding === 'utf-8') return buf.utf8Slice(start, end);\n      if (encoding === 'ascii') return buf.asciiSlice(start, end);\n      if (encoding === 'ucs-2') return buf.ucs2Slice(start, end);\n      encoding = encoding.toLowerCase();\n      if (encoding === 'utf-8') return buf.utf8Slice(start, end);\n      if (encoding === 'ascii') return buf.asciiSlice(start, end);\n      if (encoding === 'ucs-2') return buf.ucs2Slice(start, end);\n      break;\n    case 6:\n      if (encoding === 'latin1' || encoding === 'binary')\n        return buf.latin1Slice(start, end);\n      if (encoding === 'base64') return buf.base64Slice(start, end);\n      encoding = encoding.toLowerCase();\n      if (encoding === 'latin1' || encoding === 'binary')\n        return buf.latin1Slice(start, end);\n      if (encoding === 'base64') return buf.base64Slice(start, end);\n      break;\n    case 3:\n      if (encoding === 'hex' || encoding.toLowerCase() === 'hex')\n        return buf.hexSlice(start, end);\n      break;\n    case 7:\n      if (encoding === 'utf16le' || encoding.toLowerCase() === 'utf16le')\n        return buf.ucs2Slice(start, end);\n      break;\n    case 8:\n      if (encoding === 'utf-16le' || encoding.toLowerCase() === 'utf-16le')\n        return buf.ucs2Slice(start, end);\n      break;\n  }\n  throw new TypeError('Unknown encoding: ' + encoding);\n}\n\n\nBuffer.prototype.copy = function(target, targetStart, sourceStart, sourceEnd) {\n  return binding.copy(this, target, targetStart, sourceStart, sourceEnd);\n};\n\n// No need to verify that \"buf.length <= MAX_UINT32\" since it's a read-only\n// property of a typed array.\n// This behaves neither like String nor Uint8Array in that we set start/end\n// to their upper/lower bounds if the value passed is out of range.\nBuffer.prototype.toString = function(encoding, start, end) {\n  if (arguments.length === 0) {\n    return this.utf8Slice(0, this.length);\n  }\n\n  const len = this.length;\n  if (len === 0)\n    return '';\n\n  if (!start || start < 0)\n    start = 0;\n  else if (start >= len)\n    return '';\n\n  if (end === undefined || end > len)\n    end = len;\n  else if (end <= 0)\n    return '';\n\n  start |= 0;\n  end |= 0;\n\n  if (end <= start)\n    return '';\n  return stringSlice(this, encoding, start, end);\n};\n\n\nBuffer.prototype.equals = function equals(b) {\n  if (!isUint8Array(b))\n    throw new TypeError('Argument must be a Buffer or Uint8Array');\n\n  if (this === b)\n    return true;\n\n  return binding.compare(this, b) === 0;\n};\n\n\n// Override how buffers are presented by util.inspect().\nBuffer.prototype[internalUtil.customInspectSymbol] = function inspect() {\n  var str = '';\n  var max = exports.INSPECT_MAX_BYTES;\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();\n  if (this.length > max)\n    str += ' ... ';\n  return `<${this.constructor.name} ${str}>`;\n};\nBuffer.prototype.inspect = Buffer.prototype[internalUtil.customInspectSymbol];\n\nBuffer.prototype.compare = function compare(target,\n                                            start,\n                                            end,\n                                            thisStart,\n                                            thisEnd) {\n  if (!isUint8Array(target))\n    throw new TypeError('Argument must be a Buffer or Uint8Array');\n  if (arguments.length === 1)\n    return compare_(this, target);\n\n  if (start === undefined)\n    start = 0;\n  else if (start < 0)\n    throw new RangeError('out of range index');\n  else\n    start >>>= 0;\n\n  if (end === undefined)\n    end = target.length;\n  else if (end > target.length)\n    throw new RangeError('out of range index');\n  else\n    end >>>= 0;\n\n  if (thisStart === undefined)\n    thisStart = 0;\n  else if (thisStart < 0)\n    throw new RangeError('out of range index');\n  else\n    thisStart >>>= 0;\n\n  if (thisEnd === undefined)\n    thisEnd = this.length;\n  else if (thisEnd > this.length)\n    throw new RangeError('out of range index');\n  else\n    thisEnd >>>= 0;\n\n  if (thisStart >= thisEnd)\n    return (start >= end ? 0 : -1);\n  else if (start >= end)\n    return 1;\n\n  return compareOffset(this, target, start, thisStart, end, thisEnd);\n};\n\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = undefined;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n  // Coerce to Number. Values like null and [] become 0.\n  byteOffset = +byteOffset;\n  // If the offset is undefined, \"foo\", {}, coerces to NaN, search whole buffer.\n  // `x !== x`-style conditionals are a faster form of `isNaN(x)`\n  if (byteOffset !== byteOffset) {\n    byteOffset = dir ? 0 : buffer.length;\n  }\n  dir = !!dir;  // Cast to bool.\n\n  if (typeof val === 'string') {\n    if (encoding === undefined) {\n      return binding.indexOfString(buffer, val, byteOffset, encoding, dir);\n    }\n    return slowIndexOf(buffer, val, byteOffset, encoding, dir);\n  } else if (isUint8Array(val)) {\n    return binding.indexOfBuffer(buffer, val, byteOffset, encoding, dir);\n  } else if (typeof val === 'number') {\n    return binding.indexOfNumber(buffer, val, byteOffset, dir);\n  }\n\n  throw new TypeError('\"val\" argument must be string, number, Buffer ' +\n                      'or Uint8Array');\n}\n\n\nfunction slowIndexOf(buffer, val, byteOffset, encoding, dir) {\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'utf8':\n      case 'utf-8':\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n      case 'latin1':\n      case 'binary':\n        return binding.indexOfString(buffer, val, byteOffset, encoding, dir);\n\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return binding.indexOfBuffer(\n            buffer, Buffer.from(val, encoding), byteOffset, encoding, dir);\n\n      default:\n        if (loweredCase) {\n          throw new TypeError('Unknown encoding: ' + encoding);\n        }\n\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;\n    }\n  }\n}\n\n\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\n\n\nBuffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\n\n\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1;\n};\n\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill(val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start;\n      start = 0;\n      end = this.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = this.length;\n    }\n\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string');\n    }\n    var normalizedEncoding = internalUtil.normalizeEncoding(encoding);\n    if (normalizedEncoding === undefined) {\n      throw new TypeError('Unknown encoding: ' + encoding);\n    }\n\n    if (val.length === 0) {\n      // Previously, if val === '', the Buffer would not fill,\n      // which is rather surprising.\n      val = 0;\n    } else if (val.length === 1) {\n      var code = val.charCodeAt(0);\n      if ((normalizedEncoding === 'utf8' && code < 128) ||\n          normalizedEncoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code;\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255;\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || end > this.length)\n    throw new RangeError('Out of range index');\n\n  if (end <= start)\n    return this;\n\n  start = start >>> 0;\n  end = end === undefined ? this.length : end >>> 0;\n\n  binding.fill(this, val, start, end, encoding);\n\n  return this;\n};\n\n\nBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Buffer#write(string);\n  if (offset === undefined) {\n    return this.utf8Write(string, 0, this.length);\n\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0;\n    if (isFinite(length)) {\n      length = length >>> 0;\n    } else {\n      encoding = length;\n      length = undefined;\n    }\n\n    var remaining = this.length - offset;\n    if (length === undefined || length > remaining)\n      length = remaining;\n\n    if (string.length > 0 && (length < 0 || offset < 0))\n      throw new RangeError('Attempt to write outside buffer bounds');\n  } else {\n    // if someone is still calling the obsolete form of write(), tell them.\n    // we don't want eg buf.write(\"foo\", \"utf8\", 10) to silently turn into\n    // buf.write(\"foo\", \"utf8\"), so we can't ignore extra args\n    throw new Error('Buffer.write(string, encoding, offset[, length]) ' +\n                    'is no longer supported');\n  }\n\n  if (!encoding) return this.utf8Write(string, offset, length);\n\n  encoding += '';\n  switch (encoding.length) {\n    case 4:\n      if (encoding === 'utf8') return this.utf8Write(string, offset, length);\n      if (encoding === 'ucs2') return this.ucs2Write(string, offset, length);\n      encoding = encoding.toLowerCase();\n      if (encoding === 'utf8') return this.utf8Write(string, offset, length);\n      if (encoding === 'ucs2') return this.ucs2Write(string, offset, length);\n      break;\n    case 5:\n      if (encoding === 'utf-8') return this.utf8Write(string, offset, length);\n      if (encoding === 'ascii') return this.asciiWrite(string, offset, length);\n      if (encoding === 'ucs-2') return this.ucs2Write(string, offset, length);\n      encoding = encoding.toLowerCase();\n      if (encoding === 'utf-8') return this.utf8Write(string, offset, length);\n      if (encoding === 'ascii') return this.asciiWrite(string, offset, length);\n      if (encoding === 'ucs-2') return this.ucs2Write(string, offset, length);\n      break;\n    case 7:\n      if (encoding === 'utf16le' || encoding.toLowerCase() === 'utf16le')\n        return this.ucs2Write(string, offset, length);\n      break;\n    case 8:\n      if (encoding === 'utf-16le' || encoding.toLowerCase() === 'utf-16le')\n        return this.ucs2Write(string, offset, length);\n      break;\n    case 6:\n      if (encoding === 'latin1' || encoding === 'binary')\n        return this.latin1Write(string, offset, length);\n      if (encoding === 'base64')\n        return this.base64Write(string, offset, length);\n      encoding = encoding.toLowerCase();\n      if (encoding === 'latin1' || encoding === 'binary')\n        return this.latin1Write(string, offset, length);\n      if (encoding === 'base64')\n        return this.base64Write(string, offset, length);\n      break;\n    case 3:\n      if (encoding === 'hex' || encoding.toLowerCase() === 'hex')\n        return this.hexWrite(string, offset, length);\n      break;\n  }\n  throw new TypeError('Unknown encoding: ' + encoding);\n};\n\n\nBuffer.prototype.toJSON = function() {\n  if (this.length > 0) {\n    const data = new Array(this.length);\n    for (var i = 0; i < this.length; ++i)\n      data[i] = this[i];\n    return { type: 'Buffer', data };\n  } else {\n    return { type: 'Buffer', data: [] };\n  }\n};\n\n\nfunction adjustOffset(offset, length) {\n  // Use Math.trunc() to convert offset to an integer value that can be larger\n  // than an Int32. Hence, don't use offset | 0 or similar techniques.\n  offset = Math.trunc(offset);\n  // `x !== x`-style conditionals are a faster form of `isNaN(x)`\n  if (offset === 0 || offset !== offset) {\n    return 0;\n  } else if (offset < 0) {\n    offset += length;\n    return offset > 0 ? offset : 0;\n  } else {\n    return offset < length ? offset : length;\n  }\n}\n\n\nBuffer.prototype.slice = function slice(start, end) {\n  const srcLength = this.length;\n  start = adjustOffset(start, srcLength);\n  end = end !== undefined ? adjustOffset(end, srcLength) : srcLength;\n  const newLength = end > start ? end - start : 0;\n  return new FastBuffer(this.buffer, this.byteOffset + start, newLength);\n};\n\n\nfunction checkOffset(offset, ext, length) {\n  if (offset + ext > length)\n    throw new RangeError('Index out of range');\n}\n\n\nBuffer.prototype.readUIntLE = function(offset, byteLength, noAssert) {\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n  if (!noAssert)\n    checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100))\n    val += this[offset + i] * mul;\n\n  return val;\n};\n\n\nBuffer.prototype.readUIntBE = function(offset, byteLength, noAssert) {\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n  if (!noAssert)\n    checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset + --byteLength];\n  var mul = 1;\n  while (byteLength > 0 && (mul *= 0x100))\n    val += this[offset + --byteLength] * mul;\n\n  return val;\n};\n\n\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 1, this.length);\n  return this[offset];\n};\n\n\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 2, this.length);\n  return this[offset] | (this[offset + 1] << 8);\n};\n\n\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 2, this.length);\n  return (this[offset] << 8) | this[offset + 1];\n};\n\n\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 4, this.length);\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000);\n};\n\n\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 4, this.length);\n\n  return (this[offset] * 0x1000000) +\n      ((this[offset + 1] << 16) |\n      (this[offset + 2] << 8) |\n      this[offset + 3]);\n};\n\n\nBuffer.prototype.readIntLE = function(offset, byteLength, noAssert) {\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n  if (!noAssert)\n    checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100))\n    val += this[offset + i] * mul;\n  mul *= 0x80;\n\n  if (val >= mul)\n    val -= Math.pow(2, 8 * byteLength);\n\n  return val;\n};\n\n\nBuffer.prototype.readIntBE = function(offset, byteLength, noAssert) {\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n  if (!noAssert)\n    checkOffset(offset, byteLength, this.length);\n\n  var i = byteLength;\n  var mul = 1;\n  var val = this[offset + --i];\n  while (i > 0 && (mul *= 0x100))\n    val += this[offset + --i] * mul;\n  mul *= 0x80;\n\n  if (val >= mul)\n    val -= Math.pow(2, 8 * byteLength);\n\n  return val;\n};\n\n\nBuffer.prototype.readInt8 = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 1, this.length);\n  var val = this[offset];\n  return !(val & 0x80) ? val : (0xff - val + 1) * -1;\n};\n\n\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 2, this.length);\n  var val = this[offset] | (this[offset + 1] << 8);\n  return (val & 0x8000) ? val | 0xFFFF0000 : val;\n};\n\n\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 2, this.length);\n  var val = this[offset + 1] | (this[offset] << 8);\n  return (val & 0x8000) ? val | 0xFFFF0000 : val;\n};\n\n\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 4, this.length);\n\n  return (this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16) |\n      (this[offset + 3] << 24);\n};\n\n\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 4, this.length);\n\n  return (this[offset] << 24) |\n      (this[offset + 1] << 16) |\n      (this[offset + 2] << 8) |\n      (this[offset + 3]);\n};\n\n\nBuffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 4, this.length);\n  return binding.readFloatLE(this, offset);\n};\n\n\nBuffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 4, this.length);\n  return binding.readFloatBE(this, offset);\n};\n\n\nBuffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 8, this.length);\n  return binding.readDoubleLE(this, offset);\n};\n\n\nBuffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 8, this.length);\n  return binding.readDoubleBE(this, offset);\n};\n\n\nfunction checkInt(buffer, value, offset, ext, max, min) {\n  if (value > max || value < min)\n    throw new TypeError('\"value\" argument is out of bounds');\n  if (offset + ext > buffer.length)\n    throw new RangeError('Index out of range');\n}\n\n\nBuffer.prototype.writeUIntLE = function(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var mul = 1;\n  var i = 0;\n  this[offset] = value;\n  while (++i < byteLength && (mul *= 0x100))\n    this[offset + i] = (value / mul) >>> 0;\n\n  return offset + byteLength;\n};\n\n\nBuffer.prototype.writeUIntBE = function(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  byteLength = byteLength >>> 0;\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  this[offset + i] = value;\n  while (--i >= 0 && (mul *= 0x100))\n    this[offset + i] = (value / mul) >>> 0;\n\n  return offset + byteLength;\n};\n\n\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 1, 0xff, 0);\n  this[offset] = value;\n  return offset + 1;\n};\n\n\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 2, 0xffff, 0);\n  this[offset] = value;\n  this[offset + 1] = (value >>> 8);\n  return offset + 2;\n};\n\n\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 2, 0xffff, 0);\n  this[offset] = (value >>> 8);\n  this[offset + 1] = value;\n  return offset + 2;\n};\n\n\nBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 4, 0xffffffff, 0);\n  this[offset + 3] = (value >>> 24);\n  this[offset + 2] = (value >>> 16);\n  this[offset + 1] = (value >>> 8);\n  this[offset] = value;\n  return offset + 4;\n};\n\n\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 4, 0xffffffff, 0);\n  this[offset] = (value >>> 24);\n  this[offset + 1] = (value >>> 16);\n  this[offset + 2] = (value >>> 8);\n  this[offset + 3] = value;\n  return offset + 4;\n};\n\n\nBuffer.prototype.writeIntLE = function(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) {\n    checkInt(this,\n             value,\n             offset,\n             byteLength,\n             Math.pow(2, 8 * byteLength - 1) - 1,\n             -Math.pow(2, 8 * byteLength - 1));\n  }\n\n  var i = 0;\n  var mul = 1;\n  var sub = 0;\n  this[offset] = value;\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0)\n      sub = 1;\n    this[offset + i] = ((value / mul) >> 0) - sub;\n  }\n\n  return offset + byteLength;\n};\n\n\nBuffer.prototype.writeIntBE = function(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert) {\n    checkInt(this,\n             value,\n             offset,\n             byteLength,\n             Math.pow(2, 8 * byteLength - 1) - 1,\n             -Math.pow(2, 8 * byteLength - 1));\n  }\n\n  var i = byteLength - 1;\n  var mul = 1;\n  var sub = 0;\n  this[offset + i] = value;\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0)\n      sub = 1;\n    this[offset + i] = ((value / mul) >> 0) - sub;\n  }\n\n  return offset + byteLength;\n};\n\n\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 1, 0x7f, -0x80);\n  this[offset] = value;\n  return offset + 1;\n};\n\n\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  this[offset] = value;\n  this[offset + 1] = (value >>> 8);\n  return offset + 2;\n};\n\n\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  this[offset] = (value >>> 8);\n  this[offset + 1] = value;\n  return offset + 2;\n};\n\n\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  this[offset] = value;\n  this[offset + 1] = (value >>> 8);\n  this[offset + 2] = (value >>> 16);\n  this[offset + 3] = (value >>> 24);\n  return offset + 4;\n};\n\n\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  this[offset] = (value >>> 24);\n  this[offset + 1] = (value >>> 16);\n  this[offset + 2] = (value >>> 8);\n  this[offset + 3] = value;\n  return offset + 4;\n};\n\n\nBuffer.prototype.writeFloatLE = function writeFloatLE(val, offset, noAssert) {\n  val = +val;\n  offset = offset >>> 0;\n  if (!noAssert)\n    binding.writeFloatLE(this, val, offset);\n  else\n    binding.writeFloatLE(this, val, offset, true);\n  return offset + 4;\n};\n\n\nBuffer.prototype.writeFloatBE = function writeFloatBE(val, offset, noAssert) {\n  val = +val;\n  offset = offset >>> 0;\n  if (!noAssert)\n    binding.writeFloatBE(this, val, offset);\n  else\n    binding.writeFloatBE(this, val, offset, true);\n  return offset + 4;\n};\n\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE(val, offset, noAssert) {\n  val = +val;\n  offset = offset >>> 0;\n  if (!noAssert)\n    binding.writeDoubleLE(this, val, offset);\n  else\n    binding.writeDoubleLE(this, val, offset, true);\n  return offset + 8;\n};\n\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE(val, offset, noAssert) {\n  val = +val;\n  offset = offset >>> 0;\n  if (!noAssert)\n    binding.writeDoubleBE(this, val, offset);\n  else\n    binding.writeDoubleBE(this, val, offset, true);\n  return offset + 8;\n};\n\nconst swap16n = binding.swap16;\nconst swap32n = binding.swap32;\nconst swap64n = binding.swap64;\n\nfunction swap(b, n, m) {\n  const i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\n\nBuffer.prototype.swap16 = function swap16() {\n  // For Buffer.length < 128, it's generally faster to\n  // do the swap in javascript. For larger buffers,\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 2 !== 0)\n    throw new RangeError('Buffer size must be a multiple of 16-bits');\n  if (len < 128) {\n    for (var i = 0; i < len; i += 2)\n      swap(this, i, i + 1);\n    return this;\n  }\n  return swap16n(this);\n};\n\n\nBuffer.prototype.swap32 = function swap32() {\n  // For Buffer.length < 192, it's generally faster to\n  // do the swap in javascript. For larger buffers,\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 4 !== 0)\n    throw new RangeError('Buffer size must be a multiple of 32-bits');\n  if (len < 192) {\n    for (var i = 0; i < len; i += 4) {\n      swap(this, i, i + 3);\n      swap(this, i + 1, i + 2);\n    }\n    return this;\n  }\n  return swap32n(this);\n};\n\n\nBuffer.prototype.swap64 = function swap64() {\n  // For Buffer.length < 192, it's generally faster to\n  // do the swap in javascript. For larger buffers,\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 8 !== 0)\n    throw new RangeError('Buffer size must be a multiple of 64-bits');\n  if (len < 192) {\n    for (var i = 0; i < len; i += 8) {\n      swap(this, i, i + 7);\n      swap(this, i + 1, i + 6);\n      swap(this, i + 2, i + 5);\n      swap(this, i + 3, i + 4);\n    }\n    return this;\n  }\n  return swap64n(this);\n};\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString;\n\n// Put this at the end because internal/buffer has a circular\n// dependency on Buffer.\nconst internalBuffer = require('internal/buffer');\nexports.transcode = internalBuffer.transcode;\ninternalBuffer.FastBuffer = FastBuffer;\n\n});"},
    {"fileId":13, "filename":"trace_mgr.js", "source":"(function (exports, require, module, __filename, __dirname) { 'use strict';\n\n//Disable trace handling inside trace handler to avoid recursion\n//Set to true to prevent action till loading is complete -- set to false at end\nvar reentrantDisable = true;\n\nvar process = require('process');\n\nvar lazyloadDone = false;\nvar path = undefined;\nvar fs = undefined;\n\n///////////////////////////////\n//Trace calls\n\n/*\n*Check and emit time travel trace\n* -- invoke remoteTraceManagerObj functions as needed.\n*@emitKind string matching one of the emitOption flags\n*@optInfo additional info we want to pass in (error code for emitOnExit)\n*@result 're-entrant' 'disabled', 'no-sample', 'fail', 'success'\n*/\nfunction emitTrace(emitKind, optInfo) {\n  var res = emitTrace_helper(emitKind, optInfo);\n  if (res.flag === 'success') {\n    //This is an intentional programatic breakpoint\n    // -- it is only triggerable in --replay-debug mode\n    debugger; /*TTD_DEBUG_BREAKPOINT*/ // eslint-disable-line no-debugger\n  }\n  res.action();\n}\nexports.emitTrace = emitTrace;\n\nfunction buildTraceResult(flagv, actionv) {\n  var realAction = actionv || function() { };\n  return { flag: flagv, action: realAction };\n}\n\nfunction emitTrace_helper(emitKind, optInfo) {\n  if (reentrantDisable) {\n    return buildTraceResult('re-entrant');\n  }\n\n  reentrantDisable = true;\n  try {\n    if (!global.enabledDiagnosticsTrace || !global.enabledDiagnosticsTrace()) {\n      return buildTraceResult('disabled');\n    }\n\n    if (!checkGlobalShouldEmit(emitKind, optInfo)) {\n      return buildTraceResult('no-sample');\n    }\n\n    if (!lazyloadDone) {\n      path = require('path');\n      fs = require('fs');\n\n      lazyloadDone = true;\n    }\n\n    //Process a synchronous write action for a unique trace bin\n    //  -- otherwise a async action on a multiple trace bin\n    var sampleRes = buildTraceResult('no-sample');\n    if (emitKind === 'emitOnExit' ||\n      emitKind === 'emitOnException' ||\n      emitKind === 'emitOnSigInt') {\n      sampleRes = emitSyncTraceKind(emitKind, optInfo);\n    } else {\n      sampleRes = emitAsyncTraceKind(emitKind);\n    }\n\n    if (sampleRes.flag === 'success') {\n      updateGlobalSampleStats(emitKind);\n    }\n    return sampleRes;\n\n  } catch (ex) {\n    process.stderr.write('Failed in emitTrace with: ' + ex);\n    return buildTraceResult('fail');\n  } finally {\n    reentrantDisable = false;\n  }\n}\n\n////\n//Helpers for trace calls\nfunction emitSyncTraceKind(emitKind, optInfo) {\n  //build up trace name\n  var traceName = emitKind;\n  if (emitKind === 'emitOnExit') {\n    traceName += ('_code-' + optInfo);\n  }\n\n  //invoke the trace writer and remote manager if needed\n  var resolvedPath = createTraceLogTarget(traceName);\n  if (!resolvedPath) {\n    return buildTraceResult('fail');\n  }\n\n  function action() {\n    try {\n      process.stderr.write(`    Write error trace to: ${resolvedPath}\\n`);\n      global.emitTTDLog(resolvedPath);\n\n      if (emitOptions.remoteTraceManagerObj &&\n        emitOptions.remoteTraceManagerObj.uploadTraceSync) {\n        emitOptions.remoteTraceManagerObj.uploadTraceSync(resolvedPath);\n      }\n    } catch (ex) {\n      process.stderr.write('Failed in emitTrace with: ' + ex);\n    }\n  }\n\n  return buildTraceResult('success', action);\n}\n\nfunction emitAsyncTraceKind(emitKind) {\n  //get trace stack and check if we want to emit\n  var stk = generateFuzzyStack(emitKind);\n  var entry = checkBinShouldEmit(stk);\n  if (!entry) {\n    return buildTraceResult('no-sample');\n  }\n\n  //build up trace name\n  var traceBucketName = `${emitKind}_${stk.fbin}_bucket-${entry.bucketId}`;\n  var traceDirName = `trace-${entry.traceCtr}`;\n  var traceName = path.join(traceBucketName, traceDirName);\n\n  //invoke the trace writer and remote manager if needed\n  var resolvedPath = createTraceLogTarget(traceName);\n  if (!resolvedPath) {\n    return buildTraceResult('fail');\n  }\n\n  function action() {\n    try {\n      process.stderr.write(`    Write error trace to: ${resolvedPath}\\n`);\n      global.emitTTDLog(resolvedPath);\n\n      if (emitOptions.remoteTraceManagerObj &&\n        emitOptions.remoteTraceManagerObj.uploadTraceAsync) {\n        emitOptions.remoteTraceManagerObj.uploadTraceAsync(resolvedPath);\n      }\n    } catch (ex) {\n      process.stderr.write('Failed in emitTrace with: ' + ex);\n    }\n  }\n\n  //update the bin stats as needed\n  updateEmitInfo(entry, resolvedPath);\n  return buildTraceResult('success', action);\n}\n\n//create a directory for emitting the trace (if possible) and return it\nfunction createTraceLogTarget(tracename) {\n  var traceRootDir = emitOptions.localTraceDirectory ||\n    path.dirname(process.mainModule.filename);\n\n  var resolvedTracePath =\n    path.resolve(traceRootDir, '_diagnosticTraces', tracename);\n\n  //ensure directory exists and is empty...\n  var ok = ensureTraceTarget(resolvedTracePath);\n  if (!ok) {\n    return undefined;\n  }\n\n  return resolvedTracePath;\n}\n\n//ensure directory exists and is empty...\nfunction ensureTraceTarget(pth) {\n  //I don't like this and don't want it to be happening so I am going to bail\n  if (!path.isAbsolute(pth)) {\n    return false;\n  }\n\n  var okdir = createTargetDirectory(pth);\n  if (!okdir) {\n    return false;\n  }\n\n  return deleteTargetDirectoryContents(pth);\n}\n\nfunction createTargetDirectory(pth) {\n  //see if it just exists and, if so, just return true\n  var accessok = fs.constants.R_OK | fs.constants.W_OK | fs.constants.X_OK;\n  try {\n    fs.accessSync(pth, accessok);\n    if (fs.statSync(pth).isDirectory()) {\n      return true;\n    }\n  } catch (ei) { }\n\n  //walk up the directory to see where the first valid part of the path is\n  var prefixPath = pth;\n  var suffixPaths = [];\n  var baseFound = false;\n  do {\n    //check for bad prefix\n    if (prefixPath === path.dirname(prefixPath)) {\n      process.stderr.write(`Failed prefix: ${pth} -> ${prefixPath}\\n`);\n      return false;\n    }\n\n    suffixPaths.push(path.basename(prefixPath)); //reverse order\n    prefixPath = path.dirname(prefixPath);\n\n    try {\n      fs.accessSync(prefixPath, accessok);\n      baseFound = fs.statSync(prefixPath).isDirectory();\n    } catch (ei) { }\n  } while (!baseFound);\n\n  //now extend the prefix with all the suffix parts\n  while (suffixPaths.length > 0) {\n    try {\n      prefixPath = path.resolve(prefixPath, suffixPaths.pop());\n      fs.mkdirSync(prefixPath);\n    } catch (ec) {\n      process.stderr.write(`Failed creating trace directory : ${ec}\\n`);\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction deleteTargetDirectoryContents(pth) {\n  try {\n    var items = fs.readdirSync(pth);\n    for (var i = 0; i < items.length; i++) {\n      var fpath = path.resolve(pth, items[i]);\n      var stats = fs.lstatSync(fpath);\n      if (stats.isFile()) {\n        fs.unlinkSync(fpath);\n      } else if (stats.isDirectory()) {\n        var recok = deleteTargetDirectoryContents(fpath);\n        if (!recok) {\n          return false;\n        }\n\n        fs.rmdirSync(fpath);\n      } else {\n        return false; //something strange in here.\n      }\n    }\n  } catch (ex) {\n    process.stderr.write(`Failed cleaning directory contents: ${ex}\\n`);\n    return false;\n  }\n\n  return true;\n}\n\n//after we take a sample update the sampling stats\nfunction updateGlobalSampleStats(eventKind) {\n  currentSampleRate[eventKind] *= emitOptions.backoffFactors[eventKind];\n\n  var updateTime = new Date();\n  emitMinTimeValue['emitOnLogWarn'] = new Date(updateTime);\n  emitMinTimeValue['emitOnLogError'] = new Date(updateTime);\n\n  if (eventKind === 'emitOnAssert') {\n    emitMinTimeValue['emitOnAssert'] = updateTime;\n  }\n}\n\n///////////////////////////////\n//Trace emit manager code\n\nvar emitOptions = {\n  emitOnExit: 'error', //emit a trace on exit -- off, error, all\n  emitOnException: true, //emit a trace on uncaught execption\n  emitOnSigInt: true, //emit a trace on sigint\n  emitOnLogWarn: true, //check for trace emit on console.warn\n  emitOnLogError: true, //check for trace emit on console.error\n  emitOnAssert: true, //check for trace emit on console.assert or assert\n\n  globalMinInterval: 500, //min interval between console/assert trace emits\n  globalBackoffCancelInterval: 5000, //time when we reset the backoff interval\n\n  //The probability that we sample on the first warn/error/assert encountered\n  initialRates: {\n    emitOnLogWarn: 0.25,\n    emitOnLogError: 0.25,\n    emitOnAssert: 1.0\n  },\n\n  //The baseline background probability that we sample traces\n  baselineRates: {\n    emitOnLogWarn: 0.25,\n    emitOnLogError: 0.25,\n    emitOnAssert: 1.0\n  },\n\n  //backoff factor to apply\n  backoffFactors: {\n    emitOnLogWarn: 0.25,\n    emitOnLogError: 0.5,\n    emitOnAssert: 0.5\n  },\n\n  binMaxSampled: 10, //Max number of traces to take per stack bin\n  binBackoffFactor: 0.5, //sample probability #preserved * binBackoffFactor\n\n  localTraceDirectory: undefined, //The root directory for storing traces\n  remoteTraceManagerObj: undefined //manager object for remote trace support\n};\n\nvar callStackEmitInfoMap = new Map();\nvar bucketCtr = 0;\n\nvar emitMinTimeValue = {\n  emitOnLogWarn: new Date(0),\n  emitOnLogError: new Date(0),\n  emitOnAssert: new Date(0)\n};\n\nvar currentSampleRate = {};\nfor (var srp in emitOptions.initialRates) {\n  currentSampleRate[srp] = emitOptions.initialRates[srp];\n}\n\n/*\n*Update emitOptions from the given options object\n*/\nfunction setOptions(optionsObj) {\n  for (var opt in optionsObj) {\n    //TODO: need more error checking on the validity of the option values\n    emitOptions[opt] = optionsObj[opt];\n  }\n\n  for (var srp in emitOptions.initialRates) {\n    currentSampleRate[srp] = emitOptions.initialRates[srp];\n  }\n}\nexports.setOptions = setOptions;\n\n/*\n*Do a preliminary check if the emitKind is even enabled and to do sampling.\n*@emitKind string matching one of the emitOption flags\n*@optInfo additional info we want to pass in (error code for emitOnExit)\n*@result true if we may want to sample false if we definitely do not\n*/\nfunction checkGlobalShouldEmit(emitKind, optInfo) {\n  //Check if the flag is enabled\n  if (emitKind === 'emitOnExit') {\n    if (emitOptions.emitOnExit === 'all') {\n      return true;\n    } else {\n      return (emitOptions.emitOnExit === 'error') && (optInfo !== 0);\n    }\n  } else if (emitKind === 'emitOnException' || emitKind === 'emitOnSigInt') {\n    return emitOptions[emitKind];\n  } else {\n    if (!emitOptions[emitKind]) {\n      return false;\n    }\n\n    var sampleInterval = new Date() - emitMinTimeValue[emitKind];\n\n    //Don't sample too often no matter what (or we can basically live lock)\n    if (sampleInterval < emitOptions.globalMinInterval) {\n      return false;\n    }\n\n    //Relax our global rate if it has been a while\n    if (sampleInterval >= emitOptions.globalBackoffCancelInterval) {\n      var currRate = currentSampleRate[emitKind];\n      var blRate = emitOptions.baselineRates[emitKind];\n      currentSampleRate[emitKind] = Math.max(currRate, blRate);\n    }\n\n    //Probabalistic check if we want to do sample new trace\n    return Math.random() < currentSampleRate[emitKind];\n  }\n}\n\n/*\n*Given a fuzzy stack see if we want to write a trace for the call\n*@fuzzyStack is the stack produced by getFuzzyCallStack\n*@result if we want to sample return the entry otherwise undefined\n*/\nfunction checkBinShouldEmit(fuzzyStack) {\n  var entry = resolveStackEntry(fuzzyStack);\n\n  //stop sampling after max sampled values -- e.g. we don't need 100 repros\n  if (entry.traceCtr > emitOptions.binMaxSampled) {\n    return undefined;\n  }\n\n  //check if we want to sample on this entry -- we don't need every hit on this\n  var sampleProb = Math.pow(emitOptions.binBackoffFactor, entry.traceCtr);\n  return (Math.random() < sampleProb) ? entry : undefined;\n}\n\n/*\n*Note that we sampled for this entry and update the info as appropriate\n*@sampleEntry the entry we did the sample on\n*@sampleName the sample we are adding\n*/\nfunction updateEmitInfo(sampleEntry, sampleName) {\n  sampleEntry.traceCtr++;\n  sampleEntry.samples.push(sampleName);\n}\n\n////\n//Helpers for emit manager code\nfunction resolveStackEntry(fuzzyStack) {\n  if (!callStackEmitInfoMap.has(fuzzyStack.hash)) {\n    callStackEmitInfoMap.set(fuzzyStack.hash, []);\n  }\n  var stackList = callStackEmitInfoMap.get(fuzzyStack.hash);\n\n  for (var i = 0; i < stackList.length; ++i) {\n    if (eqFuzzyStacks(fuzzyStack, stackList[i].stack)) {\n      return stackList[i];\n    }\n  }\n\n  stackList.push({\n    stack: fuzzyStack,\n    bucketId: bucketCtr++,\n    traceCtr: 0,\n    samples: []\n  });\n  return stackList[stackList.length - 1];\n}\n\n///////////////////////////////\n//Fuzzy stack code\n\n//Helper hashcode computation function (dbj2 variant)\nfunction djbHash(str, hash) {\n  for (var i = 0; i < str.length; i++) {\n    hash = (hash * 33) ^ str.charCodeAt(i);\n  }\n  return hash;\n}\n\n//helper is absolute path copied from path -- avoid neededing to require it\nfunction directIsAbsoluteW32(pth) {\n  const len = pth.length;\n  if (len === 0)\n    return false;\n\n  var code = pth.charCodeAt(0);\n  if (code === 47/*/*/ || code === 92/*\\*/) {\n    return true;\n  } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||\n    (code >= 97/*a*/ && code <= 122/*z*/)) {\n    // Possible device root\n\n    if (len > 2 && pth.charCodeAt(1) === 58/*:*/) {\n      code = pth.charCodeAt(2);\n      if (code === 47/*/*/ || code === 92/*\\*/)\n        return true;\n    }\n  }\n  return false;\n}\n\nfunction directIsAbsolutePosix(pth) {\n  return pth.length > 0 && pth.charCodeAt(0) === 47/*/*/;\n}\n\nvar directIsAbsolute = (process.platform === 'win32') ?\n  directIsAbsoluteW32 :\n  directIsAbsolutePosix;\n\n/*\n* Create and return a fuzzy stack match for the current call.\n*/\nfunction generateFuzzyStack(eventKind) {\n  //Create an array of the file/lines for user space code in the call stack\n  var errstk = new Error()\n    .stack\n    .split('\\n')\n    .slice(1)\n    .map(function(frame) {\n      return frame.substring(frame.indexOf('(') + 1, frame.lastIndexOf(')'));\n    })\n    .filter(function(frame) {\n      return directIsAbsolute(frame);\n    });\n\n  var lastframe = errstk[errstk.length - 1];\n  var fname = lastframe.substr(lastframe.lastIndexOf(path.sep) + 1)\n      .replace('.js:', '_line-')\n      .replace(':', '_column-');\n\n  //Identify which frames are recursive (appear multiple times in the stack)\n  var recFrames = new Map();\n  var hasRecFrames = false;\n  for (var i = 0; i < errstk.length; ++i) {\n    if (recFrames.has(errstk[i])) {\n      hasRecFrames = true;\n      recFrames.set(errstk[i], true);\n    } else {\n      recFrames.set(errstk[i], false);\n    }\n  }\n\n  if (hasRecFrames) {\n    //Compress any recursive frames\n    var cpos = 0;\n    var fpos = 0;\n    while (fpos < errstk.length) {\n      if (recFrames.get(errstk[fpos])) {\n        var recArray = [];\n        var spanpos = fpos;\n        var spanend = errstk.lastIndexOf(errstk[fpos]);\n        while (spanpos <= spanend) {\n          if (recArray.indexOf(errstk[spanpos]) === -1) {\n            recArray.push(errstk[spanpos]);\n          }\n\n          spanend = Math.max(spanend, errstk.lastIndexOf(errstk[spanpos]));\n          spanpos++;\n        }\n\n        errstk[cpos] = recArray.sort();\n        fpos = spanend + 1;\n      } else {\n        if (cpos !== fpos) {\n          errstk[cpos] = errstk[fpos];\n        }\n        fpos++;\n      }\n\n      cpos++;\n    }\n\n    errstk = errstk.slice(0, cpos);\n  }\n\n  var chash = 5381;\n  for (i = 0; i < errstk.length; ++i) {\n    if (Array.isArray(errstk[i])) {\n      for (var j = 0; j < errstk[i].length; ++j) {\n        chash = djbHash(errstk[i][j], chash);\n      }\n    } else {\n      chash = djbHash(errstk[i], chash);\n    }\n  }\n\n  return {\n    kind: eventKind,\n    fbin: fname,\n    hash: chash,\n    stack: errstk\n  };\n}\n\n/*\n* Check if 2 fuzzy stacks are equal.\n*/\nfunction eqFuzzyStacks(s1, s2) {\n  if (s1.hash !== s2.hash || s1.stack.length !== s2.stack.length) {\n    return false;\n  }\n\n  for (var i = 0; i < s1.stack.length; ++i) {\n    if (Array.isArray(s1.stack[i]) !== Array.isArray(s2.stack[i])) {\n      return false;\n    }\n\n    if (Array.isArray(s1.stack[i])) {\n      if (s1.stack[i].length !== s2.stack[i].length) {\n        return false;\n      }\n\n      for (var j = 0; j < s1.stack[i].length; ++j) {\n        if (s1.stack[j] !== s2.stack[j]) {\n          return false;\n        }\n      }\n    } else {\n      if (s1.stack[i] !== s2.stack[i]) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n///////////////////////////////\n//Bind handlers\n\nfunction onExitHandler(code) {\n  emitTrace('emitOnExit', code);\n}\nexports.onExitHandler = onExitHandler;\n\nfunction onUncaughtExceptionHandler() {\n  emitTrace('emitOnException');\n}\nexports.onUncaughtExceptionHandler = onUncaughtExceptionHandler;\n\nfunction onSigIntHandler(hasUserHandler) {\n  emitTrace('emitOnSigInt');\n\n  if (!hasUserHandler) {\n    //Really exit without triggering any other events\n    process.reallyExit(0);\n  }\n}\nexports.onSigIntHandler = onSigIntHandler;\n\nreentrantDisable = false;\n\n});"},
    {"fileId":14, "filename":"internal/process/next_tick.js", "source":"(function (exports, require, module, __filename, __dirname) { 'use strict';\n\n// This value is used to prevent the nextTickQueue from becoming too\n// large and cause the process to run out of memory. When this value\n// is reached the nextTimeQueue array will be shortend (see tickDone\n// for details).\nconst kMaxCallbacksPerLoop = 1e4;\n\nexports.setup = setupNextTick;\n// Will be overwritten when setupNextTick() is called.\nexports.nextTick = null;\n\nfunction setupNextTick() {\n  const async_wrap = process.binding('async_wrap');\n  const async_hooks = require('async_hooks');\n  const promises = require('internal/process/promises');\n  const errors = require('internal/errors');\n  const emitPendingUnhandledRejections = promises.setup(scheduleMicrotasks);\n  const initTriggerId = async_hooks.initTriggerId;\n  // Two arrays that share state between C++ and JS.\n  const { async_hook_fields, async_uid_fields } = async_wrap;\n  // Used to change the state of the async id stack.\n  const { pushAsyncIds, popAsyncIds } = async_wrap;\n  // The needed emit*() functions.\n  const { emitInit, emitBefore, emitAfter, emitDestroy } = async_hooks;\n  // Grab the constants necessary for working with internal arrays.\n  const { kInit, kBefore, kAfter, kDestroy, kAsyncUidCntr, kInitTriggerId } =\n      async_wrap.constants;\n  const { async_id_symbol, trigger_id_symbol } = async_wrap;\n  var nextTickQueue = [];\n  var microtasksScheduled = false;\n\n  // Used to run V8's micro task queue.\n  var _runMicrotasks = {};\n\n  // *Must* match Environment::TickInfo::Fields in src/env.h.\n  var kIndex = 0;\n  var kLength = 1;\n\n  process.nextTick = nextTick;\n  // Needs to be accessible from beyond this scope.\n  process._tickCallback = _tickCallback;\n  process._tickDomainCallback = _tickDomainCallback;\n\n  // Set the nextTick() function for internal usage.\n  exports.nextTick = internalNextTick;\n\n  // This tickInfo thing is used so that the C++ code in src/node.cc\n  // can have easy access to our nextTick state, and avoid unnecessary\n  // calls into JS land.\n  const tickInfo = process._setupNextTick(_tickCallback, _runMicrotasks);\n\n  _runMicrotasks = _runMicrotasks.runMicrotasks;\n\n  function tickDone() {\n    if (tickInfo[kLength] !== 0) {\n      if (tickInfo[kLength] <= tickInfo[kIndex]) {\n        nextTickQueue = [];\n        tickInfo[kLength] = 0;\n      } else {\n        nextTickQueue.splice(0, tickInfo[kIndex]);\n        tickInfo[kLength] = nextTickQueue.length;\n      }\n    }\n    tickInfo[kIndex] = 0;\n  }\n\n  function scheduleMicrotasks() {\n    if (microtasksScheduled)\n      return;\n\n    const tickObject =\n        new TickObject(runMicrotasksCallback, undefined, null);\n    // For the moment all microtasks come from the void until the PromiseHook\n    // API is implemented.\n    tickObject[async_id_symbol] = 0;\n    tickObject[trigger_id_symbol] = 0;\n    nextTickQueue.push(tickObject);\n\n    tickInfo[kLength]++;\n    microtasksScheduled = true;\n  }\n\n  function runMicrotasksCallback() {\n    microtasksScheduled = false;\n    _runMicrotasks();\n\n    if (tickInfo[kIndex] < tickInfo[kLength] ||\n        emitPendingUnhandledRejections())\n      scheduleMicrotasks();\n  }\n\n  function _combinedTickCallback(args, callback) {\n    if (args === undefined) {\n      callback();\n    } else {\n      switch (args.length) {\n        case 1:\n          callback(args[0]);\n          break;\n        case 2:\n          callback(args[0], args[1]);\n          break;\n        case 3:\n          callback(args[0], args[1], args[2]);\n          break;\n        default:\n          callback.apply(null, args);\n      }\n    }\n  }\n\n  // TODO(trevnorris): Using std::stack of Environment::AsyncHooks::ids_stack_\n  // is much slower here than was the Float64Array stack used in a previous\n  // implementation. Problem is the Float64Array stack was a bit brittle.\n  // Investigate how to harden that implementation and possibly reintroduce it.\n  function nextTickEmitBefore(asyncId, triggerId) {\n    if (async_hook_fields[kBefore] > 0)\n      emitBefore(asyncId, triggerId);\n    else\n      pushAsyncIds(asyncId, triggerId);\n  }\n\n  function nextTickEmitAfter(asyncId) {\n    if (async_hook_fields[kAfter] > 0)\n      emitAfter(asyncId);\n    else\n      popAsyncIds(asyncId);\n  }\n\n  // Run callbacks that have no domain.\n  // Using domains will cause this to be overridden.\n  function _tickCallback() {\n    do {\n      while (tickInfo[kIndex] < tickInfo[kLength]) {\n        const tock = nextTickQueue[tickInfo[kIndex]++];\n        const callback = tock.callback;\n        const args = tock.args;\n\n        // CHECK(Number.isSafeInteger(tock[async_id_symbol]))\n        // CHECK(tock[async_id_symbol] > 0)\n        // CHECK(Number.isSafeInteger(tock[trigger_id_symbol]))\n        // CHECK(tock[trigger_id_symbol] > 0)\n\n        nextTickEmitBefore(tock[async_id_symbol], tock[trigger_id_symbol]);\n        // emitDestroy() places the async_id_symbol into an asynchronous queue\n        // that calls the destroy callback in the future. It's called before\n        // calling tock.callback so destroy will be called even if the callback\n        // throws an exception that is handles by 'uncaughtException' or a\n        // domain.\n        // TODO(trevnorris): This is a bit of a hack. It relies on the fact\n        // that nextTick() doesn't allow the event loop to proceed, but if\n        // any async hooks are enabled during the callback's execution then\n        // this tock's after hook will be called, but not its destroy hook.\n        if (async_hook_fields[kDestroy] > 0)\n          emitDestroy(tock[async_id_symbol]);\n\n        // Using separate callback execution functions allows direct\n        // callback invocation with small numbers of arguments to avoid the\n        // performance hit associated with using `fn.apply()`\n        _combinedTickCallback(args, callback);\n\n        nextTickEmitAfter(tock[async_id_symbol]);\n\n        if (kMaxCallbacksPerLoop < tickInfo[kIndex])\n          tickDone();\n      }\n      tickDone();\n      _runMicrotasks();\n      emitPendingUnhandledRejections();\n    } while (tickInfo[kLength] !== 0);\n  }\n\n  function _tickDomainCallback() {\n    do {\n      while (tickInfo[kIndex] < tickInfo[kLength]) {\n        const tock = nextTickQueue[tickInfo[kIndex]++];\n        const callback = tock.callback;\n        const domain = tock.domain;\n        const args = tock.args;\n        if (domain)\n          domain.enter();\n\n        // CHECK(Number.isSafeInteger(tock[async_id_symbol]))\n        // CHECK(tock[async_id_symbol] > 0)\n        // CHECK(Number.isSafeInteger(tock[trigger_id_symbol]))\n        // CHECK(tock[trigger_id_symbol] > 0)\n\n        nextTickEmitBefore(tock[async_id_symbol], tock[trigger_id_symbol]);\n        // TODO(trevnorris): See comment in _tickCallback() as to why this\n        // isn't a good solution.\n        if (async_hook_fields[kDestroy] > 0)\n          emitDestroy(tock[async_id_symbol]);\n\n        // Using separate callback execution functions allows direct\n        // callback invocation with small numbers of arguments to avoid the\n        // performance hit associated with using `fn.apply()`\n        _combinedTickCallback(args, callback);\n\n        nextTickEmitAfter(tock[async_id_symbol]);\n\n        if (kMaxCallbacksPerLoop < tickInfo[kIndex])\n          tickDone();\n        if (domain)\n          domain.exit();\n      }\n      tickDone();\n      _runMicrotasks();\n      emitPendingUnhandledRejections();\n    } while (tickInfo[kLength] !== 0);\n  }\n\n  function TickObject(callback, args, domain) {\n    this.callback = callback;\n    this.domain = domain;\n    this.args = args;\n    this[async_id_symbol] = -1;\n    this[trigger_id_symbol] = -1;\n  }\n\n  function setupInit(tickObject, triggerId) {\n    tickObject[async_id_symbol] = ++async_uid_fields[kAsyncUidCntr];\n    tickObject[trigger_id_symbol] = triggerId || initTriggerId();\n    if (async_hook_fields[kInit] > 0) {\n      emitInit(tickObject[async_id_symbol],\n               'TickObject',\n               tickObject[trigger_id_symbol],\n               tickObject);\n    }\n  }\n\n  function nextTick(callback) {\n    if (typeof callback !== 'function')\n      throw new errors.TypeError('ERR_INVALID_CALLBACK');\n    // on the way out, don't bother. it won't get fired anyway.\n    if (process._exiting)\n      return;\n\n    var args;\n    if (arguments.length > 1) {\n      args = new Array(arguments.length - 1);\n      for (var i = 1; i < arguments.length; i++)\n        args[i - 1] = arguments[i];\n    }\n\n    var obj = new TickObject(callback, args, process.domain || null);\n    setupInit(obj, null);\n    nextTickQueue.push(obj);\n    tickInfo[kLength]++;\n  }\n\n  function internalNextTick(triggerId, callback) {\n    if (typeof callback !== 'function')\n      throw new TypeError('callback is not a function');\n    // CHECK(Number.isSafeInteger(triggerId) || triggerId === null)\n    // CHECK(triggerId > 0 || triggerId === null)\n\n    if (process._exiting)\n      return;\n\n    var args;\n    if (arguments.length > 2) {\n      args = new Array(arguments.length - 2);\n      for (var i = 2; i < arguments.length; i++)\n        args[i - 2] = arguments[i];\n    }\n\n    var obj = new TickObject(callback, args, process.domain || null);\n    setupInit(obj, triggerId);\n    // The call to initTriggerId() was skipped, so clear kInitTriggerId.\n    async_uid_fields[kInitTriggerId] = 0;\n    nextTickQueue.push(obj);\n    tickInfo[kLength]++;\n  }\n}\n\n});"},
    {"fileId":15, "filename":"_stream_transform.js", "source":"(function (exports, require, module, __filename, __dirname) { // Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nconst Duplex = require('_stream_duplex');\nconst util = require('util');\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(stream) {\n  this.afterTransform = function(er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n  this.writeencoding = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return stream.emit('error',\n                       new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined)\n    stream.push(data);\n\n  cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(this);\n\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function')\n      this._transform = options.transform;\n\n    if (typeof options.flush === 'function')\n      this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.once('prefinish', function() {\n    if (typeof this._flush === 'function')\n      this._flush(function(er, data) {\n        done(stream, er, data);\n      });\n    else\n      done(stream);\n  });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform ||\n        rs.needReadable ||\n        rs.length < rs.highWaterMark)\n      this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\n\nTransform.prototype._destroy = function(err, cb) {\n  Duplex.prototype._destroy.call(this, err, (err2) => {\n    cb(err2);\n    this.emit('close');\n  });\n};\n\n\nfunction done(stream, er, data) {\n  if (er)\n    return stream.emit('error', er);\n\n  if (data !== null && data !== undefined)\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length)\n    throw new Error('Calling transform done when ws.length != 0');\n\n  if (ts.transforming)\n    throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}\n\n});"},
    {"fileId":16, "filename":"internal/process.js", "source":"(function (exports, require, module, __filename, __dirname) { 'use strict';\n\nvar _lazyConstants = null;\n\nfunction lazyConstants() {\n  if (!_lazyConstants) {\n    _lazyConstants = process.binding('constants').os.signals;\n  }\n  return _lazyConstants;\n}\n\nconst assert = process.assert = function(x, msg) {\n  if (!x) throw new Error(msg || 'assertion error');\n};\n\n\n// Set up the process.cpuUsage() function.\nfunction setup_cpuUsage() {\n  // Get the native function, which will be replaced with a JS version.\n  const _cpuUsage = process.cpuUsage;\n\n  // Create the argument array that will be passed to the native function.\n  const cpuValues = new Float64Array(2);\n\n  // Replace the native function with the JS version that calls the native\n  // function.\n  process.cpuUsage = function cpuUsage(prevValue) {\n    // If a previous value was passed in, ensure it has the correct shape.\n    if (prevValue) {\n      if (!previousValueIsValid(prevValue.user)) {\n        throw new TypeError('value of user property of argument is invalid');\n      }\n\n      if (!previousValueIsValid(prevValue.system)) {\n        throw new TypeError('value of system property of argument is invalid');\n      }\n    }\n\n    // Call the native function to get the current values.\n    const errmsg = _cpuUsage(cpuValues);\n    if (errmsg) {\n      throw new Error('unable to obtain CPU usage: ' + errmsg);\n    }\n\n    // If a previous value was passed in, return diff of current from previous.\n    if (prevValue) return {\n      user: cpuValues[0] - prevValue.user,\n      system: cpuValues[1] - prevValue.system\n    };\n\n    // If no previous value passed in, return current value.\n    return {\n      user: cpuValues[0],\n      system: cpuValues[1]\n    };\n\n    // Ensure that a previously passed in value is valid. Currently, the native\n    // implementation always returns numbers <= Number.MAX_SAFE_INTEGER.\n    function previousValueIsValid(num) {\n      return Number.isFinite(num) &&\n          num <= Number.MAX_SAFE_INTEGER &&\n          num >= 0;\n    }\n  };\n}\n\n// The 3 entries filled in by the original process.hrtime contains\n// the upper/lower 32 bits of the second part of the value,\n// and the remaining nanoseconds of the value.\nfunction setup_hrtime() {\n  const _hrtime = process.hrtime;\n  const hrValues = new Uint32Array(3);\n\n  process.hrtime = function hrtime(time) {\n    _hrtime(hrValues);\n\n    if (time !== undefined) {\n      if (Array.isArray(time) && time.length === 2) {\n        const sec = (hrValues[0] * 0x100000000 + hrValues[1]) - time[0];\n        const nsec = hrValues[2] - time[1];\n        const needsBorrow = nsec < 0;\n        return [needsBorrow ? sec - 1 : sec, needsBorrow ? nsec + 1e9 : nsec];\n      }\n\n      throw new TypeError('process.hrtime() only accepts an Array tuple');\n    }\n\n    return [\n      hrValues[0] * 0x100000000 + hrValues[1],\n      hrValues[2]\n    ];\n  };\n}\n\nfunction setupMemoryUsage() {\n  const memoryUsage_ = process.memoryUsage;\n  const memValues = new Float64Array(4);\n\n  process.memoryUsage = function memoryUsage() {\n    memoryUsage_(memValues);\n    return {\n      rss: memValues[0],\n      heapTotal: memValues[1],\n      heapUsed: memValues[2],\n      external: memValues[3]\n    };\n  };\n}\n\nfunction setupConfig(_source) {\n  // NativeModule._source\n  // used for `process.config`, but not a real module\n  var config = _source.config;\n  delete _source.config;\n\n  // strip the gyp comment line at the beginning\n  config = config.split('\\n')\n      .slice(1)\n      .join('\\n')\n      .replace(/\"/g, '\\\\\"')\n      .replace(/'/g, '\"');\n\n  process.config = JSON.parse(config, function(key, value) {\n    if (value === 'true') return true;\n    if (value === 'false') return false;\n    return value;\n  });\n  const processConfig = process.binding('config');\n  if (typeof Intl !== 'undefined' && Intl.hasOwnProperty('v8BreakIterator')) {\n    const oldV8BreakIterator = Intl.v8BreakIterator;\n    const des = Object.getOwnPropertyDescriptor(Intl, 'v8BreakIterator');\n    des.value = require('internal/util').deprecate(function v8BreakIterator() {\n      if (processConfig.hasSmallICU && !processConfig.icuDataDir) {\n        // Intl.v8BreakIterator() would crash w/ fatal error, so throw instead.\n        throw new Error('v8BreakIterator: full ICU data not installed. ' +\n                        'See https://github.com/nodejs/node/wiki/Intl');\n      }\n      return Reflect.construct(oldV8BreakIterator, arguments);\n    }, 'Intl.v8BreakIterator is deprecated and will be removed soon.',\n                                                   'DEP0017');\n    Object.defineProperty(Intl, 'v8BreakIterator', des);\n  }\n}\n\n\nfunction setupKillAndExit() {\n\n  process.exit = function(code) {\n    if (code || code === 0)\n      process.exitCode = code;\n\n    if (!process._exiting) {\n      process._exiting = true;\n      process.emit('exit', process.exitCode || 0);\n    }\n\n    require('trace_mgr').onExitHandler(process.exitCode || 0); //ENABLE_TTD\n    process.reallyExit(process.exitCode || 0);\n  };\n\n  process.kill = function(pid, sig) {\n    var err;\n\n    // eslint-disable-next-line eqeqeq\n    if (pid != (pid | 0)) {\n      throw new TypeError('invalid pid');\n    }\n\n    // preserve null signal\n    if (0 === sig) {\n      err = process._kill(pid, 0);\n    } else {\n      sig = sig || 'SIGTERM';\n      if (lazyConstants()[sig]) {\n        err = process._kill(pid, lazyConstants()[sig]);\n      } else {\n        throw new Error(`Unknown signal: ${sig}`);\n      }\n    }\n\n    if (err) {\n      const errnoException = require('util')._errnoException;\n      throw errnoException(err, 'kill');\n    }\n\n    return true;\n  };\n}\n\nvar ttdSigIntHandler = undefined;\nfunction setupSignalHandlers() {\n  // Load events module in order to access prototype elements on process like\n  // process.addListener.\n  const signalWraps = {};\n\n  function isSignal(event) {\n    return typeof event === 'string' && lazyConstants()[event] !== undefined;\n  }\n\n  // Detect presence of a listener for the special signal types\n  process.on('newListener', function(type, listener) {\n    if (isSignal(type) &&\n        !signalWraps.hasOwnProperty(type)) {\n      const Signal = process.binding('signal_wrap').Signal;\n      const wrap = new Signal();\n\n      wrap.unref();\n\n      if (type === 'SIGINT' && global.enabledDiagnosticsTrace) {\n        //TODO: this is probably a little over complicated\n        //  -- should unify this and ttdSigIntHandler setup below\n        //  -- ttdSigIntHandler will emit event after it runs\n        wrap.onsignal = function() { }; //ENABLE_TTD\n      } else {\n        wrap.onsignal = function() { process.emit(type); };\n      }\n\n      const signum = lazyConstants()[type];\n      const err = wrap.start(signum);\n      if (err) {\n        wrap.close();\n        const errnoException = require('util')._errnoException;\n        throw errnoException(err, 'uv_signal_start');\n      }\n\n      signalWraps[type] = wrap;\n    }\n  });\n\n  process.on('removeListener', function(type, listener) {\n    if (signalWraps.hasOwnProperty(type) && this.listenerCount(type) === 0) {\n      signalWraps[type].close();\n      delete signalWraps[type];\n    }\n  });\n\n  //ENABLE_TTD\n  if (global.enabledDiagnosticsTrace) {\n    (function() {\n      var Signal = process.binding('signal_wrap').Signal;\n      var wrap = new Signal();\n\n      wrap.unref();\n\n      var handler = require('trace_mgr').onSigIntHandler;\n      wrap.onsignal = function() {\n        handler(signalWraps.hasOwnProperty('SIGINT'));\n        process.emit('SIGINT');\n      };\n\n      const signum = lazyConstants()['SIGINT'];\n      const err = wrap.start(signum);\n      if (err) {\n        wrap.close();\n        const errnoException = require('util')._errnoException;\n        throw errnoException(err, 'uv_signal_start');\n      }\n\n      if (!ttdSigIntHandler) {\n        ttdSigIntHandler = wrap;\n      }\n    })();\n  }\n}\n\n\nfunction setupChannel() {\n  // If we were spawned with env NODE_CHANNEL_FD then load that up and\n  // start parsing data from that stream.\n  if (process.env.NODE_CHANNEL_FD) {\n    const fd = parseInt(process.env.NODE_CHANNEL_FD, 10);\n    assert(fd >= 0);\n\n    // Make sure it's not accidentally inherited by child processes.\n    delete process.env.NODE_CHANNEL_FD;\n\n    const cp = require('child_process');\n\n    // Load tcp_wrap to avoid situation where we might immediately receive\n    // a message.\n    // FIXME is this really necessary?\n    process.binding('tcp_wrap');\n\n    cp._forkChild(fd);\n    assert(process.send);\n  }\n}\n\n\nfunction setupRawDebug() {\n  const format = require('util').format;\n  const rawDebug = process._rawDebug;\n  process._rawDebug = function() {\n    rawDebug(format.apply(null, arguments));\n  };\n}\n\nmodule.exports = {\n  setup_cpuUsage,\n  setup_hrtime,\n  setupMemoryUsage,\n  setupConfig,\n  setupKillAndExit,\n  setupSignalHandlers,\n  setupChannel,\n  setupRawDebug\n};\n\n});"},
    {"fileId":17, "filename":"events.js", "source":"(function (exports, require, module, __filename, __dirname) { // Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar domain;\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.usingDomains = false;\n\nEventEmitter.prototype.domain = undefined;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    // force global console to be compiled.\n    // see https://github.com/nodejs/node/issues/4467\n    console;\n    // check whether the input is a positive number (whose value is zero or\n    // greater and not a NaN).\n    if (typeof arg !== 'number' || arg < 0 || arg !== arg)\n      throw new TypeError('\"defaultMaxListeners\" must be a positive number');\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n  this.domain = null;\n  if (EventEmitter.usingDomains) {\n    // if there is an active domain, then attach to it.\n    domain = domain || require('domain');\n    if (domain.active && !(this instanceof domain.Domain)) {\n      this.domain = domain.active;\n    }\n  }\n\n  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || isNaN(n))\n    throw new TypeError('\"n\" argument must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\n// These standalone emit* functions are used to optimize calling of event\n// handlers for fast cases because emit() itself often has a variable number of\n// arguments and can be deoptimized because of that. These functions always have\n// the same number of arguments and thus do not get deoptimized, so the code\n// inside them can execute faster.\nfunction emitNone(handler, isFn, self) {\n  if (isFn)\n    handler.call(self);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self);\n  }\n}\nfunction emitOne(handler, isFn, self, arg1) {\n  if (isFn)\n    handler.call(self, arg1);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1);\n  }\n}\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\n  if (isFn)\n    handler.call(self, arg1, arg2);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2);\n  }\n}\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n  if (isFn)\n    handler.call(self, arg1, arg2, arg3);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2, arg3);\n  }\n}\n\nfunction emitMany(handler, isFn, self, args) {\n  if (isFn)\n    handler.apply(self, args);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].apply(self, args);\n  }\n}\n\nEventEmitter.prototype.emit = function emit(type) {\n  var er, handler, len, args, i, events, domain;\n  var needDomainExit = false;\n  var doError = (type === 'error');\n\n  events = this._events;\n  if (events)\n    doError = (doError && events.error == null);\n  else if (!doError)\n    return false;\n\n  domain = this.domain;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    if (arguments.length > 1)\n      er = arguments[1];\n    if (domain) {\n      if (!er)\n        er = new Error('Unhandled \"error\" event');\n      if (typeof er === 'object' && er !== null) {\n        er.domainEmitter = this;\n        er.domain = domain;\n        er.domainThrown = false;\n      }\n      domain.emit('error', er);\n    } else if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      // At least give some kind of context to the user\n      const err = new Error('Unhandled \"error\" event. (' + er + ')');\n      err.context = er;\n      throw err;\n    }\n    return false;\n  }\n\n  handler = events[type];\n\n  if (!handler)\n    return false;\n\n  if (domain && this !== process) {\n    domain.enter();\n    needDomainExit = true;\n  }\n\n  var isFn = typeof handler === 'function';\n  len = arguments.length;\n  switch (len) {\n    // fast cases\n    case 1:\n      emitNone(handler, isFn, this);\n      break;\n    case 2:\n      emitOne(handler, isFn, this, arguments[1]);\n      break;\n    case 3:\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n      break;\n    case 4:\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n      break;\n    // slower\n    default:\n      args = new Array(len - 1);\n      for (i = 1; i < len; i++)\n        args[i - 1] = arguments[i];\n      emitMany(handler, isFn, this, args);\n  }\n\n  if (needDomainExit)\n    domain.exit();\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n\n  events = target._events;\n  if (!events) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (!existing) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] :\n                                          [existing, listener];\n    } else {\n      // If we've already got an array, just append.\n      if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n    }\n\n    // Check for listener leak\n    if (!existing.warned) {\n      m = $getMaxListeners(target);\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true;\n        const w = new Error('Possible EventEmitter memory leak detected. ' +\n                            `${existing.length} ${String(type)} listeners ` +\n                            'added. Use emitter.setMaxListeners() to ' +\n                            'increase limit');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        process.emitWarning(w);\n      }\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  this.target.removeListener(this.type, this.wrapFn);\n  if (!this.fired) {\n    this.fired = true;\n    this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target, type, listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      list = events[type];\n      if (!list)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else\n          spliceOne(list, position);\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (!events.removeListener) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type]) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  var evlistener;\n  var ret;\n  var events = this._events;\n\n  if (!events)\n    ret = [];\n  else {\n    evlistener = events[type];\n    if (!evlistener)\n      ret = [];\n    else if (typeof evlistener === 'function')\n      ret = [evlistener.listener || evlistener];\n    else\n      ret = unwrapListeners(evlistener);\n  }\n\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  const events = this._events;\n\n  if (events) {\n    const evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n};\n\n// About 1.5x faster than the two-arg version of Array#splice().\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n    list[i] = list[k];\n  list.pop();\n}\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction unwrapListeners(arr) {\n  const ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n});"},
    {"fileId":18, "filename":"internal/module.js", "source":"(function (exports, require, module, __filename, __dirname) { 'use strict';\n\n// Invoke with makeRequireFunction(module) where |module| is the Module object\n// to use as the context for the require() function.\nfunction makeRequireFunction(mod) {\n  const Module = mod.constructor;\n\n  function require(path) {\n    try {\n      exports.requireDepth += 1;\n      return mod.require(path);\n    } finally {\n      exports.requireDepth -= 1;\n    }\n  }\n\n  function resolve(request) {\n    return Module._resolveFilename(request, mod);\n  }\n\n  require.resolve = resolve;\n\n  require.main = process.mainModule;\n\n  // Enable support to add extra extension types.\n  require.extensions = Module._extensions;\n\n  require.cache = Module._cache;\n\n  return require;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n * because the buffer-to-string conversion in `fs.readFileSync()`\n * translates it to FEFF, the UTF-16 BOM.\n */\nfunction stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\n/**\n * Find end of shebang line and slice it off\n */\nfunction stripShebang(content) {\n  // Remove shebang\n  var contLen = content.length;\n  if (contLen >= 2) {\n    if (content.charCodeAt(0) === 35/*#*/ &&\n        content.charCodeAt(1) === 33/*!*/) {\n      if (contLen === 2) {\n        // Exact match\n        content = '';\n      } else {\n        // Find end of shebang line and slice it off\n        var i = 2;\n        for (; i < contLen; ++i) {\n          var code = content.charCodeAt(i);\n          if (code === 10/*\\n*/ || code === 13/*\\r*/)\n            break;\n        }\n        if (i === contLen)\n          content = '';\n        else {\n          // Note that this actually includes the newline character(s) in the\n          // new output. This duplicates the behavior of the regular expression\n          // that was previously used to replace the shebang line\n          content = content.slice(i);\n        }\n      }\n    }\n  }\n  return content;\n}\n\nconst builtinLibs = [\n  'assert', 'async_hooks', 'buffer', 'child_process', 'cluster', 'crypto',\n  'dgram', 'dns', 'domain', 'events', 'fs', 'http', 'https', 'net', 'os',\n  'path', 'punycode', 'querystring', 'readline', 'repl', 'stream',\n  'string_decoder', 'tls', 'tty', 'url', 'util', 'v8', 'vm', 'zlib'\n];\n\nfunction addBuiltinLibsToObject(object) {\n  // Make built-in modules available directly (loaded lazily).\n  builtinLibs.forEach((name) => {\n    // Goals of this mechanism are:\n    // - Lazy loading of built-in modules\n    // - Having all built-in modules available as non-enumerable properties\n    // - Allowing the user to re-assign these variables as if there were no\n    //   pre-existing globals with the same name.\n\n    const setReal = (val) => {\n      // Deleting the property before re-assigning it disables the\n      // getter/setter mechanism.\n      delete object[name];\n      object[name] = val;\n    };\n\n    Object.defineProperty(object, name, {\n      get: () => {\n        const lib = require(name);\n\n        // Disable the current getter/setter and set up a new\n        // non-enumerable property.\n        delete object[name];\n        Object.defineProperty(object, name, {\n          get: () => lib,\n          set: setReal,\n          configurable: true,\n          enumerable: false\n        });\n\n        return lib;\n      },\n      set: setReal,\n      configurable: true,\n      enumerable: false\n    });\n  });\n}\n\nmodule.exports = exports = {\n  addBuiltinLibsToObject,\n  builtinLibs,\n  makeRequireFunction,\n  requireDepth: 0,\n  stripBOM,\n  stripShebang\n};\n\n});"},
    {"fileId":19, "filename":"internal/process/promises.js", "source":"(function (exports, require, module, __filename, __dirname) { 'use strict';\n\nconst promiseRejectEvent = process._promiseRejectEvent;\nconst hasBeenNotifiedProperty = new WeakMap();\nconst promiseToGuidProperty = new WeakMap();\nconst pendingUnhandledRejections = [];\nlet lastPromiseId = 1;\n\nexports.setup = setupPromises;\n\nfunction getAsynchronousRejectionWarningObject(uid) {\n  return new Error('Promise rejection was handled ' +\n                   `asynchronously (rejection id: ${uid})`);\n}\n\nfunction setupPromises(scheduleMicrotasks) {\n  process._setupPromises(function(event, promise, reason) {\n    if (event === promiseRejectEvent.unhandled)\n      unhandledRejection(promise, reason);\n    else if (event === promiseRejectEvent.handled)\n      rejectionHandled(promise);\n    else\n      require('assert').fail(null, null, 'unexpected PromiseRejectEvent');\n  });\n\n  function unhandledRejection(promise, reason) {\n    hasBeenNotifiedProperty.set(promise, false);\n    promiseToGuidProperty.set(promise, lastPromiseId++);\n    addPendingUnhandledRejection(promise, reason);\n  }\n\n  function rejectionHandled(promise) {\n    const hasBeenNotified = hasBeenNotifiedProperty.get(promise);\n    if (hasBeenNotified !== undefined) {\n      hasBeenNotifiedProperty.delete(promise);\n      const uid = promiseToGuidProperty.get(promise);\n      promiseToGuidProperty.delete(promise);\n      if (hasBeenNotified === true) {\n        let warning = null;\n        if (!process.listenerCount('rejectionHandled')) {\n          // Generate the warning object early to get a good stack trace.\n          warning = getAsynchronousRejectionWarningObject(uid);\n        }\n        process.nextTick(function() {\n          if (!process.emit('rejectionHandled', promise)) {\n            if (warning === null)\n              warning = getAsynchronousRejectionWarningObject(uid);\n            warning.name = 'PromiseRejectionHandledWarning';\n            warning.id = uid;\n            process.emitWarning(warning);\n          }\n        });\n      }\n\n    }\n  }\n\n  function emitWarning(uid, reason) {\n    const warning = new Error('Unhandled promise rejection ' +\n                              `(rejection id: ${uid}): ${String(reason)}`);\n    warning.name = 'UnhandledPromiseRejectionWarning';\n    warning.id = uid;\n    if (reason instanceof Error) {\n      warning.stack = reason.stack;\n    }\n    process.emitWarning(warning);\n    if (!deprecationWarned) {\n      deprecationWarned = true;\n      process.emitWarning(\n        'Unhandled promise rejections are deprecated. In the future, ' +\n        'promise rejections that are not handled will terminate the ' +\n        'Node.js process with a non-zero exit code.',\n        'DeprecationWarning', 'DEP0018');\n    }\n  }\n  var deprecationWarned = false;\n  function emitPendingUnhandledRejections() {\n    let hadListeners = false;\n    while (pendingUnhandledRejections.length > 0) {\n      const promise = pendingUnhandledRejections.shift();\n      const reason = pendingUnhandledRejections.shift();\n      if (hasBeenNotifiedProperty.get(promise) === false) {\n        hasBeenNotifiedProperty.set(promise, true);\n        const uid = promiseToGuidProperty.get(promise);\n        if (!process.emit('unhandledRejection', reason, promise)) {\n          emitWarning(uid, reason);\n        } else {\n          hadListeners = true;\n        }\n      }\n    }\n    return hadListeners;\n  }\n\n  function addPendingUnhandledRejection(promise, reason) {\n    pendingUnhandledRejections.push(promise, reason);\n    scheduleMicrotasks();\n  }\n\n  return emitPendingUnhandledRejections;\n}\n\n});"},
    {"fileId":20, "filename":"internal/errors.js", "source":"(function (exports, require, module, __filename, __dirname) { 'use strict';\n\n// The whole point behind this internal module is to allow Node.js to no\n// longer be forced to treat every error message change as a semver-major\n// change. The NodeError classes here all expose a `code` property whose\n// value statically and permanently identifies the error. While the error\n// message may change, the code should not.\n\nconst kCode = Symbol('code');\nconst messages = new Map();\n\nvar util;\nfunction lazyUtil() {\n  if (!util)\n    util = require('util');\n  return util;\n}\n\nvar assert;\nfunction lazyAssert() {\n  if (!assert)\n    assert = require('assert');\n  return assert;\n}\n\nfunction makeNodeError(Base) {\n  return class NodeError extends Base {\n    constructor(key, ...args) {\n      super(message(key, args));\n      this[kCode] = key;\n      Error.captureStackTrace(this, NodeError);\n    }\n\n    get name() {\n      return `${super.name} [${this[kCode]}]`;\n    }\n\n    get code() {\n      return this[kCode];\n    }\n  };\n}\n\nclass AssertionError extends Error {\n  constructor(options) {\n    if (typeof options !== 'object' || options === null) {\n      throw new exports.TypeError('ERR_INVALID_ARG_TYPE', 'options', 'object');\n    }\n    const util = lazyUtil();\n    const assert = lazyAssert();\n    const message = options.message ||\n                    `${util.inspect(options.actual).slice(0, 128)} ` +\n                    `${options.operator} ` +\n                    util.inspect(options.expected).slice(0, 128);\n\n    super(message);\n    this.generatedMessage = !options.message;\n    this.name = 'AssertionError [ERR_ASSERTION]';\n    this.code = 'ERR_ASSERTION';\n    this.actual = options.actual;\n    this.expected = options.expected;\n    this.operator = options.operator;\n    const stackStartFunction = options.stackStartFunction || assert.fail;\n    Error.captureStackTrace(this, stackStartFunction);\n  }\n}\n\nfunction message(key, args) {\n  const assert = lazyAssert();\n  assert.strictEqual(typeof key, 'string');\n  const util = lazyUtil();\n  const msg = messages.get(key);\n  assert(msg, `An invalid error message key was used: ${key}.`);\n  let fmt = util.format;\n  if (typeof msg === 'function') {\n    fmt = msg;\n  } else {\n    if (args === undefined || args.length === 0)\n      return msg;\n    args.unshift(msg);\n  }\n  return String(fmt.apply(null, args));\n}\n\n// Utility function for registering the error codes. Only used here. Exported\n// *only* to allow for testing.\nfunction E(sym, val) {\n  messages.set(sym, typeof val === 'function' ? val : String(val));\n}\n\nmodule.exports = exports = {\n  message,\n  Error: makeNodeError(Error),\n  TypeError: makeNodeError(TypeError),\n  RangeError: makeNodeError(RangeError),\n  AssertionError,\n  E // This is exported only to facilitate testing.\n};\n\n// To declare an error message, use the E(sym, val) function above. The sym\n// must be an upper case string. The val can be either a function or a string.\n// The return value of the function must be a string.\n// Examples:\n// E('EXAMPLE_KEY1', 'This is the error value');\n// E('EXAMPLE_KEY2', (a, b) => return `${a} ${b}`);\n//\n// Once an error code has been assigned, the code itself MUST NOT change and\n// any given error code must never be reused to identify a different error.\n//\n// Any error code added here should also be added to the documentation\n//\n// Note: Please try to keep these in alphabetical order\nE('ERR_ARG_NOT_ITERABLE', '%s must be iterable');\nE('ERR_ASSERTION', (msg) => msg);\nE('ERR_INVALID_ARG_TYPE', invalidArgType);\nE('ERR_INVALID_CALLBACK', 'callback must be a function');\nE('ERR_INVALID_FILE_URL_HOST', 'File URL host %s');\nE('ERR_INVALID_FILE_URL_PATH', 'File URL path %s');\nE('ERR_INVALID_HANDLE_TYPE', 'This handle type cannot be sent');\nE('ERR_INVALID_OPT_VALUE',\n  (name, value) => {\n    return `The value \"${String(value)}\" is invalid for option \"${name}\"`;\n  });\nE('ERR_INVALID_SYNC_FORK_INPUT',\n  (value) => {\n    return 'Asynchronous forks do not support Buffer, Uint8Array or string' +\n           `input: ${value}`;\n  });\nE('ERR_INVALID_THIS', 'Value of \"this\" must be of type %s');\nE('ERR_INVALID_TUPLE', '%s must be an iterable %s tuple');\nE('ERR_INVALID_URL', 'Invalid URL: %s');\nE('ERR_INVALID_URL_SCHEME',\n  (expected) => `The URL must be ${oneOf(expected, 'scheme')}`);\nE('ERR_IPC_CHANNEL_CLOSED', 'channel closed');\nE('ERR_IPC_DISCONNECTED', 'IPC channel is already disconnected');\nE('ERR_IPC_ONE_PIPE', 'Child process can have only one IPC pipe');\nE('ERR_IPC_SYNC_FORK', 'IPC cannot be used with synchronous forks');\nE('ERR_MISSING_ARGS', missingArgs);\nE('ERR_STDERR_CLOSE', 'process.stderr cannot be closed');\nE('ERR_STDOUT_CLOSE', 'process.stdout cannot be closed');\nE('ERR_UNKNOWN_BUILTIN_MODULE', (id) => `No such built-in module: ${id}`);\nE('ERR_UNKNOWN_SIGNAL', (signal) => `Unknown signal: ${signal}`);\nE('ERR_UNKNOWN_STDIN_TYPE', 'Unknown stdin file type');\nE('ERR_UNKNOWN_STREAM_TYPE', 'Unknown stream file type');\nE('ERR_SOCKET_ALREADY_BOUND', 'Socket is already bound');\nE('ERR_SOCKET_BAD_TYPE',\n  'Bad socket type specified. Valid types are: udp4, udp6');\nE('ERR_SOCKET_CANNOT_SEND', 'Unable to send data');\nE('ERR_SOCKET_BAD_PORT', 'Port should be > 0 and < 65536');\nE('ERR_SOCKET_DGRAM_NOT_RUNNING', 'Not running');\n// Add new errors from here...\n\nfunction invalidArgType(name, expected, actual) {\n  const assert = lazyAssert();\n  assert(name, 'name is required');\n  var msg = `The \"${name}\" argument must be ${oneOf(expected, 'type')}`;\n  if (arguments.length >= 3) {\n    msg += `. Received type ${actual !== null ? typeof actual : 'null'}`;\n  }\n  return msg;\n}\n\nfunction missingArgs(...args) {\n  assert(args.length > 0, 'At least one arg needs to be specified');\n  let msg = 'The ';\n  const len = args.length;\n  args = args.map((a) => `\"${a}\"`);\n  switch (len) {\n    case 1:\n      msg += `${args[0]} argument`;\n      break;\n    case 2:\n      msg += `${args[0]} and ${args[1]} arguments`;\n      break;\n    default:\n      msg += args.slice(0, len - 1).join(', ');\n      msg += `, and ${args[len - 1]} arguments`;\n      break;\n  }\n  return `${msg} must be specified`;\n}\n\nfunction oneOf(expected, thing) {\n  assert(expected, 'expected is required');\n  assert(typeof thing === 'string', 'thing is required');\n  if (Array.isArray(expected)) {\n    const len = expected.length;\n    assert(len > 0, 'At least one expected value needs to be specified');\n    expected = expected.map((i) => String(i));\n    if (len > 2) {\n      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` +\n             expected[len - 1];\n    } else if (len === 2) {\n      return `one of ${thing} ${expected[0]} or ${expected[1]}`;\n    } else {\n      return `of ${thing} ${expected[0]}`;\n    }\n  } else {\n    return `of ${thing} ${String(expected)}`;\n  }\n}\n\n});"},
    {"fileId":21, "filename":"bootstrap_node.js", "source":"// Hello, and welcome to hacking node.js!\n//\n// This file is invoked by node::LoadEnvironment in src/node.cc, and is\n// responsible for bootstrapping the node.js core. As special caution is given\n// to the performance of the startup process, many dependencies are invoked\n// lazily.\n\n'use strict';\n\n(function(process) {\n\n  function startup() {\n    const EventEmitter = NativeModule.require('events');\n    process._eventsCount = 0;\n\n    const origProcProto = Object.getPrototypeOf(process);\n    Object.setPrototypeOf(process, Object.create(EventEmitter.prototype, {\n      constructor: Object.getOwnPropertyDescriptor(origProcProto, 'constructor')\n    }));\n\n    EventEmitter.call(process);\n\n    setupProcessObject();\n\n    // do this good and early, since it handles errors.\n    setupProcessFatal();\n\n    setupProcessICUVersions();\n\n    setupGlobalVariables();\n    if (!process._noBrowserGlobals) {\n      setupGlobalTimeouts();\n      setupGlobalConsole();\n    }\n\n    const _process = NativeModule.require('internal/process');\n\n    _process.setup_hrtime();\n    _process.setup_cpuUsage();\n    _process.setupMemoryUsage();\n    _process.setupConfig(NativeModule._source);\n    NativeModule.require('internal/process/warning').setup();\n    NativeModule.require('internal/process/next_tick').setup();\n    NativeModule.require('internal/process/stdio').setup();\n    _process.setupKillAndExit();\n    _process.setupSignalHandlers();\n    if (global.__coverage__)\n      NativeModule.require('internal/process/write-coverage').setup();\n\n    NativeModule.require('trace_mgr'); //ENABLE_TTD;\n\n    // Do not initialize channel in debugger agent, it deletes env variable\n    // and the main thread won't see it.\n    if (process.argv[1] !== '--debug-agent')\n      _process.setupChannel();\n\n    _process.setupRawDebug();\n\n    // Ensure setURLConstructor() is called before the native\n    // URL::ToObject() method is used.\n    NativeModule.require('internal/url');\n\n    Object.defineProperty(process, 'argv0', {\n      enumerable: true,\n      configurable: false,\n      value: process.argv[0]\n    });\n    process.argv[0] = process.execPath;\n\n    // There are various modes that Node can run in. The most common two\n    // are running from a script and running the REPL - but there are a few\n    // others like the debugger or running --eval arguments. Here we decide\n    // which mode we run in.\n\n    if (NativeModule.exists('_third_party_main')) {\n      // To allow people to extend Node in different ways, this hook allows\n      // one to drop a file lib/_third_party_main.js into the build\n      // directory which will be executed instead of Node's normal loading.\n      process.nextTick(function() {\n        NativeModule.require('_third_party_main');\n      });\n\n    } else if (process.argv[1] === 'inspect' || process.argv[1] === 'debug') {\n      if (process.argv[1] === 'debug') {\n        process.emitWarning(\n          '`node debug` is deprecated. Please use `node inspect` instead.',\n          'DeprecationWarning', 'DEP0068');\n      }\n\n      // Start the debugger agent\n      process.nextTick(function() {\n        NativeModule.require('node-inspect/lib/_inspect').start();\n      });\n\n    } else if (process.argv[1] === '--remote_debugging_server') {\n      // Start the debugging server\n      NativeModule.require('internal/inspector/remote_debugging_server');\n\n    } else if (process.argv[1] === '--debug-agent') {\n      // Start the debugger agent\n      NativeModule.require('_debug_agent').start();\n\n    } else if (process.profProcess) {\n      NativeModule.require('internal/v8_prof_processor');\n\n    } else {\n      // There is user code to be run\n\n      // If this is a worker in cluster mode, start up the communication\n      // channel. This needs to be done before any user code gets executed\n      // (including preload modules).\n      if (process.argv[1] && process.env.NODE_UNIQUE_ID) {\n        const cluster = NativeModule.require('cluster');\n        cluster._setupWorker();\n\n        // Make sure it's not accidentally inherited by child processes.\n        delete process.env.NODE_UNIQUE_ID;\n      }\n\n      if (process._eval != null && !process._forceRepl) {\n        // User passed '-e' or '--eval' arguments to Node without '-i' or\n        // '--interactive'\n        preloadModules();\n\n        const internalModule = NativeModule.require('internal/module');\n        internalModule.addBuiltinLibsToObject(global);\n        evalScript('[eval]');\n      } else if (process.argv[1] && process.argv[1] !== '-') {\n        // make process.argv[1] into a full path\n        const path = NativeModule.require('path');\n        process.argv[1] = path.resolve(process.argv[1]);\n\n        const Module = NativeModule.require('module');\n\n        // check if user passed `-c` or `--check` arguments to Node.\n        if (process._syntax_check_only != null) {\n          const fs = NativeModule.require('fs');\n          // read the source\n          const filename = Module._resolveFilename(process.argv[1]);\n          var source = fs.readFileSync(filename, 'utf-8');\n          checkScriptSyntax(source, filename);\n          process.exit(0);\n        }\n\n        preloadModules();\n        Module.runMain();\n      } else {\n        preloadModules();\n        // If -i or --interactive were passed, or stdin is a TTY.\n        if (process._forceRepl || NativeModule.require('tty').isatty(0)) {\n          // REPL\n          const cliRepl = NativeModule.require('internal/repl');\n          cliRepl.createInternalRepl(process.env, function(err, repl) {\n            if (err) {\n              throw err;\n            }\n            repl.on('exit', function() {\n              if (repl._flushing) {\n                repl.pause();\n                return repl.once('flushHistory', function() {\n                  process.exit();\n                });\n              }\n              process.exit();\n            });\n          });\n\n          if (process._eval != null) {\n            // User passed '-e' or '--eval'\n            evalScript('[eval]');\n          }\n        } else {\n          // Read all of stdin - execute it.\n          process.stdin.setEncoding('utf8');\n\n          var code = '';\n          process.stdin.on('data', function(d) {\n            code += d;\n          });\n\n          process.stdin.on('end', function() {\n            if (process._syntax_check_only != null) {\n              checkScriptSyntax(code, '[stdin]');\n            } else {\n              process._eval = code;\n              evalScript('[stdin]');\n            }\n          });\n        }\n      }\n    }\n  }\n\n  function setupProcessObject() {\n    process._setupProcessObject(pushValueToArray);\n\n    function pushValueToArray() {\n      for (var i = 0; i < arguments.length; i++)\n        this.push(arguments[i]);\n    }\n  }\n\n  function setupGlobalVariables() {\n    Object.defineProperty(global, Symbol.toStringTag, {\n      value: 'global',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n    global.process = process;\n    const util = NativeModule.require('util');\n\n    function makeGetter(name) {\n      return util.deprecate(function() {\n        return this;\n      }, `'${name}' is deprecated, use 'global'`, 'DEP0016');\n    }\n\n    function makeSetter(name) {\n      return util.deprecate(function(value) {\n        Object.defineProperty(this, name, {\n          configurable: true,\n          writable: true,\n          enumerable: true,\n          value: value\n        });\n      }, `'${name}' is deprecated, use 'global'`, 'DEP0016');\n    }\n\n    Object.defineProperties(global, {\n      GLOBAL: {\n        configurable: true,\n        get: makeGetter('GLOBAL'),\n        set: makeSetter('GLOBAL')\n      },\n      root: {\n        configurable: true,\n        get: makeGetter('root'),\n        set: makeSetter('root')\n      }\n    });\n\n    global.Buffer = NativeModule.require('buffer').Buffer;\n    process.domain = null;\n    process._exiting = false;\n  }\n\n  function setupGlobalTimeouts() {\n    const timers = NativeModule.require('timers');\n    global.clearImmediate = timers.clearImmediate;\n    global.clearInterval = timers.clearInterval;\n    global.clearTimeout = timers.clearTimeout;\n    global.setImmediate = timers.setImmediate;\n    global.setInterval = timers.setInterval;\n    global.setTimeout = timers.setTimeout;\n  }\n\n  function setupGlobalConsole() {\n    const originalConsole = global.console;\n    let console;\n    Object.defineProperty(global, 'console', {\n      configurable: true,\n      enumerable: true,\n      get: function() {\n        if (!console) {\n          console = originalConsole === undefined ?\n              NativeModule.require('console') :\n              installInspectorConsole(originalConsole);\n        }\n        return console;\n      }\n    });\n  }\n\n  function installInspectorConsole(globalConsole) {\n    const wrappedConsole = NativeModule.require('console');\n    const inspector = process.binding('inspector');\n    const config = {};\n    for (const key of Object.keys(wrappedConsole)) {\n      if (!globalConsole.hasOwnProperty(key))\n        continue;\n      // If global console has the same method as inspector console,\n      // then wrap these two methods into one. Native wrapper will preserve\n      // the original stack.\n      wrappedConsole[key] = inspector.consoleCall.bind(wrappedConsole,\n                                                       globalConsole[key],\n                                                       wrappedConsole[key],\n                                                       config);\n    }\n    for (const key of Object.keys(globalConsole)) {\n      if (wrappedConsole.hasOwnProperty(key))\n        continue;\n      wrappedConsole[key] = globalConsole[key];\n    }\n    return wrappedConsole;\n  }\n\n  function setupProcessFatal() {\n    const async_wrap = process.binding('async_wrap');\n    // Arrays containing hook flags and ids for async_hook calls.\n    const { async_hook_fields, async_uid_fields } = async_wrap;\n    // Internal functions needed to manipulate the stack.\n    const { clearIdStack, popAsyncIds } = async_wrap;\n    const { kAfter, kCurrentAsyncId, kInitTriggerId } = async_wrap.constants;\n\n    process._fatalException = function(er) {\n      var caught;\n\n      // It's possible that kInitTriggerId was set for a constructor call that\n      // threw and was never cleared. So clear it now.\n      async_uid_fields[kInitTriggerId] = 0;\n\n      if (process.domain && process.domain._errorHandler)\n        caught = process.domain._errorHandler(er);\n\n      if (!caught)\n        caught = process.emit('uncaughtException', er);\n\n      //ENABLE_TTD\n      NativeModule.require('trace_mgr').onUncaughtExceptionHandler();\n\n      // If someone handled it, then great.  otherwise, die in C++ land\n      // since that means that we'll exit the process, emit the 'exit' event\n      if (!caught) {\n        try {\n          if (!process._exiting) {\n            process._exiting = true;\n            process.emit('exit', 1);\n          }\n        } catch (er) {\n          // nothing to be done about it at this point.\n        }\n\n      } else {\n        // If we handled an error, then make sure any ticks get processed\n        NativeModule.require('timers').setImmediate(process._tickCallback);\n\n        // Emit the after() hooks now that the exception has been handled.\n        if (async_hook_fields[kAfter] > 0) {\n          do {\n            NativeModule.require('async_hooks').emitAfter(\n                async_uid_fields[kCurrentAsyncId]);\n          // popAsyncIds() returns true if there are more ids on the stack.\n          } while (popAsyncIds(async_uid_fields[kCurrentAsyncId]));\n        // Or completely empty the id stack.\n        } else {\n          clearIdStack();\n        }\n      }\n\n      return caught;\n    };\n  }\n\n  function setupProcessICUVersions() {\n    const icu = process.binding('config').hasIntl ?\n      process.binding('icu') : undefined;\n    if (!icu) return;  // no Intl/ICU: nothing to add here.\n    // With no argument, getVersion() returns a comma separated list\n    // of possible types.\n    const versionTypes = icu.getVersion().split(',');\n\n    function makeGetter(name) {\n      return () => {\n        // With an argument, getVersion(type) returns\n        // the actual version string.\n        const version = icu.getVersion(name);\n        // Replace the current getter with a new property.\n        delete process.versions[name];\n        Object.defineProperty(process.versions, name, {\n          value: version,\n          writable: false,\n          enumerable: true\n        });\n        return version;\n      };\n    }\n\n    for (var n = 0; n < versionTypes.length; n++) {\n      var name = versionTypes[n];\n      Object.defineProperty(process.versions, name, {\n        configurable: true,\n        enumerable: true,\n        get: makeGetter(name)\n      });\n    }\n  }\n\n  function tryGetCwd(path) {\n    var threw = true;\n    var cwd;\n    try {\n      cwd = process.cwd();\n      threw = false;\n    } finally {\n      if (threw) {\n        // getcwd(3) can fail if the current working directory has been deleted.\n        // Fall back to the directory name of the (absolute) executable path.\n        // It's not really correct but what are the alternatives?\n        return path.dirname(process.execPath);\n      }\n    }\n    return cwd;\n  }\n\n  function evalScript(name) {\n    const Module = NativeModule.require('module');\n    const path = NativeModule.require('path');\n    const cwd = tryGetCwd(path);\n\n    const module = new Module(name);\n    module.filename = path.join(cwd, name);\n    module.paths = Module._nodeModulePaths(cwd);\n    const body = process._eval;\n    const script = `global.__filename = ${JSON.stringify(name)};\\n` +\n                   'global.exports = exports;\\n' +\n                   'global.module = module;\\n' +\n                   'global.__dirname = __dirname;\\n' +\n                   'global.require = require;\\n' +\n                   'return require(\"vm\").runInThisContext(' +\n                   `${JSON.stringify(body)}, { filename: ` +\n                   `${JSON.stringify(name)}, displayErrors: true });\\n`;\n    const result = module._compile(script, `${name}-wrapper`);\n    if (process._print_eval) console.log(result);\n    // Handle any nextTicks added in the first tick of the program.\n    process._tickCallback();\n  }\n\n  // Load preload modules\n  function preloadModules() {\n    if (process._preload_modules) {\n      NativeModule.require('module')._preloadModules(process._preload_modules);\n    }\n  }\n\n  function checkScriptSyntax(source, filename) {\n    const Module = NativeModule.require('module');\n    const vm = NativeModule.require('vm');\n    const internalModule = NativeModule.require('internal/module');\n\n    // remove Shebang\n    source = internalModule.stripShebang(source);\n    // remove BOM\n    source = internalModule.stripBOM(source);\n    // wrap it\n    source = Module.wrap(source);\n    // compile the script, this will throw if it fails\n    new vm.Script(source, {displayErrors: true, filename});\n  }\n\n  // Below you find a minimal module system, which is used to load the node\n  // core modules found in lib/*.js. All core modules are compiled into the\n  // node binary, so they can be loaded faster.\n\n  const ContextifyScript = process.binding('contextify').ContextifyScript;\n  function runInThisContext(code, options) {\n    const script = new ContextifyScript(code, options);\n    return script.runInThisContext();\n  }\n\n  function NativeModule(id) {\n    this.filename = `${id}.js`;\n    this.id = id;\n    this.exports = {};\n    this.loaded = false;\n    this.loading = false;\n  }\n\n  NativeModule._source = process.binding('natives');\n  NativeModule._cache = {};\n\n  NativeModule.require = function(id) {\n    if (id === 'native_module') {\n      return NativeModule;\n    }\n\n    const cached = NativeModule.getCached(id);\n    if (cached && (cached.loaded || cached.loading)) {\n      return cached.exports;\n    }\n\n    if (!NativeModule.exists(id)) {\n      // Model the error off the internal/errors.js model, but\n      // do not use that module given that it could actually be\n      // the one causing the error if there's a bug in Node.js\n      const err = new Error(`No such built-in module: ${id}`);\n      err.code = 'ERR_UNKNOWN_BUILTIN_MODULE';\n      err.name = 'Error [ERR_UNKNOWN_BUILTIN_MODULE]';\n      throw err;\n    }\n\n    process.moduleLoadList.push(`NativeModule ${id}`);\n\n    const nativeModule = new NativeModule(id);\n\n    nativeModule.cache();\n    nativeModule.compile();\n\n    return nativeModule.exports;\n  };\n\n  NativeModule.getCached = function(id) {\n    return NativeModule._cache[id];\n  };\n\n  NativeModule.exists = function(id) {\n    return NativeModule._source.hasOwnProperty(id);\n  };\n\n  const config = process.binding('config');\n\n  if (config.exposeInternals) {\n    NativeModule.nonInternalExists = NativeModule.exists;\n\n    NativeModule.isInternal = function(id) {\n      return false;\n    };\n  } else {\n    NativeModule.nonInternalExists = function(id) {\n      return NativeModule.exists(id) && !NativeModule.isInternal(id);\n    };\n\n    NativeModule.isInternal = function(id) {\n      return id.startsWith('internal/');\n    };\n  }\n\n\n  NativeModule.getSource = function(id) {\n    return NativeModule._source[id];\n  };\n\n  NativeModule.wrap = function(script) {\n    return NativeModule.wrapper[0] + script + NativeModule.wrapper[1];\n  };\n\n  NativeModule.wrapper = [\n    '(function (exports, require, module, __filename, __dirname) { ',\n    '\\n});'\n  ];\n\n  NativeModule.prototype.compile = function() {\n    var source = NativeModule.getSource(this.id);\n    source = NativeModule.wrap(source);\n\n    this.loading = true;\n\n    try {\n      const fn = runInThisContext(source, {\n        filename: this.filename,\n        lineOffset: 0,\n        displayErrors: true\n      });\n      fn(this.exports, NativeModule.require, this, this.filename);\n\n      this.loaded = true;\n    } finally {\n      this.loading = false;\n    }\n  };\n\n  NativeModule.prototype.cache = function() {\n    NativeModule._cache[this.id] = this;\n  };\n\n  startup();\n});\n"},
    {"fileId":22, "filename":"internal/util.js", "source":"(function (exports, require, module, __filename, __dirname) { 'use strict';\n\nconst errors = require('internal/errors');\nconst binding = process.binding('util');\nconst signals = process.binding('constants').os.signals;\n\nconst { createPromise, promiseResolve, promiseReject } = binding;\n\nconst kArrowMessagePrivateSymbolIndex = binding['arrow_message_private_symbol'];\nconst kDecoratedPrivateSymbolIndex = binding['decorated_private_symbol'];\nconst noCrypto = !process.versions.openssl;\n\nfunction isError(e) {\n  return objectToString(e) === '[object Error]' || e instanceof Error;\n}\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nfunction deprecate(fn, msg, code) {\n  // Allow for deprecating things in the process of starting up.\n  if (global.process === undefined) {\n    return function(...args) {\n      return deprecate(fn, msg).apply(this, args);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  if (code !== undefined && typeof code !== 'string')\n    throw new TypeError('`code` argument must be a string');\n\n  var warned = false;\n  function deprecated(...args) {\n    if (!warned) {\n      warned = true;\n      if (code !== undefined) {\n        process.emitWarning(msg, 'DeprecationWarning', code, deprecated);\n      } else {\n        process.emitWarning(msg, 'DeprecationWarning', deprecated);\n      }\n    }\n    if (new.target) {\n      return Reflect.construct(fn, args, new.target);\n    }\n    return fn.apply(this, args);\n  }\n\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n  Object.setPrototypeOf(deprecated, fn);\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype, as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nfunction decorateErrorStack(err) {\n  if (!(isError(err) && err.stack) ||\n      binding.getHiddenValue(err, kDecoratedPrivateSymbolIndex) === true)\n    return;\n\n  const arrow = binding.getHiddenValue(err, kArrowMessagePrivateSymbolIndex);\n\n  if (arrow) {\n    err.stack = arrow + err.stack;\n    binding.setHiddenValue(err, kDecoratedPrivateSymbolIndex, true);\n  }\n}\n\nfunction assertCrypto() {\n  if (noCrypto)\n    throw new Error('Node.js is not compiled with openssl crypto support');\n}\n\n// The loop should only run at most twice, retrying with lowercased enc\n// if there is no match in the first pass.\n// We use a loop instead of branching to retry with a helper\n// function in order to avoid the performance hit.\n// Return undefined if there is no match.\nfunction normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n}\n\nfunction filterDuplicateStrings(items, low) {\n  const map = new Map();\n  for (var i = 0; i < items.length; i++) {\n    const item = items[i];\n    const key = item.toLowerCase();\n    if (low) {\n      map.set(key, key);\n    } else {\n      map.set(key, item);\n    }\n  }\n  return Array.from(map.values()).sort();\n}\n\nfunction cachedResult(fn) {\n  var result;\n  return () => {\n    if (result === undefined)\n      result = fn();\n    return result.slice();\n  };\n}\n\n// Useful for Wrapping an ES6 Class with a constructor Function that\n// does not require the new keyword. For instance:\n//   class A { constructor(x) {this.x = x;}}\n//   const B = createClassWrapper(A);\n//   B() instanceof A // true\n//   B() instanceof B // true\nfunction createClassWrapper(type) {\n  function fn(...args) {\n    return Reflect.construct(type, args, new.target || type);\n  }\n  // Mask the wrapper function name and length values\n  Object.defineProperties(fn, {\n    name: {value: type.name},\n    length: {value: type.length}\n  });\n  Object.setPrototypeOf(fn, type);\n  fn.prototype = type.prototype;\n  return fn;\n}\n\nlet signalsToNamesMapping;\nfunction getSignalsToNamesMapping() {\n  if (signalsToNamesMapping !== undefined)\n    return signalsToNamesMapping;\n\n  signalsToNamesMapping = Object.create(null);\n  for (var key in signals) {\n    signalsToNamesMapping[signals[key]] = key;\n  }\n\n  return signalsToNamesMapping;\n}\n\nfunction convertToValidSignal(signal) {\n  if (typeof signal === 'number' && getSignalsToNamesMapping()[signal])\n    return signal;\n\n  if (typeof signal === 'string') {\n    const signalName = signals[signal.toUpperCase()];\n    if (signalName) return signalName;\n  }\n\n  throw new errors.Error('ERR_UNKNOWN_SIGNAL', signal);\n}\n\nfunction getConstructorOf(obj) {\n  while (obj) {\n    var descriptor = Object.getOwnPropertyDescriptor(obj, 'constructor');\n    if (descriptor !== undefined &&\n        typeof descriptor.value === 'function' &&\n        descriptor.value.name !== '') {\n      return descriptor.value;\n    }\n\n    obj = Object.getPrototypeOf(obj);\n  }\n\n  return null;\n}\n\nconst kCustomPromisifiedSymbol = Symbol('util.promisify.custom');\nconst kCustomPromisifyArgsSymbol = Symbol('customPromisifyArgs');\n\nfunction promisify(orig) {\n  if (typeof orig !== 'function') {\n    const errors = require('internal/errors');\n    throw new errors.TypeError('ERR_INVALID_ARG_TYPE', 'original', 'function');\n  }\n\n  if (orig[kCustomPromisifiedSymbol]) {\n    const fn = orig[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The [util.promisify.custom] property must be ' +\n                          'a function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  // Names to create an object from in case the callback receives multiple\n  // arguments, e.g. ['stdout', 'stderr'] for child_process.exec.\n  const argumentNames = orig[kCustomPromisifyArgsSymbol];\n\n  function fn(...args) {\n    const promise = createPromise();\n    try {\n      orig.call(this, ...args, (err, ...values) => {\n        if (err) {\n          promiseReject(promise, err);\n        } else if (argumentNames !== undefined && values.length > 1) {\n          const obj = {};\n          for (var i = 0; i < argumentNames.length; i++)\n            obj[argumentNames[i]] = values[i];\n          promiseResolve(promise, obj);\n        } else {\n          promiseResolve(promise, values[0]);\n        }\n      });\n    } catch (err) {\n      promiseReject(promise, err);\n    }\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(orig));\n\n  Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(fn, Object.getOwnPropertyDescriptors(orig));\n}\n\npromisify.custom = kCustomPromisifiedSymbol;\n\nmodule.exports = {\n  assertCrypto,\n  cachedResult,\n  convertToValidSignal,\n  createClassWrapper,\n  decorateErrorStack,\n  deprecate,\n  filterDuplicateStrings,\n  getConstructorOf,\n  isError,\n  normalizeEncoding,\n  objectToString,\n  promisify,\n\n  // Symbol used to customize promisify conversion\n  customPromisifyArgs: kCustomPromisifyArgsSymbol,\n\n  // Symbol used to provide a custom inspect function for an object as an\n  // alternative to using 'inspect'\n  customInspectSymbol: Symbol('util.inspect.custom'),\n\n  // Used by the buffer module to capture an internal reference to the\n  // default isEncoding implementation, just in case userland overrides it.\n  kIsEncodingSymbol: Symbol('node.isEncoding')\n};\n\n});"},
    {"fileId":23, "filename":"internal/buffer.js", "source":"(function (exports, require, module, __filename, __dirname) { 'use strict';\n\nif (!process.binding('config').hasIntl) {\n  return;\n}\n\nconst normalizeEncoding = require('internal/util').normalizeEncoding;\nconst Buffer = require('buffer').Buffer;\n\nconst icu = process.binding('icu');\nconst { isUint8Array } = process.binding('util');\n\n// Transcodes the Buffer from one encoding to another, returning a new\n// Buffer instance.\nfunction transcode(source, fromEncoding, toEncoding) {\n  if (!isUint8Array(source))\n    throw new TypeError('\"source\" argument must be a Buffer or Uint8Array');\n  if (source.length === 0) return Buffer.alloc(0);\n\n  fromEncoding = normalizeEncoding(fromEncoding) || fromEncoding;\n  toEncoding = normalizeEncoding(toEncoding) || toEncoding;\n  const result = icu.transcode(source, fromEncoding, toEncoding);\n  if (typeof result !== 'number')\n    return result;\n\n  const code = icu.icuErrName(result);\n  const err = new Error(`Unable to transcode Buffer [${code}]`);\n  err.code = code;\n  err.errno = result;\n  throw err;\n}\n\nmodule.exports = {\n  transcode\n};\n\n});"},
    {"fileId":24, "filename":"_stream_passthrough.js", "source":"(function (exports, require, module, __filename, __dirname) { // Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nconst Transform = require('_stream_transform');\nconst util = require('util');\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough))\n    return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n});"},
    {"fileId":25, "filename":"internal/streams/BufferList.js", "source":"(function (exports, require, module, __filename, __dirname) { 'use strict';\n\nconst Buffer = require('buffer').Buffer;\n\nmodule.exports = class BufferList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  push(v) {\n    const entry = { data: v, next: null };\n    if (this.length > 0)\n      this.tail.next = entry;\n    else\n      this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  }\n\n  unshift(v) {\n    const entry = { data: v, next: this.head };\n    if (this.length === 0)\n      this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  }\n\n  shift() {\n    if (this.length === 0)\n      return;\n    const ret = this.head.data;\n    if (this.length === 1)\n      this.head = this.tail = null;\n    else\n      this.head = this.head.next;\n    --this.length;\n    return ret;\n  }\n\n  clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  }\n\n  join(s) {\n    if (this.length === 0)\n      return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next)\n      ret += s + p.data;\n    return ret;\n  }\n\n  concat(n) {\n    if (this.length === 0)\n      return Buffer.alloc(0);\n    if (this.length === 1)\n      return this.head.data;\n    const ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      p.data.copy(ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  }\n};\n\n});"},
    {"fileId":26, "filename":"timers.js", "source":"(function (exports, require, module, __filename, __dirname) { // Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst async_wrap = process.binding('async_wrap');\nconst TimerWrap = process.binding('timer_wrap').Timer;\nconst L = require('internal/linkedlist');\nconst internalUtil = require('internal/util');\nconst { createPromise, promiseResolve } = process.binding('util');\nconst async_hooks = require('async_hooks');\nconst assert = require('assert');\nconst util = require('util');\nconst debug = util.debuglog('timer');\nconst kOnTimeout = TimerWrap.kOnTimeout | 0;\nconst initTriggerId = async_hooks.initTriggerId;\n// Two arrays that share state between C++ and JS.\nconst { async_hook_fields, async_uid_fields } = async_wrap;\n// Used to change the state of the async id stack.\nconst { pushAsyncIds, popAsyncIds } = async_wrap;\n// The needed emit*() functions.\nconst { emitInit, emitBefore, emitAfter, emitDestroy } = async_hooks;\n// Grab the constants necessary for working with internal arrays.\nconst { kInit, kBefore, kAfter, kDestroy, kAsyncUidCntr } =\n    async_wrap.constants;\n// Symbols for storing async id state.\nconst async_id_symbol = Symbol('asyncId');\nconst trigger_id_symbol = Symbol('triggerId');\n\n// Timeout values > TIMEOUT_MAX are set to 1.\nconst TIMEOUT_MAX = 2147483647; // 2^31-1\n\n\n// HOW and WHY the timers implementation works the way it does.\n//\n// Timers are crucial to Node.js. Internally, any TCP I/O connection creates a\n// timer so that we can time out of connections. Additionally, many user\n// libraries and applications also use timers. As such there may be a\n// significantly large amount of timeouts scheduled at any given time.\n// Therefore, it is very important that the timers implementation is performant\n// and efficient.\n//\n// Note: It is suggested you first read though the lib/internal/linkedlist.js\n// linked list implementation, since timers depend on it extensively. It can be\n// somewhat counter-intuitive at first, as it is not actually a class. Instead,\n// it is a set of helpers that operate on an existing object.\n//\n// In order to be as performant as possible, the architecture and data\n// structures are designed so that they are optimized to handle the following\n// use cases as efficiently as possible:\n\n// - Adding a new timer. (insert)\n// - Removing an existing timer. (remove)\n// - Handling a timer timing out. (timeout)\n//\n// Whenever possible, the implementation tries to make the complexity of these\n// operations as close to constant-time as possible.\n// (So that performance is not impacted by the number of scheduled timers.)\n//\n// Object maps are kept which contain linked lists keyed by their duration in\n// milliseconds.\n// The linked lists within also have some meta-properties, one of which is a\n// TimerWrap C++ handle, which makes the call after the duration to process the\n// list it is attached to.\n//\n//\n// \u4552\u0552\u0552\u0552\u0552 > Object Map\n// \u1552\n// \u0652\u0552\u0552\n// \u1552 refedLists: { '40': { }, '320': { etc } } (keys of millisecond duration)\n// \uA552\u0552\u0552          \uC052\u0052\u0052\u0052\u0052\u0052\u0052\u0052\u0052\u0052\u8152\n//              \u2052\n// \u4552\u0552\u0552          \u2052\n// \u1552 TimersList { _idleNext: { }, _idlePrev: (self), _timer: (TimerWrap) }\n// \u1552         \uC052\u0052\u0052\u0052\u0052\u0052\u0052\u0052\u0052\u0052\u0052\u0052\u0052\u0052\u0052\u0052\u0052\u8152\n// \u1552    \u4552\u0552\u0552  \u2052                              ^\n// \u1552    \u1552    { _idleNext: { },  _idlePrev: { }, _onTimeout: (callback) }\n// \u1552    \u1552      \uC052\u0052\u0052\u0052\u0052\u0052\u0052\u0052\u0052\u0052\u0052\u0052\u8152\n// \u1552    \u1552      \u2052                                  ^\n// \u1552    \u1552      { _idleNext: { etc },  _idlePrev: { }, _onTimeout: (callback) }\n// \u0652\u0552\u0552  \u0652\u0552\u0552\n// \u1552    \u1552\n// \u1552    \uA552\u0552\u0552\u0552\u0552 >  Actual JavaScript timeouts\n// \u1552\n// \uA552\u0552\u0552\u0552\u0552 > Linked List\n//\n//\n// With this, virtually constant-time insertion (append), removal, and timeout\n// is possible in the JavaScript layer. Any one list of timers is able to be\n// sorted by just appending to it because all timers within share the same\n// duration. Therefore, any timer added later will always have been scheduled to\n// timeout later, thus only needing to be appended.\n// Removal from an object-property linked list is also virtually constant-time\n// as can be seen in the lib/internal/linkedlist.js implementation.\n// Timeouts only need to process any timers due to currently timeout, which will\n// always be at the beginning of the list for reasons stated above. Any timers\n// after the first one encountered that does not yet need to timeout will also\n// always be due to timeout at a later time.\n//\n// Less-than constant time operations are thus contained in two places:\n// TimerWrap's backing libuv timers implementation (a performant heap-based\n// queue), and the object map lookup of a specific list by the duration of\n// timers within (or creation of a new list).\n// However, these operations combined have shown to be trivial in comparison to\n// other alternative timers architectures.\n\n\n// Object maps containing linked lists of timers, keyed and sorted by their\n// duration in milliseconds.\n//\n// The difference between these two objects is that the former contains timers\n// that will keep the process open if they are the only thing left, while the\n// latter will not.\n//\n// - key = time in milliseconds\n// - value = linked list\nconst refedLists = Object.create(null);\nconst unrefedLists = Object.create(null);\n\n\n// Schedule or re-schedule a timer.\n// The item must have been enroll()'d first.\nconst active = exports.active = function(item) {\n  insert(item, false);\n};\n\n// Internal APIs that need timeouts should use `_unrefActive()` instead of\n// `active()` so that they do not unnecessarily keep the process open.\nexports._unrefActive = function(item) {\n  insert(item, true);\n};\n\n\nfunction timerEmitBefore(asyncId, triggerId) {\n  if (async_hook_fields[kBefore] > 0)\n    emitBefore(asyncId, triggerId);\n  else\n    pushAsyncIds(asyncId, triggerId);\n}\n\n\nfunction timerEmitAfter(asyncId) {\n  if (async_hook_fields[kAfter] > 0)\n    emitAfter(asyncId);\n  else\n    popAsyncIds(asyncId);\n}\n\n\n// The underlying logic for scheduling or re-scheduling a timer.\n//\n// Appends a timer onto the end of an existing timers list, or creates a new\n// TimerWrap backed list if one does not already exist for the specified timeout\n// duration.\nfunction insert(item, unrefed) {\n  const msecs = item._idleTimeout;\n  if (msecs < 0 || msecs === undefined) return;\n\n  item._idleStart = TimerWrap.now();\n\n  const lists = unrefed === true ? unrefedLists : refedLists;\n\n  // Use an existing list if there is one, otherwise we need to make a new one.\n  var list = lists[msecs];\n  if (!list) {\n    debug('no %d list was found in insert, creating a new one', msecs);\n    lists[msecs] = list = createTimersList(msecs, unrefed);\n  }\n\n  if (!item[async_id_symbol] || item._destroyed) {\n    item._destroyed = false;\n    item[async_id_symbol] = ++async_uid_fields[kAsyncUidCntr];\n    item[trigger_id_symbol] = initTriggerId();\n    if (async_hook_fields[kInit] > 0)\n      emitInit(item[async_id_symbol], 'Timeout', item[trigger_id_symbol], item);\n  }\n\n  L.append(list, item);\n  assert(!L.isEmpty(list)); // list is not empty\n}\n\nfunction createTimersList(msecs, unrefed) {\n  // Make a new linked list of timers, and create a TimerWrap to schedule\n  // processing for the list.\n  const list = new TimersList(msecs, unrefed);\n  L.init(list);\n  list._timer._list = list;\n\n  if (unrefed === true) list._timer.unref();\n  list._timer.start(msecs);\n\n  list._timer[kOnTimeout] = listOnTimeout;\n\n  return list;\n}\n\nfunction TimersList(msecs, unrefed) {\n  this._idleNext = null; // Create the list with the linkedlist properties to\n  this._idlePrev = null; // prevent any unnecessary hidden class changes.\n  this._timer = new TimerWrap();\n  this._unrefed = unrefed;\n  this.msecs = msecs;\n  this.nextTick = false;\n}\n\nfunction listOnTimeout() {\n  var list = this._list;\n  var msecs = list.msecs;\n\n  if (list.nextTick) {\n    list.nextTick = false;\n    process.nextTick(listOnTimeoutNT, list);\n    return;\n  }\n\n  debug('timeout callback %d', msecs);\n\n  var now = TimerWrap.now();\n  debug('now: %d', now);\n\n  var diff, timer;\n  while (timer = L.peek(list)) {\n    diff = now - timer._idleStart;\n\n    // Check if this loop iteration is too early for the next timer.\n    // This happens if there are more timers scheduled for later in the list.\n    if (diff < msecs) {\n      var timeRemaining = msecs - (TimerWrap.now() - timer._idleStart);\n      if (timeRemaining < 0) {\n        timeRemaining = 0;\n      }\n      this.start(timeRemaining);\n      debug('%d list wait because diff is %d', msecs, diff);\n      return;\n    }\n\n    // The actual logic for when a timeout happens.\n\n    L.remove(timer);\n    assert(timer !== L.peek(list));\n\n    if (!timer._onTimeout) {\n      if (async_hook_fields[kDestroy] > 0 && !timer._destroyed &&\n            typeof timer[async_id_symbol] === 'number') {\n        emitDestroy(timer[async_id_symbol]);\n        timer._destroyed = true;\n      }\n      continue;\n    }\n\n    var domain = timer.domain;\n    if (domain) {\n\n      // If the timer callback throws and the\n      // domain or uncaughtException handler ignore the exception,\n      // other timers that expire on this tick should still run.\n      //\n      // https://github.com/nodejs/node-v0.x-archive/issues/2631\n      if (domain._disposed)\n        continue;\n\n      domain.enter();\n    }\n\n    tryOnTimeout(timer, list);\n\n    if (domain)\n      domain.exit();\n  }\n\n  // If `L.peek(list)` returned nothing, the list was either empty or we have\n  // called all of the timer timeouts.\n  // As such, we can remove the list and clean up the TimerWrap C++ handle.\n  debug('%d list empty', msecs);\n  assert(L.isEmpty(list));\n\n  // Either refedLists[msecs] or unrefedLists[msecs] may have been removed and\n  // recreated since the reference to `list` was created. Make sure they're\n  // the same instance of the list before destroying.\n  if (list._unrefed === true && list === unrefedLists[msecs]) {\n    delete unrefedLists[msecs];\n  } else if (list === refedLists[msecs]) {\n    delete refedLists[msecs];\n  }\n\n  // Do not close the underlying handle if its ownership has changed\n  // (e.g it was unrefed in its callback).\n  if (this.owner)\n    return;\n\n  this.close();\n}\n\n\n// An optimization so that the try/finally only de-optimizes (since at least v8\n// 4.7) what is in this smaller function.\nfunction tryOnTimeout(timer, list) {\n  timer._called = true;\n  const timerAsyncId = (typeof timer[async_id_symbol] === 'number') ?\n      timer[async_id_symbol] : null;\n  var threw = true;\n  if (timerAsyncId !== null)\n    timerEmitBefore(timerAsyncId, timer[trigger_id_symbol]);\n  try {\n    ontimeout(timer);\n    threw = false;\n  } finally {\n    if (timerAsyncId !== null) {\n      if (!threw)\n        timerEmitAfter(timerAsyncId);\n      if (!timer._repeat && async_hook_fields[kDestroy] > 0 &&\n          !timer._destroyed) {\n        emitDestroy(timerAsyncId);\n        timer._destroyed = true;\n      }\n    }\n\n    if (!threw) return;\n\n    // Postpone all later list events to next tick. We need to do this\n    // so that the events are called in the order they were created.\n    const lists = list._unrefed === true ? unrefedLists : refedLists;\n    for (var key in lists) {\n      if (key > list.msecs) {\n        lists[key].nextTick = true;\n      }\n    }\n    // We need to continue processing after domain error handling\n    // is complete, but not by using whatever domain was left over\n    // when the timeout threw its exception.\n    const domain = process.domain;\n    process.domain = null;\n    // If we threw, we need to process the rest of the list in nextTick.\n    process.nextTick(listOnTimeoutNT, list);\n    process.domain = domain;\n  }\n}\n\n\nfunction listOnTimeoutNT(list) {\n  list._timer[kOnTimeout]();\n}\n\n\n// A convenience function for re-using TimerWrap handles more easily.\n//\n// This mostly exists to fix https://github.com/nodejs/node/issues/1264.\n// Handles in libuv take at least one `uv_run` to be registered as unreferenced.\n// Re-using an existing handle allows us to skip that, so that a second `uv_run`\n// will return no active handles, even when running `setTimeout(fn).unref()`.\nfunction reuse(item) {\n  L.remove(item);\n\n  var list = refedLists[item._idleTimeout];\n  // if empty - reuse the watcher\n  if (list && L.isEmpty(list)) {\n    debug('reuse hit');\n    list._timer.stop();\n    delete refedLists[item._idleTimeout];\n    return list._timer;\n  }\n\n  return null;\n}\n\n\n// Remove a timer. Cancels the timeout and resets the relevant timer properties.\nconst unenroll = exports.unenroll = function(item) {\n  // Fewer checks may be possible, but these cover everything.\n  if (async_hook_fields[kDestroy] > 0 &&\n      item &&\n      typeof item[async_id_symbol] === 'number' &&\n      !item._destroyed) {\n    emitDestroy(item[async_id_symbol]);\n    item._destroyed = true;\n  }\n\n  var handle = reuse(item);\n  if (handle) {\n    debug('unenroll: list empty');\n    handle.close();\n  }\n  // if active is called later, then we want to make sure not to insert again\n  item._idleTimeout = -1;\n};\n\n\n// Make a regular object able to act as a timer by setting some properties.\n// This function does not start the timer, see `active()`.\n// Using existing objects as timers slightly reduces object overhead.\nexports.enroll = function(item, msecs) {\n  if (typeof msecs !== 'number') {\n    throw new TypeError('\"msecs\" argument must be a number');\n  }\n\n  if (msecs < 0 || !isFinite(msecs)) {\n    throw new RangeError('\"msecs\" argument must be ' +\n                         'a non-negative finite number');\n  }\n\n  // if this item was already in a list somewhere\n  // then we should unenroll it from that\n  if (item._idleNext) unenroll(item);\n\n  // Ensure that msecs fits into signed int32\n  if (msecs > TIMEOUT_MAX) {\n    msecs = TIMEOUT_MAX;\n  }\n\n  item._idleTimeout = msecs;\n  L.init(item);\n};\n\n\n/*\n * DOM-style timers\n */\n\n\nfunction setTimeout(callback, after, arg1, arg2, arg3) {\n  if (typeof callback !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n\n  var len = arguments.length;\n  var args;\n  if (len === 3) {\n    args = [arg1];\n  } else if (len === 4) {\n    args = [arg1, arg2];\n  } else if (len > 4) {\n    args = [arg1, arg2, arg3];\n    for (var i = 5; i < len; i++)\n      // extend array dynamically, makes .apply run much faster in v6.0.0\n      args[i - 2] = arguments[i];\n  }\n\n  return createSingleTimeout(callback, after, args);\n}\n\nsetTimeout[internalUtil.promisify.custom] = function(after, value) {\n  const promise = createPromise();\n  createSingleTimeout(promise, after, [value]);\n  return promise;\n};\n\nexports.setTimeout = setTimeout;\n\nfunction createSingleTimeout(callback, after, args) {\n  after *= 1; // coalesce to number or NaN\n  if (!(after >= 1 && after <= TIMEOUT_MAX))\n    after = 1; // schedule on next tick, follows browser behaviour\n\n  var timer = new Timeout(after, callback, args);\n  if (process.domain)\n    timer.domain = process.domain;\n\n  active(timer);\n\n  return timer;\n}\n\n\nfunction ontimeout(timer) {\n  var args = timer._timerArgs;\n  var callback = timer._onTimeout;\n  if (typeof callback !== 'function')\n    return promiseResolve(callback, args[0]);\n  if (!args)\n    timer._onTimeout();\n  else {\n    switch (args.length) {\n      case 1:\n        timer._onTimeout(args[0]);\n        break;\n      case 2:\n        timer._onTimeout(args[0], args[1]);\n        break;\n      case 3:\n        timer._onTimeout(args[0], args[1], args[2]);\n        break;\n      default:\n        Function.prototype.apply.call(callback, timer, args);\n    }\n  }\n  if (timer._repeat)\n    rearm(timer);\n}\n\n\nfunction rearm(timer) {\n  // // Do not re-arm unenroll'd or closed timers.\n  if (timer._idleTimeout === -1) return;\n\n  // If timer is unref'd (or was - it's permanently removed from the list.)\n  if (timer._handle && timer instanceof Timeout) {\n    timer._handle.start(timer._repeat);\n  } else {\n    timer._idleTimeout = timer._repeat;\n    active(timer);\n  }\n}\n\n\nconst clearTimeout = exports.clearTimeout = function(timer) {\n  if (timer && (timer[kOnTimeout] || timer._onTimeout)) {\n    timer[kOnTimeout] = timer._onTimeout = null;\n    if (timer instanceof Timeout) {\n      timer.close(); // for after === 0\n    } else {\n      unenroll(timer);\n    }\n  }\n};\n\n\nexports.setInterval = function(callback, repeat, arg1, arg2, arg3) {\n  if (typeof callback !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n\n  var len = arguments.length;\n  var args;\n  if (len === 3) {\n    args = [arg1];\n  } else if (len === 4) {\n    args = [arg1, arg2];\n  } else if (len > 4) {\n    args = [arg1, arg2, arg3];\n    for (var i = 5; i < len; i++)\n      // extend array dynamically, makes .apply run much faster in v6.0.0\n      args[i - 2] = arguments[i];\n  }\n\n  return createRepeatTimeout(callback, repeat, args);\n};\n\nfunction createRepeatTimeout(callback, repeat, args) {\n  repeat *= 1; // coalesce to number or NaN\n  if (!(repeat >= 1 && repeat <= TIMEOUT_MAX))\n    repeat = 1; // schedule on next tick, follows browser behaviour\n\n  var timer = new Timeout(repeat, callback, args);\n  timer._repeat = repeat;\n  if (process.domain)\n    timer.domain = process.domain;\n\n  active(timer);\n\n  return timer;\n}\n\nexports.clearInterval = function(timer) {\n  if (timer && timer._repeat) {\n    timer._repeat = null;\n    clearTimeout(timer);\n  }\n};\n\n\nfunction Timeout(after, callback, args) {\n  this._called = false;\n  this._idleTimeout = after;\n  this._idlePrev = this;\n  this._idleNext = this;\n  this._idleStart = null;\n  this._onTimeout = callback;\n  this._timerArgs = args;\n  this._repeat = null;\n  this._destroyed = false;\n  this[async_id_symbol] = ++async_uid_fields[kAsyncUidCntr];\n  this[trigger_id_symbol] = initTriggerId();\n  if (async_hook_fields[kInit] > 0)\n    emitInit(this[async_id_symbol], 'Timeout', this[trigger_id_symbol], this);\n}\n\n\nfunction unrefdHandle() {\n  // Don't attempt to call the callback if it is not a function.\n  if (typeof this.owner._onTimeout === 'function') {\n    ontimeout(this.owner);\n  }\n\n  // Make sure we clean up if the callback is no longer a function\n  // even if the timer is an interval.\n  if (!this.owner._repeat ||\n      typeof this.owner._onTimeout !== 'function') {\n    this.owner.close();\n  }\n}\n\n\nTimeout.prototype.unref = function() {\n  if (this._handle) {\n    this._handle.unref();\n  } else if (typeof this._onTimeout === 'function') {\n    var now = TimerWrap.now();\n    if (!this._idleStart) this._idleStart = now;\n    var delay = this._idleStart + this._idleTimeout - now;\n    if (delay < 0) delay = 0;\n\n    // Prevent running cb again when unref() is called during the same cb\n    if (this._called && !this._repeat) {\n      unenroll(this);\n      return;\n    }\n\n    var handle = reuse(this);\n\n    this._handle = handle || new TimerWrap();\n    this._handle.owner = this;\n    this._handle[kOnTimeout] = unrefdHandle;\n    this._handle.start(delay);\n    this._handle.domain = this.domain;\n    this._handle.unref();\n  }\n  return this;\n};\n\nTimeout.prototype.ref = function() {\n  if (this._handle)\n    this._handle.ref();\n  return this;\n};\n\nTimeout.prototype.close = function() {\n  this._onTimeout = null;\n  if (this._handle) {\n    // Fewer checks may be possible, but these cover everything.\n    if (async_hook_fields[kDestroy] > 0 &&\n        this &&\n        typeof this[async_id_symbol] === 'number' &&\n        !this._destroyed) {\n      emitDestroy(this[async_id_symbol]);\n      this._destroyed = true;\n    }\n\n    this._idleTimeout = -1;\n    this._handle[kOnTimeout] = null;\n    this._handle.close();\n  } else {\n    unenroll(this);\n  }\n  return this;\n};\n\n\n// A linked list for storing `setImmediate()` requests\nfunction ImmediateList() {\n  this.head = null;\n  this.tail = null;\n}\n\n// Appends an item to the end of the linked list, adjusting the current tail's\n// previous and next pointers where applicable\nImmediateList.prototype.append = function(item) {\n  if (this.tail) {\n    this.tail._idleNext = item;\n    item._idlePrev = this.tail;\n  } else {\n    this.head = item;\n  }\n  this.tail = item;\n};\n\n// Removes an item from the linked list, adjusting the pointers of adjacent\n// items and the linked list's head or tail pointers as necessary\nImmediateList.prototype.remove = function(item) {\n  if (item._idleNext) {\n    item._idleNext._idlePrev = item._idlePrev;\n  }\n\n  if (item._idlePrev) {\n    item._idlePrev._idleNext = item._idleNext;\n  }\n\n  if (item === this.head)\n    this.head = item._idleNext;\n  if (item === this.tail)\n    this.tail = item._idlePrev;\n\n  item._idleNext = null;\n  item._idlePrev = null;\n};\n\n// Create a single linked list instance only once at startup\nvar immediateQueue = new ImmediateList();\n\n\nfunction processImmediate() {\n  var immediate = immediateQueue.head;\n  var tail = immediateQueue.tail;\n  var domain;\n\n  // Clear the linked list early in case new `setImmediate()` calls occur while\n  // immediate callbacks are executed\n  immediateQueue.head = immediateQueue.tail = null;\n\n  while (immediate) {\n    domain = immediate.domain;\n\n    if (!immediate._onImmediate) {\n      immediate = immediate._idleNext;\n      continue;\n    }\n\n    if (domain)\n      domain.enter();\n\n    immediate._callback = immediate._onImmediate;\n\n    // Save next in case `clearImmediate(immediate)` is called from callback\n    var next = immediate._idleNext;\n\n    tryOnImmediate(immediate, tail);\n\n    if (domain)\n      domain.exit();\n\n    // If `clearImmediate(immediate)` wasn't called from the callback, use the\n    // `immediate`'s next item\n    if (immediate._idleNext)\n      immediate = immediate._idleNext;\n    else\n      immediate = next;\n  }\n\n  // Only round-trip to C++ land if we have to. Calling clearImmediate() on an\n  // immediate that's in |queue| is okay. Worst case is we make a superfluous\n  // call to NeedImmediateCallbackSetter().\n  if (!immediateQueue.head) {\n    process._needImmediateCallback = false;\n  }\n}\n\n\n// An optimization so that the try/finally only de-optimizes (since at least v8\n// 4.7) what is in this smaller function.\nfunction tryOnImmediate(immediate, oldTail) {\n  var threw = true;\n  timerEmitBefore(immediate[async_id_symbol], immediate[trigger_id_symbol]);\n  try {\n    // make the actual call outside the try/catch to allow it to be optimized\n    runCallback(immediate);\n    threw = false;\n  } finally {\n    // clearImmediate checks _callback === null for kDestroy hooks.\n    immediate._callback = null;\n    if (!threw)\n      timerEmitAfter(immediate[async_id_symbol]);\n    if (async_hook_fields[kDestroy] > 0 && !immediate._destroyed) {\n      emitDestroy(immediate[async_id_symbol]);\n      immediate._destroyed = true;\n    }\n\n    if (threw && immediate._idleNext) {\n      // Handle any remaining on next tick, assuming we're still alive to do so.\n      const curHead = immediateQueue.head;\n      const next = immediate._idleNext;\n      if (curHead) {\n        curHead._idlePrev = oldTail;\n        oldTail._idleNext = curHead;\n        next._idlePrev = null;\n        immediateQueue.head = next;\n      } else {\n        immediateQueue.head = next;\n        immediateQueue.tail = oldTail;\n      }\n      process.nextTick(processImmediate);\n    }\n  }\n}\n\nfunction runCallback(timer) {\n  const argv = timer._argv;\n  const argc = argv ? argv.length : 0;\n  if (typeof timer._callback !== 'function')\n    return promiseResolve(timer._callback, argv[0]);\n  switch (argc) {\n    // fast-path callbacks with 0-3 arguments\n    case 0:\n      return timer._callback();\n    case 1:\n      return timer._callback(argv[0]);\n    case 2:\n      return timer._callback(argv[0], argv[1]);\n    case 3:\n      return timer._callback(argv[0], argv[1], argv[2]);\n    // more than 3 arguments run slower with .apply\n    default:\n      return Function.prototype.apply.call(timer._callback, timer, argv);\n  }\n}\n\n\nfunction Immediate() {\n  // assigning the callback here can cause optimize/deoptimize thrashing\n  // so have caller annotate the object (node v6.0.0, v8 5.0.71.35)\n  this._idleNext = null;\n  this._idlePrev = null;\n  this._callback = null;\n  this._argv = null;\n  this._onImmediate = null;\n  this._destroyed = false;\n  this.domain = process.domain;\n  this[async_id_symbol] = ++async_uid_fields[kAsyncUidCntr];\n  this[trigger_id_symbol] = initTriggerId();\n  if (async_hook_fields[kInit] > 0)\n    emitInit(this[async_id_symbol], 'Immediate', this[trigger_id_symbol], this);\n}\n\nfunction setImmediate(callback, arg1, arg2, arg3) {\n  if (typeof callback !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n\n  var i, args;\n\n  switch (arguments.length) {\n    // fast cases\n    case 1:\n      break;\n    case 2:\n      args = [arg1];\n      break;\n    case 3:\n      args = [arg1, arg2];\n      break;\n    default:\n      args = [arg1, arg2, arg3];\n      for (i = 4; i < arguments.length; i++)\n        // extend array dynamically, makes .apply run much faster in v6.0.0\n        args[i - 1] = arguments[i];\n      break;\n  }\n  return createImmediate(args, callback);\n}\n\nsetImmediate[internalUtil.promisify.custom] = function(value) {\n  const promise = createPromise();\n  createImmediate([value], promise);\n  return promise;\n};\n\nexports.setImmediate = setImmediate;\n\nfunction createImmediate(args, callback) {\n  // declaring it `const immediate` causes v6.0.0 to deoptimize this function\n  var immediate = new Immediate();\n  immediate._callback = callback;\n  immediate._argv = args;\n  immediate._onImmediate = callback;\n\n  if (!process._needImmediateCallback) {\n    process._needImmediateCallback = true;\n    process._immediateCallback = processImmediate;\n  }\n\n  immediateQueue.append(immediate);\n\n  return immediate;\n}\n\n\nexports.clearImmediate = function(immediate) {\n  if (!immediate) return;\n\n  if (async_hook_fields[kDestroy] > 0 &&\n      immediate._callback !== null &&\n      !immediate._destroyed) {\n    emitDestroy(immediate[async_id_symbol]);\n    immediate._destroyed = true;\n  }\n\n  immediate._onImmediate = null;\n\n  immediateQueue.remove(immediate);\n\n  if (!immediateQueue.head) {\n    process._needImmediateCallback = false;\n  }\n};\n\n});"},
    {"fileId":27, "filename":"querystring.js", "source":"(function (exports, require, module, __filename, __dirname) { // Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Query String Utilities\n\n'use strict';\n\nconst { Buffer } = require('buffer');\nconst {\n  hexTable,\n  isHexTable\n} = require('internal/querystring');\nconst QueryString = module.exports = {\n  unescapeBuffer,\n  // `unescape()` is a JS global, so we need to use a different local name\n  unescape: qsUnescape,\n\n  // `escape()` is a JS global, so we need to use a different local name\n  escape: qsEscape,\n\n  stringify,\n  encode: stringify,\n\n  parse,\n  decode: parse\n};\n\nconst unhexTable = [\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 0 - 15\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 16 - 31\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 32 - 47\n  +0, +1, +2, +3, +4, +5, +6, +7, +8, +9, -1, -1, -1, -1, -1, -1, // 48 - 63\n  -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 64 - 79\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 80 - 95\n  -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 96 - 111\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 112 - 127\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 128 ...\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1  // ... 255\n];\n// a safe fast alternative to decodeURIComponent\nfunction unescapeBuffer(s, decodeSpaces) {\n  var out = Buffer.allocUnsafe(s.length);\n  var index = 0;\n  var outIndex = 0;\n  var currentChar;\n  var nextChar;\n  var hexHigh;\n  var hexLow;\n  var maxLength = s.length - 2;\n  // Flag to know if some hex chars have been decoded\n  var hasHex = false;\n  while (index < s.length) {\n    currentChar = s.charCodeAt(index);\n    if (currentChar === 43 /*'+'*/ && decodeSpaces) {\n      out[outIndex++] = 32; // ' '\n      index++;\n      continue;\n    }\n    if (currentChar === 37 /*'%'*/ && index < maxLength) {\n      currentChar = s.charCodeAt(++index);\n      hexHigh = unhexTable[currentChar];\n      if (!(hexHigh >= 0)) {\n        out[outIndex++] = 37; // '%'\n      } else {\n        nextChar = s.charCodeAt(++index);\n        hexLow = unhexTable[nextChar];\n        if (!(hexLow >= 0)) {\n          out[outIndex++] = 37; // '%'\n          out[outIndex++] = currentChar;\n          currentChar = nextChar;\n        } else {\n          hasHex = true;\n          currentChar = hexHigh * 16 + hexLow;\n        }\n      }\n    }\n    out[outIndex++] = currentChar;\n    index++;\n  }\n  return hasHex ? out.slice(0, outIndex) : out;\n}\n\n\nfunction qsUnescape(s, decodeSpaces) {\n  try {\n    return decodeURIComponent(s);\n  } catch (e) {\n    return QueryString.unescapeBuffer(s, decodeSpaces).toString();\n  }\n}\n\n\n// These characters do not need escaping when generating query strings:\n// ! - . _ ~\n// ' ( ) *\n// digits\n// alpha (uppercase)\n// alpha (lowercase)\nconst noEscape = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, // 80 - 95\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0  // 112 - 127\n];\n// QueryString.escape() replaces encodeURIComponent()\n// http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3.4\nfunction qsEscape(str) {\n  if (typeof str !== 'string') {\n    if (typeof str === 'object')\n      str = String(str);\n    else\n      str += '';\n  }\n  var out = '';\n  var lastPos = 0;\n\n  for (var i = 0; i < str.length; ++i) {\n    var c = str.charCodeAt(i);\n\n    // ASCII\n    if (c < 0x80) {\n      if (noEscape[c] === 1)\n        continue;\n      if (lastPos < i)\n        out += str.slice(lastPos, i);\n      lastPos = i + 1;\n      out += hexTable[c];\n      continue;\n    }\n\n    if (lastPos < i)\n      out += str.slice(lastPos, i);\n\n    // Multi-byte characters ...\n    if (c < 0x800) {\n      lastPos = i + 1;\n      out += hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)];\n      continue;\n    }\n    if (c < 0xD800 || c >= 0xE000) {\n      lastPos = i + 1;\n      out += hexTable[0xE0 | (c >> 12)] +\n             hexTable[0x80 | ((c >> 6) & 0x3F)] +\n             hexTable[0x80 | (c & 0x3F)];\n      continue;\n    }\n    // Surrogate pair\n    ++i;\n    var c2;\n    if (i < str.length)\n      c2 = str.charCodeAt(i) & 0x3FF;\n    else\n      throw new URIError('URI malformed');\n    lastPos = i + 1;\n    c = 0x10000 + (((c & 0x3FF) << 10) | c2);\n    out += hexTable[0xF0 | (c >> 18)] +\n           hexTable[0x80 | ((c >> 12) & 0x3F)] +\n           hexTable[0x80 | ((c >> 6) & 0x3F)] +\n           hexTable[0x80 | (c & 0x3F)];\n  }\n  if (lastPos === 0)\n    return str;\n  if (lastPos < str.length)\n    return out + str.slice(lastPos);\n  return out;\n}\n\nfunction stringifyPrimitive(v) {\n  if (typeof v === 'string')\n    return v;\n  if (typeof v === 'number' && isFinite(v))\n    return '' + v;\n  if (typeof v === 'boolean')\n    return v ? 'true' : 'false';\n  return '';\n}\n\n\nfunction stringify(obj, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n\n  var encode = QueryString.escape;\n  if (options && typeof options.encodeURIComponent === 'function') {\n    encode = options.encodeURIComponent;\n  }\n\n  if (obj !== null && typeof obj === 'object') {\n    var keys = Object.keys(obj);\n    var len = keys.length;\n    var flast = len - 1;\n    var fields = '';\n    for (var i = 0; i < len; ++i) {\n      var k = keys[i];\n      var v = obj[k];\n      var ks = encode(stringifyPrimitive(k)) + eq;\n\n      if (Array.isArray(v)) {\n        var vlen = v.length;\n        var vlast = vlen - 1;\n        for (var j = 0; j < vlen; ++j) {\n          fields += ks + encode(stringifyPrimitive(v[j]));\n          if (j < vlast)\n            fields += sep;\n        }\n        if (vlen && i < flast)\n          fields += sep;\n      } else {\n        fields += ks + encode(stringifyPrimitive(v));\n        if (i < flast)\n          fields += sep;\n      }\n    }\n    return fields;\n  }\n  return '';\n}\n\nfunction charCodes(str) {\n  if (str.length === 0) return [];\n  if (str.length === 1) return [str.charCodeAt(0)];\n  const ret = [];\n  for (var i = 0; i < str.length; ++i)\n    ret[ret.length] = str.charCodeAt(i);\n  return ret;\n}\nconst defSepCodes = [38]; // &\nconst defEqCodes = [61]; // =\n\n// Parse a key/val string.\nfunction parse(qs, sep, eq, options) {\n  const obj = Object.create(null);\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var sepCodes = (!sep ? defSepCodes : charCodes(sep + ''));\n  var eqCodes = (!eq ? defEqCodes : charCodes(eq + ''));\n  const sepLen = sepCodes.length;\n  const eqLen = eqCodes.length;\n\n  var pairs = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    // -1 is used in place of a value like Infinity for meaning\n    // \"unlimited pairs\" because of additional checks V8 (at least as of v5.4)\n    // has to do when using variables that contain values like Infinity. Since\n    // `pairs` is always decremented and checked explicitly for 0, -1 works\n    // effectively the same as Infinity, while providing a significant\n    // performance boost.\n    pairs = (options.maxKeys > 0 ? options.maxKeys : -1);\n  }\n\n  var decode = QueryString.unescape;\n  if (options && typeof options.decodeURIComponent === 'function') {\n    decode = options.decodeURIComponent;\n  }\n  const customDecode = (decode !== qsUnescape);\n\n  const keys = [];\n  var lastPos = 0;\n  var sepIdx = 0;\n  var eqIdx = 0;\n  var key = '';\n  var value = '';\n  var keyEncoded = customDecode;\n  var valEncoded = customDecode;\n  const plusChar = (customDecode ? '%20' : ' ');\n  var encodeCheck = 0;\n  for (var i = 0; i < qs.length; ++i) {\n    const code = qs.charCodeAt(i);\n\n    // Try matching key/value pair separator (e.g. '&')\n    if (code === sepCodes[sepIdx]) {\n      if (++sepIdx === sepLen) {\n        // Key/value pair separator match!\n        const end = i - sepIdx + 1;\n        if (eqIdx < eqLen) {\n          // We didn't find the (entire) key/value separator\n          if (lastPos < end) {\n            // Treat the substring as part of the key instead of the value\n            key += qs.slice(lastPos, end);\n            if (keyEncoded)\n              key = decodeStr(key, decode);\n          } else {\n            // We saw an empty substring between separators\n            if (--pairs === 0)\n              return obj;\n            lastPos = i + 1;\n            sepIdx = eqIdx = 0;\n            continue;\n          }\n        } else {\n          if (lastPos < end) {\n            value += qs.slice(lastPos, end);\n            if (valEncoded)\n              value = decodeStr(value, decode);\n          }\n          if (keyEncoded)\n            key = decodeStr(key, decode);\n        }\n\n        // Use a key array lookup instead of using hasOwnProperty(), which is\n        // slower\n        if (keys.indexOf(key) === -1) {\n          obj[key] = value;\n          keys[keys.length] = key;\n        } else {\n          const curValue = obj[key];\n          // A simple Array-specific property check is enough here to\n          // distinguish from a string value and is faster and still safe\n          // since we are generating all of the values being assigned.\n          if (curValue.pop)\n            curValue[curValue.length] = value;\n          else\n            obj[key] = [curValue, value];\n        }\n        if (--pairs === 0)\n          return obj;\n        keyEncoded = valEncoded = customDecode;\n        key = value = '';\n        encodeCheck = 0;\n        lastPos = i + 1;\n        sepIdx = eqIdx = 0;\n      }\n    } else {\n      sepIdx = 0;\n      // Try matching key/value separator (e.g. '=') if we haven't already\n      if (eqIdx < eqLen) {\n        if (code === eqCodes[eqIdx]) {\n          if (++eqIdx === eqLen) {\n            // Key/value separator match!\n            const end = i - eqIdx + 1;\n            if (lastPos < end)\n              key += qs.slice(lastPos, end);\n            encodeCheck = 0;\n            lastPos = i + 1;\n          }\n          continue;\n        } else {\n          eqIdx = 0;\n          if (!keyEncoded) {\n            // Try to match an (valid) encoded byte once to minimize unnecessary\n            // calls to string decoding functions\n            if (code === 37/*%*/) {\n              encodeCheck = 1;\n              continue;\n            } else if (encodeCheck > 0) {\n              // eslint-disable-next-line no-extra-boolean-cast\n              if (!!isHexTable[code]) {\n                if (++encodeCheck === 3)\n                  keyEncoded = true;\n                continue;\n              } else {\n                encodeCheck = 0;\n              }\n            }\n          }\n        }\n        if (code === 43/*+*/) {\n          if (lastPos < i)\n            key += qs.slice(lastPos, i);\n          key += plusChar;\n          lastPos = i + 1;\n          continue;\n        }\n      }\n      if (code === 43/*+*/) {\n        if (lastPos < i)\n          value += qs.slice(lastPos, i);\n        value += plusChar;\n        lastPos = i + 1;\n      } else if (!valEncoded) {\n        // Try to match an (valid) encoded byte (once) to minimize unnecessary\n        // calls to string decoding functions\n        if (code === 37/*%*/) {\n          encodeCheck = 1;\n        } else if (encodeCheck > 0) {\n          // eslint-disable-next-line no-extra-boolean-cast\n          if (!!isHexTable[code]) {\n            if (++encodeCheck === 3)\n              valEncoded = true;\n          } else {\n            encodeCheck = 0;\n          }\n        }\n      }\n    }\n  }\n\n  // Deal with any leftover key or value data\n  if (lastPos < qs.length) {\n    if (eqIdx < eqLen)\n      key += qs.slice(lastPos);\n    else if (sepIdx < sepLen)\n      value += qs.slice(lastPos);\n  } else if (eqIdx === 0) {\n    // We ended on an empty substring\n    return obj;\n  }\n  if (keyEncoded)\n    key = decodeStr(key, decode);\n  if (valEncoded)\n    value = decodeStr(value, decode);\n  // Use a key array lookup instead of using hasOwnProperty(), which is slower\n  if (keys.indexOf(key) === -1) {\n    obj[key] = value;\n    keys[keys.length] = key;\n  } else {\n    const curValue = obj[key];\n    // A simple Array-specific property check is enough here to\n    // distinguish from a string value and is faster and still safe since\n    // we are generating all of the values being assigned.\n    if (curValue.pop)\n      curValue[curValue.length] = value;\n    else\n      obj[key] = [curValue, value];\n  }\n\n  return obj;\n}\n\n\n// v8 does not optimize functions with try-catch blocks, so we isolate them here\n// to minimize the damage (Note: no longer true as of V8 5.4 -- but still will\n// not be inlined).\nfunction decodeStr(s, decoder) {\n  try {\n    return decoder(s);\n  } catch (e) {\n    return QueryString.unescape(s, true);\n  }\n}\n\n});"},
    {"fileId":28, "filename":"internal/linkedlist.js", "source":"(function (exports, require, module, __filename, __dirname) { 'use strict';\n\nfunction init(list) {\n  list._idleNext = list;\n  list._idlePrev = list;\n}\n\n// show the most idle item\nfunction peek(list) {\n  if (list._idlePrev === list) return null;\n  return list._idlePrev;\n}\n\n// remove a item from its list\nfunction remove(item) {\n  if (item._idleNext) {\n    item._idleNext._idlePrev = item._idlePrev;\n  }\n\n  if (item._idlePrev) {\n    item._idlePrev._idleNext = item._idleNext;\n  }\n\n  item._idleNext = null;\n  item._idlePrev = null;\n}\n\n// remove a item from its list and place at the end.\nfunction append(list, item) {\n  if (item._idleNext || item._idlePrev) {\n    remove(item);\n  }\n\n  // items are linked  with _idleNext -> (older) and _idlePrev -> (newer)\n  // Note: This linkage (next being older) may seem counter-intuitive at first.\n  item._idleNext = list._idleNext;\n  item._idlePrev = list;\n\n  // the list _idleNext points to tail (newest) and _idlePrev to head (oldest)\n  list._idleNext._idlePrev = item;\n  list._idleNext = item;\n}\n\nfunction isEmpty(list) {\n  return list._idleNext === list;\n}\n\nmodule.exports = {\n  init,\n  peek,\n  remove,\n  append,\n  isEmpty\n};\n\n});"},
    {"fileId":29, "filename":"async_hooks.js", "source":"(function (exports, require, module, __filename, __dirname) { 'use strict';\n\nconst async_wrap = process.binding('async_wrap');\n/* Both these arrays are used to communicate between JS and C++ with as little\n * overhead as possible.\n *\n * async_hook_fields is a Uint32Array() that communicates the number of each\n * type of active hooks of each type and wraps the uin32_t array of\n * node::Environment::AsyncHooks::fields_.\n *\n * async_uid_fields is a Float64Array() that contains the async/trigger ids for\n * several operations. These fields are as follows:\n *   kCurrentAsyncId: The async id of the current execution stack.\n *   kCurrentTriggerId: The trigger id of the current execution stack.\n *   kAsyncUidCntr: Counter that tracks the unique ids given to new resources.\n *   kInitTriggerId: Written to just before creating a new resource, so the\n *    constructor knows what other resource is responsible for its init().\n *    Used this way so the trigger id doesn't need to be passed to every\n *    resource's constructor.\n */\nconst { async_hook_fields, async_uid_fields } = async_wrap;\n// Used to change the state of the async id stack.\nconst { pushAsyncIds, popAsyncIds } = async_wrap;\n// Array of all AsyncHooks that will be iterated whenever an async event fires.\n// Using var instead of (preferably const) in order to assign\n// tmp_active_hooks_array if a hook is enabled/disabled during hook execution.\nvar active_hooks_array = [];\n// Track whether a hook callback is currently being processed. Used to make\n// sure active_hooks_array isn't altered in mid execution if another hook is\n// added or removed.\nvar processing_hook = false;\n// Use to temporarily store and updated active_hooks_array if the user enables\n// or disables a hook while hooks are being processed.\nvar tmp_active_hooks_array = null;\n// Keep track of the field counts held in tmp_active_hooks_array.\nvar tmp_async_hook_fields = null;\n\n// Each constant tracks how many callbacks there are for any given step of\n// async execution. These are tracked so if the user didn't include callbacks\n// for a given step, that step can bail out early.\nconst { kInit, kBefore, kAfter, kDestroy, kCurrentAsyncId, kCurrentTriggerId,\n    kAsyncUidCntr, kInitTriggerId } = async_wrap.constants;\n\nconst { async_id_symbol, trigger_id_symbol } = async_wrap;\n\n// Used in AsyncHook and AsyncResource.\nconst init_symbol = Symbol('init');\nconst before_symbol = Symbol('before');\nconst after_symbol = Symbol('after');\nconst destroy_symbol = Symbol('destroy');\n\nlet setupHooksCalled = false;\n\n// Used to fatally abort the process if a callback throws.\nfunction fatalError(e) {\n  if (typeof e.stack === 'string') {\n    process._rawDebug(e.stack);\n  } else {\n    const o = { message: e };\n    Error.captureStackTrace(o, fatalError);\n    process._rawDebug(o.stack);\n  }\n  if (process.execArgv.some(\n      (e) => /^--abort[_-]on[_-]uncaught[_-]exception$/.test(e))) {\n    process.abort();\n  }\n  process.exit(1);\n}\n\n\n// Public API //\n\nclass AsyncHook {\n  constructor({ init, before, after, destroy }) {\n    if (init !== undefined && typeof init !== 'function')\n      throw new TypeError('init must be a function');\n    if (before !== undefined && typeof before !== 'function')\n      throw new TypeError('before must be a function');\n    if (after !== undefined && typeof after !== 'function')\n      throw new TypeError('after must be a function');\n    if (destroy !== undefined && typeof destroy !== 'function')\n      throw new TypeError('destroy must be a function');\n\n    this[init_symbol] = init;\n    this[before_symbol] = before;\n    this[after_symbol] = after;\n    this[destroy_symbol] = destroy;\n  }\n\n  enable() {\n    // The set of callbacks for a hook should be the same regardless of whether\n    // enable()/disable() are run during their execution. The following\n    // references are reassigned to the tmp arrays if a hook is currently being\n    // processed.\n    const [hooks_array, hook_fields] = getHookArrays();\n\n    // Each hook is only allowed to be added once.\n    if (hooks_array.includes(this))\n      return;\n\n    if (!setupHooksCalled) {\n      setupHooksCalled = true;\n      // Setup the callbacks that node::AsyncWrap will call when there are\n      // hooks to process. They use the same functions as the JS embedder API.\n      async_wrap.setupHooks({ init,\n                              before: emitBeforeN,\n                              after: emitAfterN,\n                              destroy: emitDestroyN });\n    }\n\n    // createHook() has already enforced that the callbacks are all functions,\n    // so here simply increment the count of whether each callbacks exists or\n    // not.\n    hook_fields[kInit] += +!!this[init_symbol];\n    hook_fields[kBefore] += +!!this[before_symbol];\n    hook_fields[kAfter] += +!!this[after_symbol];\n    hook_fields[kDestroy] += +!!this[destroy_symbol];\n    hooks_array.push(this);\n    return this;\n  }\n\n  disable() {\n    const [hooks_array, hook_fields] = getHookArrays();\n\n    const index = hooks_array.indexOf(this);\n    if (index === -1)\n      return;\n\n    hook_fields[kInit] -= +!!this[init_symbol];\n    hook_fields[kBefore] -= +!!this[before_symbol];\n    hook_fields[kAfter] -= +!!this[after_symbol];\n    hook_fields[kDestroy] -= +!!this[destroy_symbol];\n    hooks_array.splice(index, 1);\n    return this;\n  }\n}\n\n\nfunction getHookArrays() {\n  if (!processing_hook)\n    return [active_hooks_array, async_hook_fields];\n  // If this hook is being enabled while in the middle of processing the array\n  // of currently active hooks then duplicate the current set of active hooks\n  // and store this there. This shouldn't fire until the next time hooks are\n  // processed.\n  if (tmp_active_hooks_array === null)\n    storeActiveHooks();\n  return [tmp_active_hooks_array, tmp_async_hook_fields];\n}\n\n\nfunction storeActiveHooks() {\n  tmp_active_hooks_array = active_hooks_array.slice();\n  // Don't want to make the assumption that kInit to kDestroy are indexes 0 to\n  // 4. So do this the long way.\n  tmp_async_hook_fields = [];\n  tmp_async_hook_fields[kInit] = async_hook_fields[kInit];\n  tmp_async_hook_fields[kBefore] = async_hook_fields[kBefore];\n  tmp_async_hook_fields[kAfter] = async_hook_fields[kAfter];\n  tmp_async_hook_fields[kDestroy] = async_hook_fields[kDestroy];\n}\n\n\n// Then restore the correct hooks array in case any hooks were added/removed\n// during hook callback execution.\nfunction restoreTmpHooks() {\n  active_hooks_array = tmp_active_hooks_array;\n  async_hook_fields[kInit] = tmp_async_hook_fields[kInit];\n  async_hook_fields[kBefore] = tmp_async_hook_fields[kBefore];\n  async_hook_fields[kAfter] = tmp_async_hook_fields[kAfter];\n  async_hook_fields[kDestroy] = tmp_async_hook_fields[kDestroy];\n\n  tmp_active_hooks_array = null;\n  tmp_async_hook_fields = null;\n}\n\n\nfunction createHook(fns) {\n  return new AsyncHook(fns);\n}\n\n\nfunction currentId() {\n  return async_uid_fields[kCurrentAsyncId];\n}\n\n\nfunction triggerId() {\n  return async_uid_fields[kCurrentTriggerId];\n}\n\n\n// Embedder API //\n\nclass AsyncResource {\n  constructor(type, triggerId) {\n    this[async_id_symbol] = ++async_uid_fields[kAsyncUidCntr];\n    // Read and reset the current kInitTriggerId so that when the constructor\n    // finishes the kInitTriggerId field is always 0.\n    if (triggerId === undefined) {\n      triggerId = initTriggerId();\n    // If a triggerId was passed, any kInitTriggerId still must be null'd.\n    } else {\n      async_uid_fields[kInitTriggerId] = 0;\n    }\n    this[trigger_id_symbol] = triggerId;\n\n    // Return immediately if there's nothing to do.\n    if (async_hook_fields[kInit] === 0)\n      return;\n\n    if (typeof type !== 'string' || type.length <= 0)\n      throw new TypeError('type must be a string with length > 0');\n    if (!Number.isSafeInteger(triggerId) || triggerId < 0)\n      throw new RangeError('triggerId must be an unsigned integer');\n\n    processing_hook = true;\n    for (var i = 0; i < active_hooks_array.length; i++) {\n      if (typeof active_hooks_array[i][init_symbol] === 'function') {\n        runInitCallback(active_hooks_array[i][init_symbol],\n                        this[async_id_symbol],\n                        type,\n                        triggerId,\n                        this);\n      }\n    }\n    processing_hook = false;\n  }\n\n  emitBefore() {\n    emitBeforeS(this[async_id_symbol], this[trigger_id_symbol]);\n    return this;\n  }\n\n  emitAfter() {\n    emitAfterS(this[async_id_symbol]);\n    return this;\n  }\n\n  emitDestroy() {\n    emitDestroyS(this[async_id_symbol]);\n    return this;\n  }\n\n  asyncId() {\n    return this[async_id_symbol];\n  }\n\n  triggerId() {\n    return this[trigger_id_symbol];\n  }\n}\n\n\nfunction runInAsyncIdScope(asyncId, cb) {\n  // Store the async id now to make sure the stack is still good when the ids\n  // are popped off the stack.\n  const prevId = currentId();\n  pushAsyncIds(asyncId, prevId);\n  try {\n    cb();\n  } finally {\n    popAsyncIds(asyncId);\n  }\n}\n\n\n// Sensitive Embedder API //\n\n// Increment the internal id counter and return the value. Important that the\n// counter increment first. Since it's done the same way in\n// Environment::new_async_uid()\nfunction newUid() {\n  return ++async_uid_fields[kAsyncUidCntr];\n}\n\n\n// Return the triggerId meant for the constructor calling it. It's up to the\n// user to safeguard this call and make sure it's zero'd out when the\n// constructor is complete.\nfunction initTriggerId() {\n  var tId = async_uid_fields[kInitTriggerId];\n  // Reset value after it's been called so the next constructor doesn't\n  // inherit it by accident.\n  async_uid_fields[kInitTriggerId] = 0;\n  if (tId <= 0)\n    tId = async_uid_fields[kCurrentAsyncId];\n  return tId;\n}\n\n\nfunction setInitTriggerId(triggerId) {\n  // CHECK(Number.isSafeInteger(triggerId))\n  // CHECK(triggerId > 0)\n  async_uid_fields[kInitTriggerId] = triggerId;\n}\n\n\nfunction emitInitS(asyncId, type, triggerId, resource) {\n  // Short circuit all checks for the common case. Which is that no hooks have\n  // been set. Do this to remove performance impact for embedders (and core).\n  // Even though it bypasses all the argument checks. The performance savings\n  // here is critical.\n  if (async_hook_fields[kInit] === 0)\n    return;\n\n  // This can run after the early return check b/c running this function\n  // manually means that the embedder must have used initTriggerId().\n  if (!Number.isSafeInteger(triggerId)) {\n    if (triggerId !== undefined)\n      resource = triggerId;\n    triggerId = initTriggerId();\n  }\n\n  // I'd prefer allowing these checks to not exist, or only throw in a debug\n  // build, in order to improve performance.\n  if (!Number.isSafeInteger(asyncId) || asyncId < 0)\n    throw new RangeError('asyncId must be an unsigned integer');\n  if (typeof type !== 'string' || type.length <= 0)\n    throw new TypeError('type must be a string with length > 0');\n  if (!Number.isSafeInteger(triggerId) || triggerId < 0)\n    throw new RangeError('triggerId must be an unsigned integer');\n\n  processing_hook = true;\n  for (var i = 0; i < active_hooks_array.length; i++) {\n    if (typeof active_hooks_array[i][init_symbol] === 'function') {\n      runInitCallback(\n        active_hooks_array[i][init_symbol], asyncId, type, triggerId, resource);\n    }\n  }\n  processing_hook = false;\n\n  // Isn't null if hooks were added/removed while the hooks were running.\n  if (tmp_active_hooks_array !== null) {\n    restoreTmpHooks();\n  }\n}\n\n\nfunction emitBeforeN(asyncId) {\n  processing_hook = true;\n  for (var i = 0; i < active_hooks_array.length; i++) {\n    if (typeof active_hooks_array[i][before_symbol] === 'function') {\n      runCallback(active_hooks_array[i][before_symbol], asyncId);\n    }\n  }\n  processing_hook = false;\n\n  if (tmp_active_hooks_array !== null) {\n    restoreTmpHooks();\n  }\n}\n\n\n// Usage: emitBeforeS(asyncId[, triggerId]). If triggerId is omitted then\n// asyncId will be used instead.\nfunction emitBeforeS(asyncId, triggerId = asyncId) {\n  // CHECK(Number.isSafeInteger(asyncId) && asyncId > 0)\n  // CHECK(Number.isSafeInteger(triggerId) && triggerId > 0)\n\n  // Validate the ids.\n  if (asyncId < 0 || triggerId < 0) {\n    fatalError('before(): asyncId or triggerId is less than zero ' +\n               `(asyncId: ${asyncId}, triggerId: ${triggerId})`);\n  }\n\n  pushAsyncIds(asyncId, triggerId);\n\n  if (async_hook_fields[kBefore] === 0) {\n    return;\n  }\n\n  emitBeforeN(asyncId);\n}\n\n\n// Called from native. The asyncId stack handling is taken care of there before\n// this is called.\nfunction emitAfterN(asyncId) {\n  if (async_hook_fields[kAfter] > 0) {\n    processing_hook = true;\n    for (var i = 0; i < active_hooks_array.length; i++) {\n      if (typeof active_hooks_array[i][after_symbol] === 'function') {\n        runCallback(active_hooks_array[i][after_symbol], asyncId);\n      }\n    }\n    processing_hook = false;\n  }\n\n  if (tmp_active_hooks_array !== null) {\n    restoreTmpHooks();\n  }\n}\n\n\n// TODO(trevnorris): Calling emitBefore/emitAfter from native can't adjust the\n// kIdStackIndex. But what happens if the user doesn't have both before and\n// after callbacks.\nfunction emitAfterS(asyncId) {\n  emitAfterN(asyncId);\n  popAsyncIds(asyncId);\n}\n\n\nfunction emitDestroyS(asyncId) {\n  // Return early if there are no destroy callbacks, or on attempt to emit\n  // destroy on the void.\n  if (async_hook_fields[kDestroy] === 0 || asyncId === 0)\n    return;\n  async_wrap.addIdToDestroyList(asyncId);\n}\n\n\nfunction emitDestroyN(asyncId) {\n  processing_hook = true;\n  for (var i = 0; i < active_hooks_array.length; i++) {\n    if (typeof active_hooks_array[i][destroy_symbol] === 'function') {\n      runCallback(active_hooks_array[i][destroy_symbol], asyncId);\n    }\n  }\n  processing_hook = false;\n\n  if (tmp_active_hooks_array !== null) {\n    restoreTmpHooks();\n  }\n}\n\n\n// Emit callbacks for native calls. Since some state can be setup directly from\n// C++ there's no need to perform all the work here.\n\n// This should only be called if hooks_array has kInit > 0. There are no global\n// values to setup. Though hooks_array will be cloned if C++ needed to call\n// init().\n// TODO(trevnorris): Perhaps have MakeCallback call a single JS function that\n// does the before/callback/after calls to remove two additional calls to JS.\nfunction init(asyncId, type, resource, triggerId) {\n  processing_hook = true;\n  for (var i = 0; i < active_hooks_array.length; i++) {\n    if (typeof active_hooks_array[i][init_symbol] === 'function') {\n      runInitCallback(\n        active_hooks_array[i][init_symbol], asyncId, type, triggerId, resource);\n    }\n  }\n  processing_hook = false;\n}\n\n\n// Generalized callers for all callbacks that handles error handling.\n\n// If either runInitCallback() or runCallback() throw then force the\n// application to shutdown if one of the callbacks throws. This may change in\n// the future depending on whether it can be determined if there's a slim\n// chance of the application remaining stable after handling one of these\n// exceptions.\n\nfunction runInitCallback(cb, asyncId, type, triggerId, resource) {\n  try {\n    cb(asyncId, type, triggerId, resource);\n  } catch (e) {\n    fatalError(e);\n  }\n}\n\n\nfunction runCallback(cb, asyncId) {\n  try {\n    cb(asyncId);\n  } catch (e) {\n    fatalError(e);\n  }\n}\n\n\n// Placing all exports down here because the exported classes won't export\n// otherwise.\nmodule.exports = {\n  // Public API\n  createHook,\n  currentId,\n  triggerId,\n  // Embedder API\n  AsyncResource,\n  runInAsyncIdScope,\n  // Sensitive Embedder API\n  newUid,\n  initTriggerId,\n  setInitTriggerId,\n  emitInit: emitInitS,\n  emitBefore: emitBeforeS,\n  emitAfter: emitAfterS,\n  emitDestroy: emitDestroyS,\n};\n\n});"},
    {"fileId":30, "filename":"internal/process/stdio.js", "source":"(function (exports, require, module, __filename, __dirname) { 'use strict';\n\nexports.setup = setupStdio;\n\nvar errors;\n\nfunction lazyErrors() {\n  if (!errors)\n    errors = require('internal/errors');\n  return errors;\n}\n\nfunction setupStdio() {\n  var stdin;\n  var stdout;\n  var stderr;\n\n  function getStdout() {\n    if (stdout) return stdout;\n    stdout = createWritableStdioStream(1);\n    stdout.destroySoon = stdout.destroy;\n    stdout._destroy = function(er, cb) {\n      // avoid errors if we already emitted\n      const errors = lazyErrors();\n      er = er || new errors.Error('ERR_STDOUT_CLOSE');\n      cb(er);\n    };\n    if (stdout.isTTY) {\n      process.on('SIGWINCH', () => stdout._refreshSize());\n    }\n    return stdout;\n  }\n\n  function getStderr() {\n    if (stderr) return stderr;\n    stderr = createWritableStdioStream(2);\n    stderr.destroySoon = stderr.destroy;\n    stderr._destroy = function(er, cb) {\n      // avoid errors if we already emitted\n      const errors = lazyErrors();\n      er = er || new errors.Error('ERR_STDERR_CLOSE');\n      cb(er);\n    };\n    if (stderr.isTTY) {\n      process.on('SIGWINCH', () => stderr._refreshSize());\n    }\n    return stderr;\n  }\n\n  function getStdin() {\n    if (stdin) return stdin;\n\n    const tty_wrap = process.binding('tty_wrap');\n    const fd = 0;\n\n    switch (tty_wrap.guessHandleType(fd)) {\n      case 'TTY':\n        var tty = require('tty');\n        stdin = new tty.ReadStream(fd, {\n          highWaterMark: 0,\n          readable: true,\n          writable: false\n        });\n        break;\n\n      case 'FILE':\n        var fs = require('fs');\n        stdin = new fs.ReadStream(null, { fd: fd, autoClose: false });\n        break;\n\n      case 'PIPE':\n      case 'TCP':\n        var net = require('net');\n\n        // It could be that process has been started with an IPC channel\n        // sitting on fd=0, in such case the pipe for this fd is already\n        // present and creating a new one will lead to the assertion failure\n        // in libuv.\n        if (process.channel && process.channel.fd === fd) {\n          stdin = new net.Socket({\n            handle: process.channel,\n            readable: true,\n            writable: false\n          });\n        } else {\n          stdin = new net.Socket({\n            fd: fd,\n            readable: true,\n            writable: false\n          });\n        }\n        // Make sure the stdin can't be `.end()`-ed\n        stdin._writableState.ended = true;\n        break;\n\n      default:\n        // Probably an error on in uv_guess_handle()\n        const errors = lazyErrors();\n        throw new errors.Error('ERR_UNKNOWN_STDIN_TYPE');\n    }\n\n    // For supporting legacy API we put the FD here.\n    stdin.fd = fd;\n\n    // stdin starts out life in a paused state, but node doesn't\n    // know yet.  Explicitly to readStop() it to put it in the\n    // not-reading state.\n    if (stdin._handle && stdin._handle.readStop) {\n      stdin._handle.reading = false;\n      stdin._readableState.reading = false;\n      stdin._handle.readStop();\n    }\n\n    // if the user calls stdin.pause(), then we need to stop reading\n    // immediately, so that the process can close down.\n    stdin.on('pause', () => {\n      if (!stdin._handle)\n        return;\n      stdin._readableState.reading = false;\n      stdin._handle.reading = false;\n      stdin._handle.readStop();\n    });\n\n    return stdin;\n  }\n\n  Object.defineProperty(process, 'stdout', {\n    configurable: true,\n    enumerable: true,\n    get: getStdout\n  });\n\n  Object.defineProperty(process, 'stderr', {\n    configurable: true,\n    enumerable: true,\n    get: getStderr\n  });\n\n  Object.defineProperty(process, 'stdin', {\n    configurable: true,\n    enumerable: true,\n    get: getStdin\n  });\n\n  process.openStdin = function() {\n    process.stdin.resume();\n    return process.stdin;\n  };\n}\n\nfunction createWritableStdioStream(fd) {\n  var stream;\n  const tty_wrap = process.binding('tty_wrap');\n\n  // Note stream._type is used for test-module-load-list.js\n\n  switch (tty_wrap.guessHandleType(fd)) {\n    case 'TTY':\n      var tty = require('tty');\n      stream = new tty.WriteStream(fd);\n      stream._type = 'tty';\n      break;\n\n    case 'FILE':\n      var fs = require('internal/fs');\n      stream = new fs.SyncWriteStream(fd, { autoClose: false });\n      stream._type = 'fs';\n      break;\n\n    case 'PIPE':\n    case 'TCP':\n      var net = require('net');\n      stream = new net.Socket({\n        fd: fd,\n        readable: false,\n        writable: true\n      });\n      stream._type = 'pipe';\n      break;\n\n    default:\n      // Probably an error on in uv_guess_handle()\n      const errors = lazyErrors();\n      throw new errors.Error('ERR_UNKNOWN_STREAM_TYPE');\n  }\n\n  // For supporting legacy API we put the FD here.\n  stream.fd = fd;\n\n  stream._isStdio = true;\n\n  return stream;\n}\n\n});"},
    {"fileId":31, "filename":"vm.js", "source":"(function (exports, require, module, __filename, __dirname) { // Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst binding = process.binding('contextify');\nconst Script = binding.ContextifyScript;\n\n// The binding provides a few useful primitives:\n// - Script(code, { filename = \"evalmachine.anonymous\",\n//                  displayErrors = true } = {})\n//   with methods:\n//   - runInThisContext({ displayErrors = true } = {})\n//   - runInContext(sandbox, { displayErrors = true, timeout = undefined } = {})\n// - makeContext(sandbox)\n// - isContext(sandbox)\n// From this we build the entire documented API.\n\nconst realRunInThisContext = Script.prototype.runInThisContext;\nconst realRunInContext = Script.prototype.runInContext;\n\nScript.prototype.runInThisContext = function(options) {\n  if (options && options.breakOnSigint && process._events.SIGINT) {\n    return sigintHandlersWrap(realRunInThisContext, this, [options]);\n  } else {\n    return realRunInThisContext.call(this, options);\n  }\n};\n\nScript.prototype.runInContext = function(contextifiedSandbox, options) {\n  if (options && options.breakOnSigint && process._events.SIGINT) {\n    return sigintHandlersWrap(realRunInContext, this,\n                              [contextifiedSandbox, options]);\n  } else {\n    return realRunInContext.call(this, contextifiedSandbox, options);\n  }\n};\n\nScript.prototype.runInNewContext = function(sandbox, options) {\n  var context = createContext(sandbox);\n  return this.runInContext(context, options);\n};\n\nfunction createContext(sandbox) {\n  if (sandbox === undefined) {\n    sandbox = {};\n  } else if (binding.isContext(sandbox)) {\n    return sandbox;\n  }\n\n  binding.makeContext(sandbox);\n  return sandbox;\n}\n\nfunction createScript(code, options) {\n  return new Script(code, options);\n}\n\n// Remove all SIGINT listeners and re-attach them after the wrapped function\n// has executed, so that caught SIGINT are handled by the listeners again.\nfunction sigintHandlersWrap(fn, thisArg, argsArray) {\n  // Using the internal list here to make sure `.once()` wrappers are used,\n  // not the original ones.\n  let sigintListeners = process._events.SIGINT;\n\n  if (Array.isArray(sigintListeners))\n    sigintListeners = sigintListeners.slice();\n  else\n    sigintListeners = [sigintListeners];\n\n  process.removeAllListeners('SIGINT');\n\n  try {\n    return fn.apply(thisArg, argsArray);\n  } finally {\n    // Add using the public methods so that the `newListener` handler of\n    // process can re-attach the listeners.\n    for (const listener of sigintListeners) {\n      process.addListener('SIGINT', listener);\n    }\n  }\n}\n\nfunction runInDebugContext(code) {\n  return binding.runInDebugContext(code);\n}\n\nfunction runInContext(code, contextifiedSandbox, options) {\n  return createScript(code, options)\n    .runInContext(contextifiedSandbox, options);\n}\n\nfunction runInNewContext(code, sandbox, options) {\n  return createScript(code, options).runInNewContext(sandbox, options);\n}\n\nfunction runInThisContext(code, options) {\n  return createScript(code, options).runInThisContext(options);\n}\n\nmodule.exports = {\n  Script,\n  createContext,\n  createScript,\n  runInDebugContext,\n  runInContext,\n  runInNewContext,\n  runInThisContext,\n  isContext: binding.isContext\n};\n\n});"},
    {"fileId":32, "filename":"internal/fs.js", "source":"(function (exports, require, module, __filename, __dirname) { 'use strict';\n\nconst Buffer = require('buffer').Buffer;\nconst Writable = require('stream').Writable;\nconst fs = require('fs');\nconst util = require('util');\n\nconst {\n  O_APPEND,\n  O_CREAT,\n  O_EXCL,\n  O_RDONLY,\n  O_RDWR,\n  O_SYNC,\n  O_TRUNC,\n  O_WRONLY\n} = process.binding('constants').fs;\n\nfunction assertEncoding(encoding) {\n  if (encoding && !Buffer.isEncoding(encoding)) {\n    throw new Error(`Unknown encoding: ${encoding}`);\n  }\n}\n\nfunction stringToFlags(flag) {\n  if (typeof flag === 'number') {\n    return flag;\n  }\n\n  switch (flag) {\n    case 'r' : return O_RDONLY;\n    case 'rs' : // Fall through.\n    case 'sr' : return O_RDONLY | O_SYNC;\n    case 'r+' : return O_RDWR;\n    case 'rs+' : // Fall through.\n    case 'sr+' : return O_RDWR | O_SYNC;\n\n    case 'w' : return O_TRUNC | O_CREAT | O_WRONLY;\n    case 'wx' : // Fall through.\n    case 'xw' : return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;\n\n    case 'w+' : return O_TRUNC | O_CREAT | O_RDWR;\n    case 'wx+': // Fall through.\n    case 'xw+': return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;\n\n    case 'a' : return O_APPEND | O_CREAT | O_WRONLY;\n    case 'ax' : // Fall through.\n    case 'xa' : return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;\n\n    case 'a+' : return O_APPEND | O_CREAT | O_RDWR;\n    case 'ax+': // Fall through.\n    case 'xa+': return O_APPEND | O_CREAT | O_RDWR | O_EXCL;\n  }\n\n  throw new Error('Unknown file open flag: ' + flag);\n}\n\n// Temporary hack for process.stdout and process.stderr when piped to files.\nfunction SyncWriteStream(fd, options) {\n  Writable.call(this);\n\n  options = options || {};\n\n  this.fd = fd;\n  this.readable = false;\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n\n  this.on('end', () => this._destroy());\n}\n\nutil.inherits(SyncWriteStream, Writable);\n\nSyncWriteStream.prototype._write = function(chunk, encoding, cb) {\n  fs.writeSync(this.fd, chunk, 0, chunk.length);\n  cb();\n  return true;\n};\n\nSyncWriteStream.prototype._destroy = function() {\n  if (this.fd === null) // already destroy()ed\n    return;\n\n  if (this.autoClose)\n    fs.closeSync(this.fd);\n\n  this.fd = null;\n  return true;\n};\n\nSyncWriteStream.prototype.destroySoon =\nSyncWriteStream.prototype.destroy = function() {\n  this._destroy();\n  this.emit('close');\n  return true;\n};\n\nmodule.exports = {\n  assertEncoding,\n  stringToFlags,\n  SyncWriteStream,\n  realpathCacheKey: Symbol('realpathCacheKey')\n};\n\n});"},
    {"fileId":33, "filename":"internal/streams/destroy.js", "source":"(function (exports, require, module, __filename, __dirname) { 'use strict';\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  const readableDestroyed = this._readableState &&\n    this._readableState.destroyed;\n  const writableDestroyed = this._writableState &&\n    this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err &&\n               (!this._writableState || !this._writableState.errorEmitted)) {\n      process.nextTick(emitErrorNT, this, err);\n    }\n    return;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, (err) => {\n    if (!cb && err) {\n      process.nextTick(emitErrorNT, this, err);\n      if (this._writableState) {\n        this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy,\n  undestroy\n};\n\n});"},
    {"fileId":34, "filename":"internal/streams/legacy.js", "source":"(function (exports, require, module, __filename, __dirname) { 'use strict';\n\nconst EE = require('events');\nconst util = require('util');\n\nfunction Stream() {\n  EE.call(this);\n}\nutil.inherits(Stream, EE);\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\nmodule.exports = Stream;\n\n});"},
    {"fileId":35, "filename":"/Users/jacksongl/Desktop/tree/mem-vis-pack/tests/crypto.js", "source":"(function (exports, require, module, __filename, __dirname) { \n\nsetTimeout(() => {}, 0);\nsetTimeout(function() {\n    /*\n * Copyright (c) 2003-2005  Tom Wu\n * All Rights Reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS-IS\" AND WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY\n * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n *\n * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,\n * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER\n * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF\n * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT\n * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n * In addition, the following condition applies:\n *\n * All redistributions must retain an intact copy of this copyright notice\n * and disclaimer.\n */\n\n    // The code has been adapted for use as a benchmark by Google.\n\n    // Basic JavaScript BN library - subset useful for RSA encryption.\n\n    // Bits per digit\n    var dbits;\n    var BI_DB;\n    var BI_DM;\n    var BI_DV;\n\n    var BI_FP;\n    var BI_FV;\n    var BI_F1;\n    var BI_F2;\n\n    // JavaScript engine analysis\n    var canary = 0xdeadbeefcafe;\n    var j_lm = (canary & 0xffffff) == 0xefcafe;\n\n    // (public) Constructor\n    function BigInteger(a, b, c) {\n        this.array = new Array();\n        if (a != null)\n            if ('number' == typeof a) this.fromNumber(a, b, c);\n            else if (b == null && 'string' != typeof a) this.fromString(a, 256);\n            else this.fromString(a, b);\n    }\n\n    // return new, unset BigInteger\n    function nbi() {\n        return new BigInteger(null);\n    }\n\n    // am: Compute w_j += (x*this_i), propagate carries,\n    // c is initial carry, returns final carry.\n    // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n    // We need to select the fastest one that works in this environment.\n\n    // am1: use a single mult and divide to get the high bits,\n    // max digit bits should be 26 because\n    // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n    function am1(i, x, w, j, c, n) {\n        var this_array = this.array;\n        var w_array = w.array;\n        while (--n >= 0) {\n            var v = x * this_array[i++] + w_array[j] + c;\n            c = Math.floor(v / 0x4000000);\n            w_array[j++] = v & 0x3ffffff;\n        }\n        return c;\n    }\n\n    // am2 avoids a big mult-and-extract completely.\n    // Max digit bits should be <= 30 because we do bitwise ops\n    // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n    function am2(i, x, w, j, c, n) {\n        var this_array = this.array;\n        var w_array = w.array;\n        var xl = x & 0x7fff, xh = x >> 15;\n        while (--n >= 0) {\n            var l = this_array[i] & 0x7fff;\n            var h = this_array[i++] >> 15;\n            var m = xh * l + h * xl;\n            l = xl * l + ((m & 0x7fff) << 15) + w_array[j] + (c & 0x3fffffff);\n            c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n            w_array[j++] = l & 0x3fffffff;\n        }\n        return c;\n    }\n\n    // Alternately, set max digit bits to 28 since some\n    // browsers slow down when dealing with 32-bit numbers.\n    function am3(i, x, w, j, c, n) {\n        var this_array = this.array;\n        var w_array = w.array;\n\n        var xl = x & 0x3fff, xh = x >> 14;\n        while (--n >= 0) {\n            var l = this_array[i] & 0x3fff;\n            var h = this_array[i++] >> 14;\n            var m = xh * l + h * xl;\n            l = xl * l + ((m & 0x3fff) << 14) + w_array[j] + c;\n            c = (l >> 28) + (m >> 14) + xh * h;\n            w_array[j++] = l & 0xfffffff;\n        }\n        return c;\n    }\n\n    // This is tailored to VMs with 2-bit tagging. It makes sure\n    // that all the computations stay within the 29 bits available.\n    function am4(i, x, w, j, c, n) {\n        var this_array = this.array;\n        var w_array = w.array;\n\n        var xl = x & 0x1fff, xh = x >> 13;\n        while (--n >= 0) {\n            var l = this_array[i] & 0x1fff;\n            var h = this_array[i++] >> 13;\n            var m = xh * l + h * xl;\n            l = xl * l + ((m & 0x1fff) << 13) + w_array[j] + c;\n            c = (l >> 26) + (m >> 13) + xh * h;\n            w_array[j++] = l & 0x3ffffff;\n        }\n        return c;\n    }\n\n    // am3/28 is best for SM, Rhino, but am4/26 is best for v8.\n    // Kestrel (Opera 9.5) gets its best result with am4/26.\n    // IE7 does 9% better with am3/28 than with am4/26.\n    // Firefox (SM) gets 10% faster with am3/28 than with am4/26.\n\n    setupEngine = function(fn, bits) {\n        BigInteger.prototype.am = fn;\n        dbits = bits;\n\n        BI_DB = dbits;\n        BI_DM = (1 << dbits) - 1;\n        BI_DV = 1 << dbits;\n\n        BI_FP = 52;\n        BI_FV = Math.pow(2, BI_FP);\n        BI_F1 = BI_FP - dbits;\n        BI_F2 = 2 * dbits - BI_FP;\n    };\n\n    // Digit conversions\n    var BI_RM = '0123456789abcdefghijklmnopqrstuvwxyz';\n    var BI_RC = new Array();\n    var rr, vv;\n    rr = '0'.charCodeAt(0);\n    for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n    rr = 'a'.charCodeAt(0);\n    for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n    rr = 'A'.charCodeAt(0);\n    for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\n    function int2char(n) {\n        return BI_RM.charAt(n);\n    }\n    function intAt(s, i) {\n        var c = BI_RC[s.charCodeAt(i)];\n        return c == null ? -1 : c;\n    }\n\n    // (protected) copy this to r\n    function bnpCopyTo(r) {\n        var this_array = this.array;\n        var r_array = r.array;\n\n        for (var i = this.t - 1; i >= 0; --i) r_array[i] = this_array[i];\n        r.t = this.t;\n        r.s = this.s;\n    }\n\n    // (protected) set from integer value x, -DV <= x < DV\n    function bnpFromInt(x) {\n        var this_array = this.array;\n        this.t = 1;\n        this.s = x < 0 ? -1 : 0;\n        if (x > 0) this_array[0] = x;\n        else if (x < -1) this_array[0] = x + DV;\n        else this.t = 0;\n    }\n\n    // return bigint initialized to value\n    function nbv(i) {\n        var r = nbi();\n        r.fromInt(i);\n        return r;\n    }\n\n    // (protected) set from string and radix\n    function bnpFromString(s, b) {\n        var this_array = this.array;\n        var k;\n        if (b == 16) k = 4;\n        else if (b == 8) k = 3;\n        else if (b == 256) k = 8;\n        else if (b == 2)\n            // byte array\n            k = 1;\n        else if (b == 32) k = 5;\n        else if (b == 4) k = 2;\n        else {\n            this.fromRadix(s, b);\n            return;\n        }\n        this.t = 0;\n        this.s = 0;\n        var i = s.length, mi = false, sh = 0;\n        while (--i >= 0) {\n            var x = k == 8 ? s[i] & 0xff : intAt(s, i);\n            if (x < 0) {\n                if (s.charAt(i) == '-') mi = true;\n                continue;\n            }\n            mi = false;\n            if (sh == 0) this_array[this.t++] = x;\n            else if (sh + k > BI_DB) {\n                this_array[this.t - 1] |= (x & ((1 << (BI_DB - sh)) - 1)) << sh;\n                this_array[this.t++] = x >> (BI_DB - sh);\n            } else this_array[this.t - 1] |= x << sh;\n            sh += k;\n            if (sh >= BI_DB) sh -= BI_DB;\n        }\n        if (k == 8 && (s[0] & 0x80) != 0) {\n            this.s = -1;\n            if (sh > 0)\n                this_array[this.t - 1] |= ((1 << (BI_DB - sh)) - 1) << sh;\n        }\n        this.clamp();\n        if (mi) BigInteger.ZERO.subTo(this, this);\n    }\n\n    // (protected) clamp off excess high words\n    function bnpClamp() {\n        var this_array = this.array;\n        var c = this.s & BI_DM;\n        while (this.t > 0 && this_array[this.t - 1] == c) --this.t;\n    }\n\n    // (public) return string representation in given radix\n    function bnToString(b) {\n        var this_array = this.array;\n        if (this.s < 0) return '-' + this.negate().toString(b);\n        var k;\n        if (b == 16) k = 4;\n        else if (b == 8) k = 3;\n        else if (b == 2) k = 1;\n        else if (b == 32) k = 5;\n        else if (b == 4) k = 2;\n        else return this.toRadix(b);\n        var km = (1 << k) - 1, d, m = false, r = '', i = this.t;\n        var p = BI_DB - i * BI_DB % k;\n        if (i-- > 0) {\n            if (p < BI_DB && (d = this_array[i] >> p) > 0) {\n                m = true;\n                r = int2char(d);\n            }\n            while (i >= 0) {\n                if (p < k) {\n                    d = (this_array[i] & ((1 << p) - 1)) << (k - p);\n                    d |= this_array[--i] >> (p += BI_DB - k);\n                } else {\n                    d = (this_array[i] >> (p -= k)) & km;\n                    if (p <= 0) {\n                        p += BI_DB;\n                        --i;\n                    }\n                }\n                if (d > 0) m = true;\n                if (m) r += int2char(d);\n            }\n        }\n        return m ? r : '0';\n    }\n\n    // (public) -this\n    function bnNegate() {\n        var r = nbi();\n        BigInteger.ZERO.subTo(this, r);\n        return r;\n    }\n\n    // (public) |this|\n    function bnAbs() {\n        return this.s < 0 ? this.negate() : this;\n    }\n\n    // (public) return + if this > a, - if this < a, 0 if equal\n    function bnCompareTo(a) {\n        var this_array = this.array;\n        var a_array = a.array;\n\n        var r = this.s - a.s;\n        if (r != 0) return r;\n        var i = this.t;\n        r = i - a.t;\n        if (r != 0) return r;\n        while (--i >= 0) if ((r = this_array[i] - a_array[i]) != 0) return r;\n        return 0;\n    }\n\n    // returns bit length of the integer x\n    function nbits(x) {\n        var r = 1, t;\n        if ((t = x >>> 16) != 0) {\n            x = t;\n            r += 16;\n        }\n        if ((t = x >> 8) != 0) {\n            x = t;\n            r += 8;\n        }\n        if ((t = x >> 4) != 0) {\n            x = t;\n            r += 4;\n        }\n        if ((t = x >> 2) != 0) {\n            x = t;\n            r += 2;\n        }\n        if ((t = x >> 1) != 0) {\n            x = t;\n            r += 1;\n        }\n        return r;\n    }\n\n    // (public) return the number of bits in \"this\"\n    function bnBitLength() {\n        var this_array = this.array;\n        if (this.t <= 0) return 0;\n        return (\n            BI_DB * (this.t - 1) +\n            nbits(this_array[this.t - 1] ^ (this.s & BI_DM))\n        );\n    }\n\n    // (protected) r = this << n*DB\n    function bnpDLShiftTo(n, r) {\n        var this_array = this.array;\n        var r_array = r.array;\n        var i;\n        for (i = this.t - 1; i >= 0; --i) r_array[i + n] = this_array[i];\n        for (i = n - 1; i >= 0; --i) r_array[i] = 0;\n        r.t = this.t + n;\n        r.s = this.s;\n    }\n\n    // (protected) r = this >> n*DB\n    function bnpDRShiftTo(n, r) {\n        var this_array = this.array;\n        var r_array = r.array;\n        for (var i = n; i < this.t; ++i) r_array[i - n] = this_array[i];\n        r.t = Math.max(this.t - n, 0);\n        r.s = this.s;\n    }\n\n    // (protected) r = this << n\n    function bnpLShiftTo(n, r) {\n        var this_array = this.array;\n        var r_array = r.array;\n        var bs = n % BI_DB;\n        var cbs = BI_DB - bs;\n        var bm = (1 << cbs) - 1;\n        var ds = Math.floor(n / BI_DB), c = (this.s << bs) & BI_DM, i;\n        for (i = this.t - 1; i >= 0; --i) {\n            r_array[i + ds + 1] = (this_array[i] >> cbs) | c;\n            c = (this_array[i] & bm) << bs;\n        }\n        for (i = ds - 1; i >= 0; --i) r_array[i] = 0;\n        r_array[ds] = c;\n        r.t = this.t + ds + 1;\n        r.s = this.s;\n        r.clamp();\n    }\n\n    // (protected) r = this >> n\n    function bnpRShiftTo(n, r) {\n        var this_array = this.array;\n        var r_array = r.array;\n        r.s = this.s;\n        var ds = Math.floor(n / BI_DB);\n        if (ds >= this.t) {\n            r.t = 0;\n            return;\n        }\n        var bs = n % BI_DB;\n        var cbs = BI_DB - bs;\n        var bm = (1 << bs) - 1;\n        r_array[0] = this_array[ds] >> bs;\n        for (var i = ds + 1; i < this.t; ++i) {\n            r_array[i - ds - 1] |= (this_array[i] & bm) << cbs;\n            r_array[i - ds] = this_array[i] >> bs;\n        }\n        if (bs > 0) r_array[this.t - ds - 1] |= (this.s & bm) << cbs;\n        r.t = this.t - ds;\n        r.clamp();\n    }\n\n    // (protected) r = this - a\n    function bnpSubTo(a, r) {\n        var this_array = this.array;\n        var r_array = r.array;\n        var a_array = a.array;\n        var i = 0, c = 0, m = Math.min(a.t, this.t);\n        while (i < m) {\n            c += this_array[i] - a_array[i];\n            r_array[i++] = c & BI_DM;\n            c >>= BI_DB;\n        }\n        if (a.t < this.t) {\n            c -= a.s;\n            while (i < this.t) {\n                c += this_array[i];\n                r_array[i++] = c & BI_DM;\n                c >>= BI_DB;\n            }\n            c += this.s;\n        } else {\n            c += this.s;\n            while (i < a.t) {\n                c -= a_array[i];\n                r_array[i++] = c & BI_DM;\n                c >>= BI_DB;\n            }\n            c -= a.s;\n        }\n        r.s = c < 0 ? -1 : 0;\n        if (c < -1) r_array[i++] = BI_DV + c;\n        else if (c > 0) r_array[i++] = c;\n        r.t = i;\n        r.clamp();\n    }\n\n    // (protected) r = this * a, r != this,a (HAC 14.12)\n    // \"this\" should be the larger one if appropriate.\n    function bnpMultiplyTo(a, r) {\n        var this_array = this.array;\n        var r_array = r.array;\n        var x = this.abs(), y = a.abs();\n        var y_array = y.array;\n\n        var i = x.t;\n        r.t = i + y.t;\n        while (--i >= 0) r_array[i] = 0;\n        for (\n            i = 0;\n            i < y.t;\n            ++i\n        ) r_array[i + x.t] = x.am(0, y_array[i], r, i, 0, x.t);\n        r.s = 0;\n        r.clamp();\n        if (this.s != a.s) BigInteger.ZERO.subTo(r, r);\n    }\n\n    // (protected) r = this^2, r != this (HAC 14.16)\n    function bnpSquareTo(r) {\n        var x = this.abs();\n        var x_array = x.array;\n        var r_array = r.array;\n\n        var i = (r.t = 2 * x.t);\n        while (--i >= 0) r_array[i] = 0;\n        for (i = 0; i < x.t - 1; ++i) {\n            var c = x.am(i, x_array[i], r, 2 * i, 0, 1);\n            if (\n                (r_array[i + x.t] += x.am(\n                    i + 1,\n                    2 * x_array[i],\n                    r,\n                    2 * i + 1,\n                    c,\n                    x.t - i - 1\n                )) >= BI_DV\n            ) {\n                r_array[i + x.t] -= BI_DV;\n                r_array[i + x.t + 1] = 1;\n            }\n        }\n        if (r.t > 0) r_array[r.t - 1] += x.am(i, x_array[i], r, 2 * i, 0, 1);\n        r.s = 0;\n        r.clamp();\n    }\n\n    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n    // r != q, this != m.  q or r may be null.\n    function bnpDivRemTo(m, q, r) {\n        var pm = m.abs();\n        if (pm.t <= 0) return;\n        var pt = this.abs();\n        if (pt.t < pm.t) {\n            if (q != null) q.fromInt(0);\n            if (r != null) this.copyTo(r);\n            return;\n        }\n        if (r == null) r = nbi();\n        var y = nbi(), ts = this.s, ms = m.s;\n        var pm_array = pm.array;\n        var nsh = BI_DB - nbits(pm_array[pm.t - 1]); // normalize modulus\n        if (nsh > 0) {\n            pm.lShiftTo(nsh, y);\n            pt.lShiftTo(nsh, r);\n        } else {\n            pm.copyTo(y);\n            pt.copyTo(r);\n        }\n        var ys = y.t;\n\n        var y_array = y.array;\n        var y0 = y_array[ys - 1];\n        if (y0 == 0) return;\n        var yt = y0 * (1 << BI_F1) + (ys > 1 ? y_array[ys - 2] >> BI_F2 : 0);\n        var d1 = BI_FV / yt, d2 = (1 << BI_F1) / yt, e = 1 << BI_F2;\n        var i = r.t, j = i - ys, t = q == null ? nbi() : q;\n        y.dlShiftTo(j, t);\n\n        var r_array = r.array;\n        if (r.compareTo(t) >= 0) {\n            r_array[r.t++] = 1;\n            r.subTo(t, r);\n        }\n        BigInteger.ONE.dlShiftTo(ys, t);\n        t.subTo(y, y); // \"negative\" y so we can replace sub with am later\n        while (y.t < ys) y_array[y.t++] = 0;\n        while (--j >= 0) {\n            // Estimate quotient digit\n            var qd = r_array[--i] == y0\n                ? BI_DM\n                : Math.floor(r_array[i] * d1 + (r_array[i - 1] + e) * d2);\n            if ((r_array[i] += y.am(0, qd, r, j, 0, ys)) < qd) {\n                // Try it out\n                y.dlShiftTo(j, t);\n                r.subTo(t, r);\n                while (r_array[i] < --qd)\n                    r.subTo(t, r);\n            }\n        }\n        if (q != null) {\n            r.drShiftTo(ys, q);\n            if (ts != ms) BigInteger.ZERO.subTo(q, q);\n        }\n        r.t = ys;\n        r.clamp();\n        if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder\n        if (ts < 0) BigInteger.ZERO.subTo(r, r);\n    }\n\n    // (public) this mod a\n    function bnMod(a) {\n        var r = nbi();\n        this.abs().divRemTo(a, null, r);\n        if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);\n        return r;\n    }\n\n    // Modular reduction using \"classic\" algorithm\n    function Classic(m) {\n        this.m = m;\n    }\n    function cConvert(x) {\n        if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n        else return x;\n    }\n    function cRevert(x) {\n        return x;\n    }\n    function cReduce(x) {\n        x.divRemTo(this.m, null, x);\n    }\n    function cMulTo(x, y, r) {\n        x.multiplyTo(y, r);\n        this.reduce(r);\n    }\n    function cSqrTo(x, r) {\n        x.squareTo(r);\n        this.reduce(r);\n    }\n\n    Classic.prototype.convert = cConvert;\n    Classic.prototype.revert = cRevert;\n    Classic.prototype.reduce = cReduce;\n    Classic.prototype.mulTo = cMulTo;\n    Classic.prototype.sqrTo = cSqrTo;\n\n    // (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n    // justification:\n    //         xy == 1 (mod m)\n    //         xy =  1+km\n    //   xy(2-xy) = (1+km)(1-km)\n    // x[y(2-xy)] = 1-k^2m^2\n    // x[y(2-xy)] == 1 (mod m^2)\n    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n    // JS multiply \"overflows\" differently from C/C++, so care is needed here.\n    function bnpInvDigit() {\n        var this_array = this.array;\n        if (this.t < 1) return 0;\n        var x = this_array[0];\n        if ((x & 1) == 0) return 0;\n        var y = x & 3; // y == 1/x mod 2^2\n        y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4\n        y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8\n        y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16\n        // last step - calculate inverse mod DV directly;\n        // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n        y = y * (2 - x * y % BI_DV) % BI_DV; // y == 1/x mod 2^dbits\n        // we really want the negative inverse, and -DV < y < DV\n        return y > 0 ? BI_DV - y : -y;\n    }\n\n    // Montgomery reduction\n    function Montgomery(m) {\n        this.m = m;\n        this.mp = m.invDigit();\n        this.mpl = this.mp & 0x7fff;\n        this.mph = this.mp >> 15;\n        this.um = (1 << (BI_DB - 15)) - 1;\n        this.mt2 = 2 * m.t;\n    }\n\n    // xR mod m\n    function montConvert(x) {\n        var r = nbi();\n        x.abs().dlShiftTo(this.m.t, r);\n        r.divRemTo(this.m, null, r);\n        if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);\n        return r;\n    }\n\n    // x/R mod m\n    function montRevert(x) {\n        var r = nbi();\n        x.copyTo(r);\n        this.reduce(r);\n        return r;\n    }\n\n    // x = x/R mod m (HAC 14.32)\n    function montReduce(x) {\n        var x_array = x.array;\n        while (\n            x.t <= this.mt2 // pad x so am has enough room later\n        ) x_array[x.t++] = 0;\n        for (var i = 0; i < this.m.t; ++i) {\n            // faster way of calculating u0 = x[i]*mp mod DV\n            var j = x_array[i] & 0x7fff;\n            var u0 =\n                (j * this.mpl +\n                    (((j * this.mph + (x_array[i] >> 15) * this.mpl) &\n                        this.um) <<\n                        15)) &\n                BI_DM;\n            // use am to combine the multiply-shift-add into one call\n            j = i + this.m.t;\n            x_array[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n            // propagate carry\n            while (x_array[j] >= BI_DV) {\n                x_array[j] -= BI_DV;\n                x_array[++j]++;\n            }\n        }\n        x.clamp();\n        x.drShiftTo(this.m.t, x);\n        if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n    }\n\n    // r = \"x^2/R mod m\"; x != r\n    function montSqrTo(x, r) {\n        x.squareTo(r);\n        this.reduce(r);\n    }\n\n    // r = \"xy/R mod m\"; x,y != r\n    function montMulTo(x, y, r) {\n        x.multiplyTo(y, r);\n        this.reduce(r);\n    }\n\n    Montgomery.prototype.convert = montConvert;\n    Montgomery.prototype.revert = montRevert;\n    Montgomery.prototype.reduce = montReduce;\n    Montgomery.prototype.mulTo = montMulTo;\n    Montgomery.prototype.sqrTo = montSqrTo;\n\n    // (protected) true iff this is even\n    function bnpIsEven() {\n        var this_array = this.array;\n        return (this.t > 0 ? this_array[0] & 1 : this.s) == 0;\n    }\n\n    // (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n    function bnpExp(e, z) {\n        if (e > 0xffffffff || e < 1) return BigInteger.ONE;\n        var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;\n        g.copyTo(r);\n        while (--i >= 0) {\n            z.sqrTo(r, r2);\n            if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);\n            else {\n                var t = r;\n                r = r2;\n                r2 = t;\n            }\n        }\n        return z.revert(r);\n    }\n\n    // (public) this^e % m, 0 <= e < 2^32\n    function bnModPowInt(e, m) {\n        var z;\n        if (e < 256 || m.isEven()) z = new Classic(m);\n        else z = new Montgomery(m);\n        return this.exp(e, z);\n    }\n\n    // protected\n    BigInteger.prototype.copyTo = bnpCopyTo;\n    BigInteger.prototype.fromInt = bnpFromInt;\n    BigInteger.prototype.fromString = bnpFromString;\n    BigInteger.prototype.clamp = bnpClamp;\n    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n    BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n    BigInteger.prototype.lShiftTo = bnpLShiftTo;\n    BigInteger.prototype.rShiftTo = bnpRShiftTo;\n    BigInteger.prototype.subTo = bnpSubTo;\n    BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n    BigInteger.prototype.squareTo = bnpSquareTo;\n    BigInteger.prototype.divRemTo = bnpDivRemTo;\n    BigInteger.prototype.invDigit = bnpInvDigit;\n    BigInteger.prototype.isEven = bnpIsEven;\n    BigInteger.prototype.exp = bnpExp;\n\n    // public\n    BigInteger.prototype.toString = bnToString;\n    BigInteger.prototype.negate = bnNegate;\n    BigInteger.prototype.abs = bnAbs;\n    BigInteger.prototype.compareTo = bnCompareTo;\n    BigInteger.prototype.bitLength = bnBitLength;\n    BigInteger.prototype.mod = bnMod;\n    BigInteger.prototype.modPowInt = bnModPowInt;\n\n    // \"constants\"\n    BigInteger.ZERO = nbv(0);\n    BigInteger.ONE = nbv(1);\n    // Copyright (c) 2005  Tom Wu\n    // All Rights Reserved.\n    // See \"LICENSE\" for details.\n\n    // Extended JavaScript BN functions, required for RSA private ops.\n\n    // (public)\n    function bnClone() {\n        var r = nbi();\n        this.copyTo(r);\n        return r;\n    }\n\n    // (public) return value as integer\n    function bnIntValue() {\n        var this_array = this.array;\n        if (this.s < 0) {\n            if (this.t == 1) return this_array[0] - BI_DV;\n            else if (this.t == 0) return -1;\n        } else if (this.t == 1) return this_array[0];\n        else if (this.t == 0) return 0;\n        // assumes 16 < DB < 32\n        return (\n            ((this_array[1] & ((1 << (32 - BI_DB)) - 1)) << BI_DB) |\n            this_array[0]\n        );\n    }\n\n    // (public) return value as byte\n    function bnByteValue() {\n        var this_array = this.array;\n        return this.t == 0 ? this.s : this_array[0] << 24 >> 24;\n    }\n\n    // (public) return value as short (assumes DB>=16)\n    function bnShortValue() {\n        var this_array = this.array;\n        return this.t == 0 ? this.s : this_array[0] << 16 >> 16;\n    }\n\n    // (protected) return x s.t. r^x < DV\n    function bnpChunkSize(r) {\n        return Math.floor(Math.LN2 * BI_DB / Math.log(r));\n    }\n\n    // (public) 0 if this == 0, 1 if this > 0\n    function bnSigNum() {\n        var this_array = this.array;\n        if (this.s < 0) return -1;\n        else if (this.t <= 0 || (this.t == 1 && this_array[0] <= 0)) return 0;\n        else return 1;\n    }\n\n    // (protected) convert to radix string\n    function bnpToRadix(b) {\n        if (b == null) b = 10;\n        if (this.signum() == 0 || b < 2 || b > 36) return '0';\n        var cs = this.chunkSize(b);\n        var a = Math.pow(b, cs);\n        var d = nbv(a), y = nbi(), z = nbi(), r = '';\n        this.divRemTo(d, y, z);\n        while (y.signum() > 0) {\n            r = (a + z.intValue()).toString(b).substr(1) + r;\n            y.divRemTo(d, y, z);\n        }\n        return z.intValue().toString(b) + r;\n    }\n\n    // (protected) convert from radix string\n    function bnpFromRadix(s, b) {\n        this.fromInt(0);\n        if (b == null) b = 10;\n        var cs = this.chunkSize(b);\n        var d = Math.pow(b, cs), mi = false, j = 0, w = 0;\n        for (var i = 0; i < s.length; ++i) {\n            var x = intAt(s, i);\n            if (x < 0) {\n                if (s.charAt(i) == '-' && this.signum() == 0) mi = true;\n                continue;\n            }\n            w = b * w + x;\n            if (++j >= cs) {\n                this.dMultiply(d);\n                this.dAddOffset(w, 0);\n                j = 0;\n                w = 0;\n            }\n        }\n        if (j > 0) {\n            this.dMultiply(Math.pow(b, j));\n            this.dAddOffset(w, 0);\n        }\n        if (mi) BigInteger.ZERO.subTo(this, this);\n    }\n\n    // (protected) alternate constructor\n    function bnpFromNumber(a, b, c) {\n        if ('number' == typeof b) {\n            // new BigInteger(int,int,RNG)\n            if (a < 2) this.fromInt(1);\n            else {\n                this.fromNumber(a, c);\n                if (\n                    !this.testBit(a - 1) // force MSB set\n                )\n                    this.bitwiseTo(\n                        BigInteger.ONE.shiftLeft(a - 1),\n                        op_or,\n                        this\n                    );\n                if (this.isEven()) this.dAddOffset(1, 0); // force odd\n                while (!this.isProbablePrime(b)) {\n                    this.dAddOffset(2, 0);\n                    if (this.bitLength() > a)\n                        this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\n                }\n            }\n        } else {\n            // new BigInteger(int,RNG)\n            var x = new Array(), t = a & 7;\n            x.length = (a >> 3) + 1;\n            b.nextBytes(x);\n            if (t > 0) x[0] &= (1 << t) - 1;\n            else x[0] = 0;\n            this.fromString(x, 256);\n        }\n    }\n\n    // (public) convert to bigendian byte array\n    function bnToByteArray() {\n        var this_array = this.array;\n        var i = this.t, r = new Array();\n        r[0] = this.s;\n        var p = BI_DB - i * BI_DB % 8, d, k = 0;\n        if (i-- > 0) {\n            if (p < BI_DB && (d = this_array[i] >> p) != (this.s & BI_DM) >> p)\n                r[k++] = d | (this.s << (BI_DB - p));\n            while (i >= 0) {\n                if (p < 8) {\n                    d = (this_array[i] & ((1 << p) - 1)) << (8 - p);\n                    d |= this_array[--i] >> (p += BI_DB - 8);\n                } else {\n                    d = (this_array[i] >> (p -= 8)) & 0xff;\n                    if (p <= 0) {\n                        p += BI_DB;\n                        --i;\n                    }\n                }\n                if ((d & 0x80) != 0) d |= -256;\n                if (k == 0 && (this.s & 0x80) != (d & 0x80)) ++k;\n                if (k > 0 || d != this.s) r[k++] = d;\n            }\n        }\n        return r;\n    }\n\n    function bnEquals(a) {\n        return this.compareTo(a) == 0;\n    }\n    function bnMin(a) {\n        return this.compareTo(a) < 0 ? this : a;\n    }\n    function bnMax(a) {\n        return this.compareTo(a) > 0 ? this : a;\n    }\n\n    // (protected) r = this op a (bitwise)\n    function bnpBitwiseTo(a, op, r) {\n        var this_array = this.array;\n        var a_array = a.array;\n        var r_array = r.array;\n        var i, f, m = Math.min(a.t, this.t);\n        for (i = 0; i < m; ++i) r_array[i] = op(this_array[i], a_array[i]);\n        if (a.t < this.t) {\n            f = a.s & BI_DM;\n            for (i = m; i < this.t; ++i)\n                r_array[i] = op(this_array[i], f);\n            r.t = this.t;\n        } else {\n            f = this.s & BI_DM;\n            for (i = m; i < a.t; ++i)\n                r_array[i] = op(f, a_array[i]);\n            r.t = a.t;\n        }\n        r.s = op(this.s, a.s);\n        r.clamp();\n    }\n\n    // (public) this & a\n    function op_and(x, y) {\n        return x & y;\n    }\n    function bnAnd(a) {\n        var r = nbi();\n        this.bitwiseTo(a, op_and, r);\n        return r;\n    }\n\n    // (public) this | a\n    function op_or(x, y) {\n        return x | y;\n    }\n    function bnOr(a) {\n        var r = nbi();\n        this.bitwiseTo(a, op_or, r);\n        return r;\n    }\n\n    // (public) this ^ a\n    function op_xor(x, y) {\n        return x ^ y;\n    }\n    function bnXor(a) {\n        var r = nbi();\n        this.bitwiseTo(a, op_xor, r);\n        return r;\n    }\n\n    // (public) this & ~a\n    function op_andnot(x, y) {\n        return x & ~y;\n    }\n    function bnAndNot(a) {\n        var r = nbi();\n        this.bitwiseTo(a, op_andnot, r);\n        return r;\n    }\n\n    // (public) ~this\n    function bnNot() {\n        var this_array = this.array;\n        var r = nbi();\n        var r_array = r.array;\n\n        for (var i = 0; i < this.t; ++i) r_array[i] = BI_DM & ~this_array[i];\n        r.t = this.t;\n        r.s = ~this.s;\n        return r;\n    }\n\n    // (public) this << n\n    function bnShiftLeft(n) {\n        var r = nbi();\n        if (n < 0) this.rShiftTo(-n, r);\n        else this.lShiftTo(n, r);\n        return r;\n    }\n\n    // (public) this >> n\n    function bnShiftRight(n) {\n        var r = nbi();\n        if (n < 0) this.lShiftTo(-n, r);\n        else this.rShiftTo(n, r);\n        return r;\n    }\n\n    // return index of lowest 1-bit in x, x < 2^31\n    function lbit(x) {\n        if (x == 0) return -1;\n        var r = 0;\n        if ((x & 0xffff) == 0) {\n            x >>= 16;\n            r += 16;\n        }\n        if ((x & 0xff) == 0) {\n            x >>= 8;\n            r += 8;\n        }\n        if ((x & 0xf) == 0) {\n            x >>= 4;\n            r += 4;\n        }\n        if ((x & 3) == 0) {\n            x >>= 2;\n            r += 2;\n        }\n        if ((x & 1) == 0) ++r;\n        return r;\n    }\n\n    // (public) returns index of lowest 1-bit (or -1 if none)\n    function bnGetLowestSetBit() {\n        var this_array = this.array;\n        for (\n            var i = 0;\n            i < this.t;\n            ++i\n        ) if (this_array[i] != 0) return i * BI_DB + lbit(this_array[i]);\n        if (this.s < 0) return this.t * BI_DB;\n        return -1;\n    }\n\n    // return number of 1 bits in x\n    function cbit(x) {\n        var r = 0;\n        while (x != 0) {\n            x &= x - 1;\n            ++r;\n        }\n        return r;\n    }\n\n    // (public) return number of set bits\n    function bnBitCount() {\n        var r = 0, x = this.s & BI_DM;\n        for (var i = 0; i < this.t; ++i) r += cbit(this_array[i] ^ x);\n        return r;\n    }\n\n    // (public) true iff nth bit is set\n    function bnTestBit(n) {\n        var this_array = this.array;\n        var j = Math.floor(n / BI_DB);\n        if (j >= this.t) return this.s != 0;\n        return (this_array[j] & (1 << (n % BI_DB))) != 0;\n    }\n\n    // (protected) this op (1<<n)\n    function bnpChangeBit(n, op) {\n        var r = BigInteger.ONE.shiftLeft(n);\n        this.bitwiseTo(r, op, r);\n        return r;\n    }\n\n    // (public) this | (1<<n)\n    function bnSetBit(n) {\n        return this.changeBit(n, op_or);\n    }\n\n    // (public) this & ~(1<<n)\n    function bnClearBit(n) {\n        return this.changeBit(n, op_andnot);\n    }\n\n    // (public) this ^ (1<<n)\n    function bnFlipBit(n) {\n        return this.changeBit(n, op_xor);\n    }\n\n    // (protected) r = this + a\n    function bnpAddTo(a, r) {\n        var this_array = this.array;\n        var a_array = a.array;\n        var r_array = r.array;\n        var i = 0, c = 0, m = Math.min(a.t, this.t);\n        while (i < m) {\n            c += this_array[i] + a_array[i];\n            r_array[i++] = c & BI_DM;\n            c >>= BI_DB;\n        }\n        if (a.t < this.t) {\n            c += a.s;\n            while (i < this.t) {\n                c += this_array[i];\n                r_array[i++] = c & BI_DM;\n                c >>= BI_DB;\n            }\n            c += this.s;\n        } else {\n            c += this.s;\n            while (i < a.t) {\n                c += a_array[i];\n                r_array[i++] = c & BI_DM;\n                c >>= BI_DB;\n            }\n            c += a.s;\n        }\n        r.s = c < 0 ? -1 : 0;\n        if (c > 0) r_array[i++] = c;\n        else if (c < -1) r_array[i++] = BI_DV + c;\n        r.t = i;\n        r.clamp();\n    }\n\n    // (public) this + a\n    function bnAdd(a) {\n        var r = nbi();\n        this.addTo(a, r);\n        return r;\n    }\n\n    // (public) this - a\n    function bnSubtract(a) {\n        var r = nbi();\n        this.subTo(a, r);\n        return r;\n    }\n\n    // (public) this * a\n    function bnMultiply(a) {\n        var r = nbi();\n        this.multiplyTo(a, r);\n        return r;\n    }\n\n    // (public) this / a\n    function bnDivide(a) {\n        var r = nbi();\n        this.divRemTo(a, r, null);\n        return r;\n    }\n\n    // (public) this % a\n    function bnRemainder(a) {\n        var r = nbi();\n        this.divRemTo(a, null, r);\n        return r;\n    }\n\n    // (public) [this/a,this%a]\n    function bnDivideAndRemainder(a) {\n        var q = nbi(), r = nbi();\n        this.divRemTo(a, q, r);\n        return new Array(q, r);\n    }\n\n    // (protected) this *= n, this >= 0, 1 < n < DV\n    function bnpDMultiply(n) {\n        var this_array = this.array;\n        this_array[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n        ++this.t;\n        this.clamp();\n    }\n\n    // (protected) this += n << w words, this >= 0\n    function bnpDAddOffset(n, w) {\n        var this_array = this.array;\n        while (this.t <= w) this_array[this.t++] = 0;\n        this_array[w] += n;\n        while (this_array[w] >= BI_DV) {\n            this_array[w] -= BI_DV;\n            if (++w >= this.t) this_array[this.t++] = 0;\n            ++this_array[w];\n        }\n    }\n\n    // A \"null\" reducer\n    function NullExp() {}\n    function nNop(x) {\n        return x;\n    }\n    function nMulTo(x, y, r) {\n        x.multiplyTo(y, r);\n    }\n    function nSqrTo(x, r) {\n        x.squareTo(r);\n    }\n\n    NullExp.prototype.convert = nNop;\n    NullExp.prototype.revert = nNop;\n    NullExp.prototype.mulTo = nMulTo;\n    NullExp.prototype.sqrTo = nSqrTo;\n\n    // (public) this^e\n    function bnPow(e) {\n        return this.exp(e, new NullExp());\n    }\n\n    // (protected) r = lower n words of \"this * a\", a.t <= n\n    // \"this\" should be the larger one if appropriate.\n    function bnpMultiplyLowerTo(a, n, r) {\n        var r_array = r.array;\n        var a_array = a.array;\n        var i = Math.min(this.t + a.t, n);\n        r.s = 0; // assumes a,this >= 0\n        r.t = i;\n        while (i > 0) r_array[--i] = 0;\n        var j;\n        for (\n            j = r.t - this.t;\n            i < j;\n            ++i\n        ) r_array[i + this.t] = this.am(0, a_array[i], r, i, 0, this.t);\n        for (\n            j = Math.min(a.t, n);\n            i < j;\n            ++i\n        ) this.am(0, a_array[i], r, i, 0, n - i);\n        r.clamp();\n    }\n\n    // (protected) r = \"this * a\" without lower n words, n > 0\n    // \"this\" should be the larger one if appropriate.\n    function bnpMultiplyUpperTo(a, n, r) {\n        var r_array = r.array;\n        var a_array = a.array;\n        --n;\n        var i = (r.t = this.t + a.t - n);\n        r.s = 0; // assumes a,this >= 0\n        while (--i >= 0) r_array[i] = 0;\n        for (\n            i = Math.max(n - this.t, 0);\n            i < a.t;\n            ++i\n        ) r_array[this.t + i - n] = this.am(n - i, a_array[i], r, 0, 0, this.t + i - n);\n        r.clamp();\n        r.drShiftTo(1, r);\n    }\n\n    // Barrett modular reduction\n    function Barrett(m) {\n        // setup Barrett\n        this.r2 = nbi();\n        this.q3 = nbi();\n        BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\n        this.mu = this.r2.divide(m);\n        this.m = m;\n    }\n\n    function barrettConvert(x) {\n        if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);\n        else if (x.compareTo(this.m) < 0) return x;\n        else {\n            var r = nbi();\n            x.copyTo(r);\n            this.reduce(r);\n            return r;\n        }\n    }\n\n    function barrettRevert(x) {\n        return x;\n    }\n\n    // x = x mod m (HAC 14.42)\n    function barrettReduce(x) {\n        x.drShiftTo(this.m.t - 1, this.r2);\n        if (x.t > this.m.t + 1) {\n            x.t = this.m.t + 1;\n            x.clamp();\n        }\n        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n        while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);\n        x.subTo(this.r2, x);\n        while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n    }\n\n    // r = x^2 mod m; x != r\n    function barrettSqrTo(x, r) {\n        x.squareTo(r);\n        this.reduce(r);\n    }\n\n    // r = x*y mod m; x,y != r\n    function barrettMulTo(x, y, r) {\n        x.multiplyTo(y, r);\n        this.reduce(r);\n    }\n\n    Barrett.prototype.convert = barrettConvert;\n    Barrett.prototype.revert = barrettRevert;\n    Barrett.prototype.reduce = barrettReduce;\n    Barrett.prototype.mulTo = barrettMulTo;\n    Barrett.prototype.sqrTo = barrettSqrTo;\n\n    // (public) this^e % m (HAC 14.85)\n    function bnModPow(e, m) {\n        var e_array = e.array;\n        var i = e.bitLength(), k, r = nbv(1), z;\n        if (i <= 0) return r;\n        else if (i < 18) k = 1;\n        else if (i < 48) k = 3;\n        else if (i < 144) k = 4;\n        else if (i < 768) k = 5;\n        else k = 6;\n        if (i < 8) z = new Classic(m);\n        else if (m.isEven()) z = new Barrett(m);\n        else z = new Montgomery(m);\n\n        // precomputation\n        var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;\n        g[1] = z.convert(this);\n        if (k > 1) {\n            var g2 = nbi();\n            z.sqrTo(g[1], g2);\n            while (n <= km) {\n                g[n] = nbi();\n                z.mulTo(g2, g[n - 2], g[n]);\n                n += 2;\n            }\n        }\n\n        var j = e.t - 1, w, is1 = true, r2 = nbi(), t;\n        i = nbits(e_array[j]) - 1;\n        while (j >= 0) {\n            if (i >= k1) w = (e_array[j] >> (i - k1)) & km;\n            else {\n                w = (e_array[j] & ((1 << (i + 1)) - 1)) << (k1 - i);\n                if (j > 0) w |= e_array[j - 1] >> (BI_DB + i - k1);\n            }\n\n            n = k;\n            while ((w & 1) == 0) {\n                w >>= 1;\n                --n;\n            }\n            if ((i -= n) < 0) {\n                i += BI_DB;\n                --j;\n            }\n            if (is1) {\n                // ret == 1, don't bother squaring or multiplying it\n                g[w].copyTo(r);\n                is1 = false;\n            } else {\n                while (n > 1) {\n                    z.sqrTo(r, r2);\n                    z.sqrTo(r2, r);\n                    n -= 2;\n                }\n                if (n > 0) z.sqrTo(r, r2);\n                else {\n                    t = r;\n                    r = r2;\n                    r2 = t;\n                }\n                z.mulTo(r2, g[w], r);\n            }\n\n            while (j >= 0 && (e_array[j] & (1 << i)) == 0) {\n                z.sqrTo(r, r2);\n                t = r;\n                r = r2;\n                r2 = t;\n                if (--i < 0) {\n                    i = BI_DB - 1;\n                    --j;\n                }\n            }\n        }\n        return z.revert(r);\n    }\n\n    // (public) gcd(this,a) (HAC 14.54)\n    function bnGCD(a) {\n        var x = this.s < 0 ? this.negate() : this.clone();\n        var y = a.s < 0 ? a.negate() : a.clone();\n        if (x.compareTo(y) < 0) {\n            var t = x;\n            x = y;\n            y = t;\n        }\n        var i = x.getLowestSetBit(), g = y.getLowestSetBit();\n        if (g < 0) return x;\n        if (i < g) g = i;\n        if (g > 0) {\n            x.rShiftTo(g, x);\n            y.rShiftTo(g, y);\n        }\n        while (x.signum() > 0) {\n            if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);\n            if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);\n            if (x.compareTo(y) >= 0) {\n                x.subTo(y, x);\n                x.rShiftTo(1, x);\n            } else {\n                y.subTo(x, y);\n                y.rShiftTo(1, y);\n            }\n        }\n        if (g > 0) y.lShiftTo(g, y);\n        return y;\n    }\n\n    // (protected) this % n, n < 2^26\n    function bnpModInt(n) {\n        var this_array = this.array;\n        if (n <= 0) return 0;\n        var d = BI_DV % n, r = this.s < 0 ? n - 1 : 0;\n        if (this.t > 0)\n            if (d == 0) r = this_array[0] % n;\n            else\n                for (var i = this.t - 1; i >= 0; --i)\n                    r = (d * r + this_array[i]) % n;\n        return r;\n    }\n\n    // (public) 1/this % m (HAC 14.61)\n    function bnModInverse(m) {\n        var ac = m.isEven();\n        if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n        var u = m.clone(), v = this.clone();\n        var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\n        while (u.signum() != 0) {\n            while (u.isEven()) {\n                u.rShiftTo(1, u);\n                if (ac) {\n                    if (!a.isEven() || !b.isEven()) {\n                        a.addTo(this, a);\n                        b.subTo(m, b);\n                    }\n                    a.rShiftTo(1, a);\n                } else if (!b.isEven()) b.subTo(m, b);\n                b.rShiftTo(1, b);\n            }\n            while (v.isEven()) {\n                v.rShiftTo(1, v);\n                if (ac) {\n                    if (!c.isEven() || !d.isEven()) {\n                        c.addTo(this, c);\n                        d.subTo(m, d);\n                    }\n                    c.rShiftTo(1, c);\n                } else if (!d.isEven()) d.subTo(m, d);\n                d.rShiftTo(1, d);\n            }\n            if (u.compareTo(v) >= 0) {\n                u.subTo(v, u);\n                if (ac) a.subTo(c, a);\n                b.subTo(d, b);\n            } else {\n                v.subTo(u, v);\n                if (ac) c.subTo(a, c);\n                d.subTo(b, d);\n            }\n        }\n        if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n        if (d.compareTo(m) >= 0) return d.subtract(m);\n        if (d.signum() < 0) d.addTo(m, d);\n        else return d;\n        if (d.signum() < 0) return d.add(m);\n        else return d;\n    }\n\n    var lowprimes = [\n        2,\n        3,\n        5,\n        7,\n        11,\n        13,\n        17,\n        19,\n        23,\n        29,\n        31,\n        37,\n        41,\n        43,\n        47,\n        53,\n        59,\n        61,\n        67,\n        71,\n        73,\n        79,\n        83,\n        89,\n        97,\n        101,\n        103,\n        107,\n        109,\n        113,\n        127,\n        131,\n        137,\n        139,\n        149,\n        151,\n        157,\n        163,\n        167,\n        173,\n        179,\n        181,\n        191,\n        193,\n        197,\n        199,\n        211,\n        223,\n        227,\n        229,\n        233,\n        239,\n        241,\n        251,\n        257,\n        263,\n        269,\n        271,\n        277,\n        281,\n        283,\n        293,\n        307,\n        311,\n        313,\n        317,\n        331,\n        337,\n        347,\n        349,\n        353,\n        359,\n        367,\n        373,\n        379,\n        383,\n        389,\n        397,\n        401,\n        409,\n        419,\n        421,\n        431,\n        433,\n        439,\n        443,\n        449,\n        457,\n        461,\n        463,\n        467,\n        479,\n        487,\n        491,\n        499,\n        503,\n        509,\n    ];\n    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];\n\n    // (public) test primality with certainty >= 1-.5^t\n    function bnIsProbablePrime(t) {\n        var i, x = this.abs();\n        var x_array = x.array;\n        if (x.t == 1 && x_array[0] <= lowprimes[lowprimes.length - 1]) {\n            for (i = 0; i < lowprimes.length; ++i)\n                if (x_array[0] == lowprimes[i]) return true;\n            return false;\n        }\n        if (x.isEven()) return false;\n        i = 1;\n        while (i < lowprimes.length) {\n            var m = lowprimes[i], j = i + 1;\n            while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n            m = x.modInt(m);\n            while (i < j) if (m % lowprimes[i++] == 0) return false;\n        }\n        return x.millerRabin(t);\n    }\n\n    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n    function bnpMillerRabin(t) {\n        var n1 = this.subtract(BigInteger.ONE);\n        var k = n1.getLowestSetBit();\n        if (k <= 0) return false;\n        var r = n1.shiftRight(k);\n        t = (t + 1) >> 1;\n        if (t > lowprimes.length) t = lowprimes.length;\n        var a = nbi();\n        for (var i = 0; i < t; ++i) {\n            a.fromInt(lowprimes[i]);\n            var y = a.modPow(r, this);\n            if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\n                var j = 1;\n                while (j++ < k && y.compareTo(n1) != 0) {\n                    y = y.modPowInt(2, this);\n                    if (y.compareTo(BigInteger.ONE) == 0) return false;\n                }\n                if (y.compareTo(n1) != 0) return false;\n            }\n        }\n        return true;\n    }\n\n    // protected\n    BigInteger.prototype.chunkSize = bnpChunkSize;\n    BigInteger.prototype.toRadix = bnpToRadix;\n    BigInteger.prototype.fromRadix = bnpFromRadix;\n    BigInteger.prototype.fromNumber = bnpFromNumber;\n    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n    BigInteger.prototype.changeBit = bnpChangeBit;\n    BigInteger.prototype.addTo = bnpAddTo;\n    BigInteger.prototype.dMultiply = bnpDMultiply;\n    BigInteger.prototype.dAddOffset = bnpDAddOffset;\n    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n    BigInteger.prototype.modInt = bnpModInt;\n    BigInteger.prototype.millerRabin = bnpMillerRabin;\n\n    // public\n    BigInteger.prototype.clone = bnClone;\n    BigInteger.prototype.intValue = bnIntValue;\n    BigInteger.prototype.byteValue = bnByteValue;\n    BigInteger.prototype.shortValue = bnShortValue;\n    BigInteger.prototype.signum = bnSigNum;\n    BigInteger.prototype.toByteArray = bnToByteArray;\n    BigInteger.prototype.equals = bnEquals;\n    BigInteger.prototype.min = bnMin;\n    BigInteger.prototype.max = bnMax;\n    BigInteger.prototype.and = bnAnd;\n    BigInteger.prototype.or = bnOr;\n    BigInteger.prototype.xor = bnXor;\n    BigInteger.prototype.andNot = bnAndNot;\n    BigInteger.prototype.not = bnNot;\n    BigInteger.prototype.shiftLeft = bnShiftLeft;\n    BigInteger.prototype.shiftRight = bnShiftRight;\n    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n    BigInteger.prototype.bitCount = bnBitCount;\n    BigInteger.prototype.testBit = bnTestBit;\n    BigInteger.prototype.setBit = bnSetBit;\n    BigInteger.prototype.clearBit = bnClearBit;\n    BigInteger.prototype.flipBit = bnFlipBit;\n    BigInteger.prototype.add = bnAdd;\n    BigInteger.prototype.subtract = bnSubtract;\n    BigInteger.prototype.multiply = bnMultiply;\n    BigInteger.prototype.divide = bnDivide;\n    BigInteger.prototype.remainder = bnRemainder;\n    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n    BigInteger.prototype.modPow = bnModPow;\n    BigInteger.prototype.modInverse = bnModInverse;\n    BigInteger.prototype.pow = bnPow;\n    BigInteger.prototype.gcd = bnGCD;\n    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\n    // BigInteger interfaces not implemented in jsbn:\n\n    // BigInteger(int signum, byte[] magnitude)\n    // double doubleValue()\n    // float floatValue()\n    // int hashCode()\n    // long longValue()\n    // static BigInteger valueOf(long val)\n    // prng4.js - uses Arcfour as a PRNG\n\n    function Arcfour() {\n        this.i = 0;\n        this.j = 0;\n        this.S = new Array();\n    }\n\n    // Initialize arcfour context from key, an array of ints, each from [0..255]\n    function ARC4init(key) {\n        var i, j, t;\n        for (i = 0; i < 256; ++i) this.S[i] = i;\n        j = 0;\n        for (i = 0; i < 256; ++i) {\n            j = (j + this.S[i] + key[i % key.length]) & 255;\n            t = this.S[i];\n            this.S[i] = this.S[j];\n            this.S[j] = t;\n        }\n        this.i = 0;\n        this.j = 0;\n    }\n\n    function ARC4next() {\n        var t;\n        this.i = (this.i + 1) & 255;\n        this.j = (this.j + this.S[this.i]) & 255;\n        t = this.S[this.i];\n        this.S[this.i] = this.S[this.j];\n        this.S[this.j] = t;\n        return this.S[(t + this.S[this.i]) & 255];\n    }\n\n    Arcfour.prototype.init = ARC4init;\n    Arcfour.prototype.next = ARC4next;\n\n    // Plug in your RNG constructor here\n    function prng_newstate() {\n        return new Arcfour();\n    }\n\n    // Pool size must be a multiple of 4 and greater than 32.\n    // An array of bytes the size of the pool will be passed to init()\n    var rng_psize = 256;\n    // Random number generator - requires a PRNG backend, e.g. prng4.js\n\n    // For best results, put code like\n    // <body onClick='rng_seed_time();' onKeyPress='rng_seed_time();'>\n    // in your main HTML document.\n\n    var rng_state;\n    var rng_pool;\n    var rng_pptr;\n\n    // Mix in a 32-bit integer into the pool\n    function rng_seed_int(x) {\n        rng_pool[rng_pptr++] ^= x & 255;\n        rng_pool[rng_pptr++] ^= (x >> 8) & 255;\n        rng_pool[rng_pptr++] ^= (x >> 16) & 255;\n        rng_pool[rng_pptr++] ^= (x >> 24) & 255;\n        if (rng_pptr >= rng_psize) rng_pptr -= rng_psize;\n    }\n\n    // Mix in the current time (w/milliseconds) into the pool\n    function rng_seed_time() {\n        // Use pre-computed date to avoid making the benchmark\n        // results dependent on the current date.\n        rng_seed_int(1122926989487);\n    }\n\n    // Initialize the pool with junk if needed.\n    if (rng_pool == null) {\n        rng_pool = new Array();\n        rng_pptr = 0;\n        var t;\n        while (rng_pptr < rng_psize) {\n            // extract some randomness from Math.random()\n            t = Math.floor(65536 * Math.random());\n            rng_pool[rng_pptr++] = t >>> 8;\n            rng_pool[rng_pptr++] = t & 255;\n        }\n        rng_pptr = 0;\n        rng_seed_time();\n\n        //rng_seed_int(window.screenX);\n\n        //rng_seed_int(window.screenY);\n    }\n\n    function rng_get_byte() {\n        if (rng_state == null) {\n            rng_seed_time();\n            rng_state = prng_newstate();\n            rng_state.init(rng_pool);\n            for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)\n                rng_pool[rng_pptr] = 0;\n            rng_pptr = 0;\n\n            //rng_pool = null;\n        }\n        // TODO: allow reseeding after first request\n        return rng_state.next();\n    }\n\n    function rng_get_bytes(ba) {\n        var i;\n        for (i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();\n    }\n\n    function SecureRandom() {}\n\n    SecureRandom.prototype.nextBytes = rng_get_bytes;\n    // Depends on jsbn.js and rng.js\n\n    // convert a (hex) string to a bignum object\n    function parseBigInt(str, r) {\n        return new BigInteger(str, r);\n    }\n\n    function linebrk(s, n) {\n        var ret = '';\n        var i = 0;\n        while (i + n < s.length) {\n            ret += s.substring(i, i + n) + '\\n';\n            i += n;\n        }\n        return ret + s.substring(i, s.length);\n    }\n\n    function byte2Hex(b) {\n        if (b < 0x10) return '0' + b.toString(16);\n        else return b.toString(16);\n    }\n\n    // PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint\n    function pkcs1pad2(s, n) {\n        if (n < s.length + 11) {\n            alert('Message too long for RSA');\n            return null;\n        }\n        var ba = new Array();\n        var i = s.length - 1;\n        while (i >= 0 && n > 0) ba[--n] = s.charCodeAt(i--);\n        ba[--n] = 0;\n        var rng = new SecureRandom();\n        var x = new Array();\n        while (n > 2) {\n            // random non-zero pad\n            x[0] = 0;\n            while (x[0] == 0) rng.nextBytes(x);\n            ba[--n] = x[0];\n        }\n        ba[--n] = 2;\n        ba[--n] = 0;\n        return new BigInteger(ba);\n    }\n\n    // \"empty\" RSA key constructor\n    function RSAKey() {\n        this.n = null;\n        this.e = 0;\n        this.d = null;\n        this.p = null;\n        this.q = null;\n        this.dmp1 = null;\n        this.dmq1 = null;\n        this.coeff = null;\n    }\n\n    // Set the public key fields N and e from hex strings\n    function RSASetPublic(N, E) {\n        if (N != null && E != null && N.length > 0 && E.length > 0) {\n            this.n = parseBigInt(N, 16);\n            this.e = parseInt(E, 16);\n        } else alert('Invalid RSA public key');\n    }\n\n    // Perform raw public operation on \"x\": return x^e (mod n)\n    function RSADoPublic(x) {\n        return x.modPowInt(this.e, this.n);\n    }\n\n    // Return the PKCS#1 RSA encryption of \"text\" as an even-length hex string\n    function RSAEncrypt(text) {\n        var m = pkcs1pad2(text, (this.n.bitLength() + 7) >> 3);\n        if (m == null) return null;\n        var c = this.doPublic(m);\n        if (c == null) return null;\n        var h = c.toString(16);\n        if ((h.length & 1) == 0) return h;\n        else return '0' + h;\n    }\n\n    // Return the PKCS#1 RSA encryption of \"text\" as a Base64-encoded string\n    //function RSAEncryptB64(text) {\n    //  var h = this.encrypt(text);\n    //  if(h) return hex2b64(h); else return null;\n    //}\n\n    // protected\n    RSAKey.prototype.doPublic = RSADoPublic;\n\n    // public\n    RSAKey.prototype.setPublic = RSASetPublic;\n    RSAKey.prototype.encrypt = RSAEncrypt;\n    //RSAKey.prototype.encrypt_b64 = RSAEncryptB64;\n    // Depends on rsa.js and jsbn2.js\n\n    // Undo PKCS#1 (type 2, random) padding and, if valid, return the plaintext\n    function pkcs1unpad2(d, n) {\n        var b = d.toByteArray();\n        var i = 0;\n        while (i < b.length && b[i] == 0) ++i;\n        if (b.length - i != n - 1 || b[i] != 2) return null;\n        ++i;\n        while (b[i] != 0) if (++i >= b.length) return null;\n        var ret = '';\n        while (++i < b.length) ret += String.fromCharCode(b[i]);\n        return ret;\n    }\n\n    // Set the private key fields N, e, and d from hex strings\n    function RSASetPrivate(N, E, D) {\n        if (N != null && E != null && N.length > 0 && E.length > 0) {\n            this.n = parseBigInt(N, 16);\n            this.e = parseInt(E, 16);\n            this.d = parseBigInt(D, 16);\n        } else alert('Invalid RSA private key');\n    }\n\n    // Set the private key fields N, e, d and CRT params from hex strings\n    function RSASetPrivateEx(N, E, D, P, Q, DP, DQ, C) {\n        if (N != null && E != null && N.length > 0 && E.length > 0) {\n            this.n = parseBigInt(N, 16);\n            this.e = parseInt(E, 16);\n            this.d = parseBigInt(D, 16);\n            this.p = parseBigInt(P, 16);\n            this.q = parseBigInt(Q, 16);\n            this.dmp1 = parseBigInt(DP, 16);\n            this.dmq1 = parseBigInt(DQ, 16);\n            this.coeff = parseBigInt(C, 16);\n        } else alert('Invalid RSA private key');\n    }\n\n    // Generate a new random private key B bits long, using public expt E\n    function RSAGenerate(B, E) {\n        var rng = new SecureRandom();\n        var qs = B >> 1;\n        this.e = parseInt(E, 16);\n        var ee = new BigInteger(E, 16);\n        for (;;) {\n            for (;;) {\n                this.p = new BigInteger(B - qs, 1, rng);\n                if (\n                    this.p\n                        .subtract(BigInteger.ONE)\n                        .gcd(ee)\n                        .compareTo(BigInteger.ONE) == 0 &&\n                    this.p.isProbablePrime(10)\n                )\n                    break;\n            }\n            for (;;) {\n                this.q = new BigInteger(qs, 1, rng);\n                if (\n                    this.q\n                        .subtract(BigInteger.ONE)\n                        .gcd(ee)\n                        .compareTo(BigInteger.ONE) == 0 &&\n                    this.q.isProbablePrime(10)\n                )\n                    break;\n            }\n            if (this.p.compareTo(this.q) <= 0) {\n                var t = this.p;\n                this.p = this.q;\n                this.q = t;\n            }\n            var p1 = this.p.subtract(BigInteger.ONE);\n            var q1 = this.q.subtract(BigInteger.ONE);\n            var phi = p1.multiply(q1);\n            if (phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {\n                this.n = this.p.multiply(this.q);\n                this.d = ee.modInverse(phi);\n                this.dmp1 = this.d.mod(p1);\n                this.dmq1 = this.d.mod(q1);\n                this.coeff = this.q.modInverse(this.p);\n                break;\n            }\n        }\n    }\n\n    // Perform raw private operation on \"x\": return x^d (mod n)\n    function RSADoPrivate(x) {\n        if (this.p == null || this.q == null) return x.modPow(this.d, this.n);\n\n        // TODO: re-calculate any missing CRT params\n        var xp = x.mod(this.p).modPow(this.dmp1, this.p);\n        var xq = x.mod(this.q).modPow(this.dmq1, this.q);\n\n        while (xp.compareTo(xq) < 0) xp = xp.add(this.p);\n        return xp\n            .subtract(xq)\n            .multiply(this.coeff)\n            .mod(this.p)\n            .multiply(this.q)\n            .add(xq);\n    }\n\n    // Return the PKCS#1 RSA decryption of \"ctext\".\n    // \"ctext\" is an even-length hex string and the output is a plain string.\n    function RSADecrypt(ctext) {\n        var c = parseBigInt(ctext, 16);\n        var m = this.doPrivate(c);\n        if (m == null) return null;\n        return pkcs1unpad2(m, (this.n.bitLength() + 7) >> 3);\n    }\n\n    // Return the PKCS#1 RSA decryption of \"ctext\".\n    // \"ctext\" is a Base64-encoded string and the output is a plain string.\n    //function RSAB64Decrypt(ctext) {\n    //  var h = b64tohex(ctext);\n    //  if(h) return this.decrypt(h); else return null;\n    //}\n\n    // protected\n    RSAKey.prototype.doPrivate = RSADoPrivate;\n\n    // public\n    RSAKey.prototype.setPrivate = RSASetPrivate;\n    RSAKey.prototype.setPrivateEx = RSASetPrivateEx;\n    RSAKey.prototype.generate = RSAGenerate;\n    RSAKey.prototype.decrypt = RSADecrypt;\n    //RSAKey.prototype.b64_decrypt = RSAB64Decrypt;\n\n    nValue =\n        'a5261939975948bb7a58dffe5ff54e65f0498f9175f5a09288810b8975871e99af3b5dd94057b0fc07535f5f97444504fa35169d461d0d30cf0192e307727c065168c788771c561a9400fb49175e9e6aa4e23fe11af69e9412dd23b0cb6684c4c2429bce139e848ab26d0829073351f4acd36074eafd036a5eb83359d2a698d3';\n    eValue = '10001';\n    dValue =\n        '8e9912f6d3645894e8d38cb58c0db81ff516cf4c7e5a14c7f1eddb1459d2cded4d8d293fc97aee6aefb861859c8b6a3d1dfe710463e1f9ddc72048c09751971c4a580aa51eb523357a3cc48d31cfad1d4a165066ed92d4748fb6571211da5cb14bc11b6e2df7c1a559e6d5ac1cd5c94703a22891464fba23d0d965086277a161';\n    pValue =\n        'd090ce58a92c75233a6486cb0a9209bf3583b64f540c76f5294bb97d285eed33aec220bde14b2417951178ac152ceab6da7090905b478195498b352048f15e7d';\n    qValue =\n        'cab575dc652bb66df15a0359609d51d1db184750c00c6698b90ef3465c99655103edbf0d54c56aec0ce3c4d22592338092a126a0cc49f65a4a30d222b411e58f';\n    dmp1Value =\n        '1a24bca8e273df2f0e47c199bbf678604e7df7215480c77c8db39f49b000ce2cf7500038acfff5433b7d582a01f1826e6f4d42e1c57f5e1fef7b12aabc59fd25';\n    dmq1Value =\n        '3d06982efbbe47339e1f6d36b1216b8a741d410b0c662f54f7118b27b9a4ec9d914337eb39841d8666f3034408cf94f5b62f11c402fc994fe15a05493150d9fd';\n    coeffValue =\n        '3a3e731acd8960b7ff9eb81a7ff93bd1cfa74cbd56987db58b4594fb09c09084db1734c8143f98b602b981aaa9243ca28deb69b5b280ee8dcee0fd2625e53250';\n\n    setupEngine(am3, 28);\n\n    var TEXT =\n        'The quick brown fox jumped over the extremely lazy frog! ' +\n        'Now is the time for all good men to come to the party.';\n    var encrypted;\n\n    function encrypt() {\n        var RSA = new RSAKey();\n        RSA.setPublic(nValue, eValue);\n        RSA.setPrivateEx(\n            nValue,\n            eValue,\n            dValue,\n            pValue,\n            qValue,\n            dmp1Value,\n            dmq1Value,\n            coeffValue\n        );\n        encrypted = RSA.encrypt(TEXT);\n    }\n\n    function decrypt() {\n        var RSA = new RSAKey();\n        RSA.setPublic(nValue, eValue);\n        RSA.setPrivateEx(\n            nValue,\n            eValue,\n            dValue,\n            pValue,\n            qValue,\n            dmp1Value,\n            dmq1Value,\n            coeffValue\n        );\n        var decrypted = RSA.decrypt(encrypted);\n        if (decrypted != TEXT) {\n            throw new Error('Crypto operation failed');\n        }\n    }\n\n    encrypt();\n    decrypt();\n\n    setTimeout(function() {\n        console.log(decrypt);\n        \n        if (global.emitTTDLog) {\n            // please make sure <MEM-VIS-DIR> points to the root dir of this repo\n            let snapshotDir = __dirname + '/../snapshot';\n            console.log('Dumping snapshot to -- ' + snapshotDir);\n            global.emitTTDLog(snapshotDir);\n        }\n    }, 500);\n}, 100);\n\n\n\n});"},
    {"fileId":36, "filename":"net.js", "source":"(function (exports, require, module, __filename, __dirname) { // Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst stream = require('stream');\nconst timers = require('timers');\nconst util = require('util');\nconst internalUtil = require('internal/util');\nconst internalNet = require('internal/net');\nconst assert = require('assert');\nconst cares = process.binding('cares_wrap');\nconst uv = process.binding('uv');\n\nconst Buffer = require('buffer').Buffer;\nconst TTYWrap = process.binding('tty_wrap');\nconst TCP = process.binding('tcp_wrap').TCP;\nconst Pipe = process.binding('pipe_wrap').Pipe;\nconst TCPConnectWrap = process.binding('tcp_wrap').TCPConnectWrap;\nconst PipeConnectWrap = process.binding('pipe_wrap').PipeConnectWrap;\nconst ShutdownWrap = process.binding('stream_wrap').ShutdownWrap;\nconst WriteWrap = process.binding('stream_wrap').WriteWrap;\nconst async_id_symbol = process.binding('async_wrap').async_id_symbol;\nconst { newUid, setInitTriggerId } = require('async_hooks');\nconst nextTick = require('internal/process/next_tick').nextTick;\n\nvar cluster;\nvar dns;\n\nconst errnoException = util._errnoException;\nconst exceptionWithHostPort = util._exceptionWithHostPort;\nconst isLegalPort = internalNet.isLegalPort;\nconst normalizedArgsSymbol = internalNet.normalizedArgsSymbol;\n\nfunction noop() {}\n\nfunction createHandle(fd) {\n  var type = TTYWrap.guessHandleType(fd);\n  if (type === 'PIPE') return new Pipe();\n  if (type === 'TCP') return new TCP();\n  throw new TypeError('Unsupported fd type: ' + type);\n}\n\n\nfunction getNewAsyncId(handle) {\n  return (!handle || typeof handle.getAsyncId !== 'function') ?\n      newUid() : handle.getAsyncId();\n}\n\n\nconst debug = util.debuglog('net');\n\nfunction isPipeName(s) {\n  return typeof s === 'string' && toNumber(s) === false;\n}\n\nfunction createServer(options, connectionListener) {\n  return new Server(options, connectionListener);\n}\n\n\n// Target API:\n//\n// var s = net.connect({port: 80, host: 'google.com'}, function() {\n//   ...\n// });\n//\n// There are various forms:\n//\n// connect(options, [cb])\n// connect(port, [host], [cb])\n// connect(path, [cb]);\n//\nfunction connect() {\n  var args = new Array(arguments.length);\n  for (var i = 0; i < arguments.length; i++)\n    args[i] = arguments[i];\n  // TODO(joyeecheung): use destructuring when V8 is fast enough\n  var normalized = normalizeArgs(args);\n  var options = normalized[0];\n  debug('createConnection', normalized);\n  var socket = new Socket(options);\n\n  if (options.timeout) {\n    socket.setTimeout(options.timeout);\n  }\n\n  return Socket.prototype.connect.call(socket, normalized);\n}\n\n\n// Returns an array [options, cb], where options is an object,\n// cb is either a funciton or null.\n// Used to normalize arguments of Socket.prototype.connect() and\n// Server.prototype.listen(). Possible combinations of paramters:\n//   (options[...][, cb])\n//   (path[...][, cb])\n//   ([port][, host][...][, cb])\n// For Socket.prototype.connect(), the [...] part is ignored\n// For Server.prototype.listen(), the [...] part is [, backlog]\n// but will not be handled here (handled in listen())\nfunction normalizeArgs(args) {\n  var arr;\n\n  if (args.length === 0) {\n    arr = [{}, null];\n    arr[normalizedArgsSymbol] = true;\n    return arr;\n  }\n\n  const arg0 = args[0];\n  var options = {};\n  if (typeof arg0 === 'object' && arg0 !== null) {\n    // (options[...][, cb])\n    options = arg0;\n  } else if (isPipeName(arg0)) {\n    // (path[...][, cb])\n    options.path = arg0;\n  } else {\n    // ([port][, host][...][, cb])\n    options.port = arg0;\n    if (args.length > 1 && typeof args[1] === 'string') {\n      options.host = args[1];\n    }\n  }\n\n  var cb = args[args.length - 1];\n  if (typeof cb !== 'function')\n    arr = [options, null];\n  else\n    arr = [options, cb];\n\n  arr[normalizedArgsSymbol] = true;\n  return arr;\n}\n\n\n// called when creating new Socket, or when re-using a closed Socket\nfunction initSocketHandle(self) {\n  self._undestroy();\n  self._bytesDispatched = 0;\n  self._sockname = null;\n\n  // Handle creation may be deferred to bind() or connect() time.\n  if (self._handle) {\n    self._handle.owner = self;\n    self._handle.onread = onread;\n    self[async_id_symbol] = getNewAsyncId(self._handle);\n\n    // If handle doesn't support writev - neither do we\n    if (!self._handle.writev)\n      self._writev = null;\n  }\n}\n\n\nconst BYTES_READ = Symbol('bytesRead');\n\n\nfunction Socket(options) {\n  if (!(this instanceof Socket)) return new Socket(options);\n\n  this.connecting = false;\n  // Problem with this is that users can supply their own handle, that may not\n  // have _handle.getAsyncId(). In this case an[async_id_symbol] should\n  // probably be supplied by async_hooks.\n  this[async_id_symbol] = -1;\n  this._hadError = false;\n  this._handle = null;\n  this._parent = null;\n  this._host = null;\n\n  if (typeof options === 'number')\n    options = { fd: options }; // Legacy interface.\n  else if (options === undefined)\n    options = {};\n\n  stream.Duplex.call(this, options);\n\n  if (options.handle) {\n    this._handle = options.handle; // private\n    this[async_id_symbol] = getNewAsyncId(this._handle);\n  } else if (options.fd !== undefined) {\n    this._handle = createHandle(options.fd);\n    this._handle.open(options.fd);\n    this[async_id_symbol] = this._handle.getAsyncId();\n    // options.fd can be string (since it is user-defined),\n    // so changing this to === would be semver-major\n    // See: https://github.com/nodejs/node/pull/11513\n    // eslint-disable-next-line eqeqeq\n    if ((options.fd == 1 || options.fd == 2) &&\n        (this._handle instanceof Pipe) &&\n        process.platform === 'win32') {\n      // Make stdout and stderr blocking on Windows\n      var err = this._handle.setBlocking(true);\n      if (err)\n        throw errnoException(err, 'setBlocking');\n    }\n    this.readable = options.readable !== false;\n    this.writable = options.writable !== false;\n  } else {\n    // these will be set once there is a connection\n    this.readable = this.writable = false;\n  }\n\n  // shut down the socket when we're finished with it.\n  this.on('finish', onSocketFinish);\n  this.on('_socketEnd', onSocketEnd);\n\n  initSocketHandle(this);\n\n  this._pendingData = null;\n  this._pendingEncoding = '';\n\n  // handle strings directly\n  this._writableState.decodeStrings = false;\n\n  // default to *not* allowing half open sockets\n  this.allowHalfOpen = options && options.allowHalfOpen || false;\n\n  // if we have a handle, then start the flow of data into the\n  // buffer.  if not, then this will happen when we connect\n  if (this._handle && options.readable !== false) {\n    if (options.pauseOnCreate) {\n      // stop the handle from reading and pause the stream\n      this._handle.reading = false;\n      this._handle.readStop();\n      this._readableState.flowing = false;\n    } else {\n      this.read(0);\n    }\n  }\n\n  // Reserve properties\n  this.server = null;\n  this._server = null;\n\n  // Used after `.destroy()`\n  this[BYTES_READ] = 0;\n}\nutil.inherits(Socket, stream.Duplex);\n\nSocket.prototype._unrefTimer = function _unrefTimer() {\n  for (var s = this; s !== null; s = s._parent)\n    timers._unrefActive(s);\n};\n\n// the user has called .end(), and all the bytes have been\n// sent out to the other side.\nfunction onSocketFinish() {\n  // If still connecting - defer handling 'finish' until 'connect' will happen\n  if (this.connecting) {\n    debug('osF: not yet connected');\n    return this.once('connect', onSocketFinish);\n  }\n\n  debug('onSocketFinish');\n  if (!this.readable || this._readableState.ended) {\n    debug('oSF: ended, destroy', this._readableState);\n    return this.destroy();\n  }\n\n  debug('oSF: not ended, call shutdown()');\n\n  // otherwise, just shutdown, or destroy() if not possible\n  if (!this._handle || !this._handle.shutdown)\n    return this.destroy();\n\n  var req = new ShutdownWrap();\n  req.oncomplete = afterShutdown;\n  req.handle = this._handle;\n  // node::ShutdownWrap isn't instantiated and attached to the JS instance of\n  // ShutdownWrap above until shutdown() is called. So don't set the init\n  // trigger id until now.\n  setInitTriggerId(this[async_id_symbol]);\n  var err = this._handle.shutdown(req);\n\n  if (err)\n    return this.destroy(errnoException(err, 'shutdown'));\n}\n\n\nfunction afterShutdown(status, handle, req) {\n  var self = handle.owner;\n\n  debug('afterShutdown destroyed=%j', self.destroyed,\n        self._readableState);\n\n  // callback may come after call to destroy.\n  if (self.destroyed)\n    return;\n\n  if (self._readableState.ended) {\n    debug('readableState ended, destroying');\n    self.destroy();\n  } else {\n    self.once('_socketEnd', self.destroy);\n  }\n}\n\n// the EOF has been received, and no more bytes are coming.\n// if the writable side has ended already, then clean everything\n// up.\nfunction onSocketEnd() {\n  // XXX Should not have to do as much crap in this function.\n  // ended should already be true, since this is called *after*\n  // the EOF errno and onread has eof'ed\n  debug('onSocketEnd', this._readableState);\n  this._readableState.ended = true;\n  if (this._readableState.endEmitted) {\n    this.readable = false;\n    maybeDestroy(this);\n  } else {\n    this.once('end', function end() {\n      this.readable = false;\n      maybeDestroy(this);\n    });\n    this.read(0);\n  }\n\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    this.destroySoon();\n  }\n}\n\n// Provide a better error message when we call end() as a result\n// of the other side sending a FIN.  The standard 'write after end'\n// is overly vague, and makes it seem like the user's code is to blame.\nfunction writeAfterFIN(chunk, encoding, cb) {\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  var er = new Error('This socket has been ended by the other party');\n  er.code = 'EPIPE';\n  // TODO: defer error events consistently everywhere, not just the cb\n  this.emit('error', er);\n  if (typeof cb === 'function') {\n    nextTick(this[async_id_symbol], cb, er);\n  }\n}\n\nSocket.prototype.read = function(n) {\n  if (n === 0)\n    return stream.Readable.prototype.read.call(this, n);\n\n  this.read = stream.Readable.prototype.read;\n  this._consuming = true;\n  return this.read(n);\n};\n\n\n// FIXME(joyeecheung): this method is neither documented nor tested\nSocket.prototype.listen = function() {\n  debug('socket.listen');\n  this.on('connection', arguments[0]);\n  listenInCluster(this, null, null, null);\n};\n\n\nSocket.prototype.setTimeout = function(msecs, callback) {\n  if (msecs === 0) {\n    timers.unenroll(this);\n    if (callback) {\n      this.removeListener('timeout', callback);\n    }\n  } else {\n    timers.enroll(this, msecs);\n    timers._unrefActive(this);\n    if (callback) {\n      this.once('timeout', callback);\n    }\n  }\n  return this;\n};\n\n\nSocket.prototype._onTimeout = function() {\n  debug('_onTimeout');\n  this.emit('timeout');\n};\n\n\nSocket.prototype.setNoDelay = function(enable) {\n  if (!this._handle) {\n    this.once('connect',\n              enable ? this.setNoDelay : () => this.setNoDelay(enable));\n    return this;\n  }\n\n  // backwards compatibility: assume true when `enable` is omitted\n  if (this._handle.setNoDelay)\n    this._handle.setNoDelay(enable === undefined ? true : !!enable);\n\n  return this;\n};\n\n\nSocket.prototype.setKeepAlive = function(setting, msecs) {\n  if (!this._handle) {\n    this.once('connect', () => this.setKeepAlive(setting, msecs));\n    return this;\n  }\n\n  if (this._handle.setKeepAlive)\n    this._handle.setKeepAlive(setting, ~~(msecs / 1000));\n\n  return this;\n};\n\n\nSocket.prototype.address = function() {\n  return this._getsockname();\n};\n\n\nObject.defineProperty(Socket.prototype, '_connecting', {\n  get: function() {\n    return this.connecting;\n  }\n});\n\n\nObject.defineProperty(Socket.prototype, 'readyState', {\n  get: function() {\n    if (this.connecting) {\n      return 'opening';\n    } else if (this.readable && this.writable) {\n      return 'open';\n    } else if (this.readable && !this.writable) {\n      return 'readOnly';\n    } else if (!this.readable && this.writable) {\n      return 'writeOnly';\n    } else {\n      return 'closed';\n    }\n  }\n});\n\n\nObject.defineProperty(Socket.prototype, 'bufferSize', {\n  get: function() {\n    if (this._handle) {\n      return this._handle.writeQueueSize + this._writableState.length;\n    }\n  }\n});\n\n\n// Just call handle.readStart until we have enough in the buffer\nSocket.prototype._read = function(n) {\n  debug('_read');\n\n  if (this.connecting || !this._handle) {\n    debug('_read wait for connection');\n    this.once('connect', () => this._read(n));\n  } else if (!this._handle.reading) {\n    // not already reading, start the flow\n    debug('Socket._read readStart');\n    this._handle.reading = true;\n    var err = this._handle.readStart();\n    if (err)\n      this.destroy(errnoException(err, 'read'));\n  }\n};\n\n\nSocket.prototype.end = function(data, encoding) {\n  stream.Duplex.prototype.end.call(this, data, encoding);\n  this.writable = false;\n  DTRACE_NET_STREAM_END(this);\n  ;\n\n  // just in case we're waiting for an EOF.\n  if (this.readable && !this._readableState.endEmitted)\n    this.read(0);\n  else\n    maybeDestroy(this);\n};\n\n\n// Call whenever we set writable=false or readable=false\nfunction maybeDestroy(socket) {\n  if (!socket.readable &&\n      !socket.writable &&\n      !socket.destroyed &&\n      !socket.connecting &&\n      !socket._writableState.length) {\n    socket.destroy();\n  }\n}\n\n\nSocket.prototype.destroySoon = function() {\n  if (this.writable)\n    this.end();\n\n  if (this._writableState.finished)\n    this.destroy();\n  else\n    this.once('finish', this.destroy);\n};\n\n\nSocket.prototype._destroy = function(exception, cb) {\n  debug('destroy');\n\n  this.connecting = false;\n\n  this.readable = this.writable = false;\n\n  for (var s = this; s !== null; s = s._parent)\n    timers.unenroll(s);\n\n  debug('close');\n  if (this._handle) {\n    if (this !== process.stderr)\n      debug('close handle');\n    var isException = exception ? true : false;\n    // `bytesRead` should be accessible after `.destroy()`\n    this[BYTES_READ] = this._handle.bytesRead;\n\n    this._handle.close(() => {\n      debug('emit close');\n      this.emit('close', isException);\n    });\n    this._handle.onread = noop;\n    this._handle = null;\n    this._sockname = null;\n  }\n\n  cb(exception);\n\n  if (this._server) {\n    ;\n    debug('has server');\n    this._server._connections--;\n    if (this._server._emitCloseIfDrained) {\n      this._server._emitCloseIfDrained();\n    }\n  }\n};\n\n\n// This function is called whenever the handle gets a\n// buffer, or when there's an error reading.\nfunction onread(nread, buffer) {\n  var handle = this;\n  var self = handle.owner;\n  assert(handle === self._handle, 'handle != self._handle');\n\n  self._unrefTimer();\n\n  debug('onread', nread);\n\n  if (nread > 0) {\n    debug('got data');\n\n    // read success.\n    // In theory (and in practice) calling readStop right now\n    // will prevent this from being called again until _read() gets\n    // called again.\n\n    // Optimization: emit the original buffer with end points\n    var ret = self.push(buffer);\n\n    if (handle.reading && !ret) {\n      handle.reading = false;\n      debug('readStop');\n      var err = handle.readStop();\n      if (err)\n        self.destroy(errnoException(err, 'read'));\n    }\n    return;\n  }\n\n  // if we didn't get any bytes, that doesn't necessarily mean EOF.\n  // wait for the next one.\n  if (nread === 0) {\n    debug('not any data, keep waiting');\n    return;\n  }\n\n  // Error, possibly EOF.\n  if (nread !== uv.UV_EOF) {\n    return self.destroy(errnoException(nread, 'read'));\n  }\n\n  debug('EOF');\n\n  // push a null to signal the end of data.\n  // Do it before `maybeDestroy` for correct order of events:\n  // `end` -> `close`\n  self.push(null);\n\n  if (self._readableState.length === 0) {\n    self.readable = false;\n    maybeDestroy(self);\n  }\n\n  // internal end event so that we know that the actual socket\n  // is no longer readable, and we can start the shutdown\n  // procedure. No need to wait for all the data to be consumed.\n  self.emit('_socketEnd');\n}\n\n\nSocket.prototype._getpeername = function() {\n  if (!this._peername) {\n    if (!this._handle || !this._handle.getpeername) {\n      return {};\n    }\n    var out = {};\n    var err = this._handle.getpeername(out);\n    if (err) return {};  // FIXME(bnoordhuis) Throw?\n    this._peername = out;\n  }\n  return this._peername;\n};\n\nfunction protoGetter(name, callback) {\n  Object.defineProperty(Socket.prototype, name, {\n    configurable: false,\n    enumerable: true,\n    get: callback\n  });\n}\n\nprotoGetter('bytesRead', function bytesRead() {\n  return this._handle ? this._handle.bytesRead : this[BYTES_READ];\n});\n\nprotoGetter('remoteAddress', function remoteAddress() {\n  return this._getpeername().address;\n});\n\nprotoGetter('remoteFamily', function remoteFamily() {\n  return this._getpeername().family;\n});\n\nprotoGetter('remotePort', function remotePort() {\n  return this._getpeername().port;\n});\n\n\nSocket.prototype._getsockname = function() {\n  if (!this._handle || !this._handle.getsockname) {\n    return {};\n  }\n  if (!this._sockname) {\n    var out = {};\n    var err = this._handle.getsockname(out);\n    if (err) return {};  // FIXME(bnoordhuis) Throw?\n    this._sockname = out;\n  }\n  return this._sockname;\n};\n\n\nprotoGetter('localAddress', function localAddress() {\n  return this._getsockname().address;\n});\n\n\nprotoGetter('localPort', function localPort() {\n  return this._getsockname().port;\n});\n\n\nSocket.prototype.write = function(chunk, encoding, cb) {\n  if (typeof chunk !== 'string' && !(chunk instanceof Buffer)) {\n    throw new TypeError(\n      'Invalid data, chunk must be a string or buffer, not ' + typeof chunk);\n  }\n  return stream.Duplex.prototype.write.apply(this, arguments);\n};\n\n\nSocket.prototype._writeGeneric = function(writev, data, encoding, cb) {\n  // If we are still connecting, then buffer this for later.\n  // The Writable logic will buffer up any more writes while\n  // waiting for this one to be done.\n  if (this.connecting) {\n    this._pendingData = data;\n    this._pendingEncoding = encoding;\n    this.once('connect', function connect() {\n      this._writeGeneric(writev, data, encoding, cb);\n    });\n    return;\n  }\n  this._pendingData = null;\n  this._pendingEncoding = '';\n\n  this._unrefTimer();\n\n  if (!this._handle) {\n    this.destroy(new Error('This socket is closed'), cb);\n    return false;\n  }\n\n  var req = new WriteWrap();\n  req.handle = this._handle;\n  req.oncomplete = afterWrite;\n  req.async = false;\n  var err;\n\n  if (writev) {\n    var allBuffers = data.allBuffers;\n    var chunks;\n    var i;\n    if (allBuffers) {\n      chunks = data;\n      for (i = 0; i < data.length; i++)\n        data[i] = data[i].chunk;\n    } else {\n      chunks = new Array(data.length << 1);\n      for (i = 0; i < data.length; i++) {\n        var entry = data[i];\n        chunks[i * 2] = entry.chunk;\n        chunks[i * 2 + 1] = entry.encoding;\n      }\n    }\n    err = this._handle.writev(req, chunks, allBuffers);\n\n    // Retain chunks\n    if (err === 0) req._chunks = chunks;\n  } else {\n    var enc;\n    if (data instanceof Buffer) {\n      enc = 'buffer';\n    } else {\n      enc = encoding;\n    }\n    err = createWriteReq(req, this._handle, data, enc);\n  }\n\n  if (err)\n    return this.destroy(errnoException(err, 'write', req.error), cb);\n\n  this._bytesDispatched += req.bytes;\n\n  // If it was entirely flushed, we can write some more right now.\n  // However, if more is left in the queue, then wait until that clears.\n  if (req.async && this._handle.writeQueueSize !== 0)\n    req.cb = cb;\n  else\n    cb();\n};\n\n\nSocket.prototype._writev = function(chunks, cb) {\n  this._writeGeneric(true, chunks, '', cb);\n};\n\n\nSocket.prototype._write = function(data, encoding, cb) {\n  this._writeGeneric(false, data, encoding, cb);\n};\n\nfunction createWriteReq(req, handle, data, encoding) {\n  switch (encoding) {\n    case 'latin1':\n    case 'binary':\n      return handle.writeLatin1String(req, data);\n\n    case 'buffer':\n      return handle.writeBuffer(req, data);\n\n    case 'utf8':\n    case 'utf-8':\n      return handle.writeUtf8String(req, data);\n\n    case 'ascii':\n      return handle.writeAsciiString(req, data);\n\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return handle.writeUcs2String(req, data);\n\n    default:\n      return handle.writeBuffer(req, Buffer.from(data, encoding));\n  }\n}\n\n\nprotoGetter('bytesWritten', function bytesWritten() {\n  var bytes = this._bytesDispatched;\n  const state = this._writableState;\n  const data = this._pendingData;\n  const encoding = this._pendingEncoding;\n\n  if (!state)\n    return undefined;\n\n  state.getBuffer().forEach(function(el) {\n    if (el.chunk instanceof Buffer)\n      bytes += el.chunk.length;\n    else\n      bytes += Buffer.byteLength(el.chunk, el.encoding);\n  });\n\n  if (data) {\n    if (data instanceof Buffer)\n      bytes += data.length;\n    else\n      bytes += Buffer.byteLength(data, encoding);\n  }\n\n  return bytes;\n});\n\n\nfunction afterWrite(status, handle, req, err) {\n  var self = handle.owner;\n  if (self !== process.stderr && self !== process.stdout)\n    debug('afterWrite', status);\n\n  // callback may come after call to destroy.\n  if (self.destroyed) {\n    debug('afterWrite destroyed');\n    return;\n  }\n\n  if (status < 0) {\n    var ex = errnoException(status, 'write', req.error);\n    debug('write failure', ex);\n    self.destroy(ex, req.cb);\n    return;\n  }\n\n  self._unrefTimer();\n\n  if (self !== process.stderr && self !== process.stdout)\n    debug('afterWrite call cb');\n\n  if (req.cb)\n    req.cb.call(self);\n}\n\n\nfunction internalConnect(\n  self, address, port, addressType, localAddress, localPort) {\n  // TODO return promise from Socket.prototype.connect which\n  // wraps _connectReq.\n\n  assert.ok(self.connecting);\n\n  var err;\n\n  if (localAddress || localPort) {\n    debug('binding to localAddress: %s and localPort: %d (addressType: %d)',\n          localAddress, localPort, addressType);\n\n    if (addressType === 4) {\n      localAddress = localAddress || '0.0.0.0';\n      err = self._handle.bind(localAddress, localPort);\n    } else if (addressType === 6) {\n      localAddress = localAddress || '::';\n      err = self._handle.bind6(localAddress, localPort);\n    } else {\n      self.destroy(new TypeError('Invalid addressType: ' + addressType));\n      return;\n    }\n\n    if (err) {\n      const ex = exceptionWithHostPort(err, 'bind', localAddress, localPort);\n      self.destroy(ex);\n      return;\n    }\n  }\n\n  if (addressType === 6 || addressType === 4) {\n    const req = new TCPConnectWrap();\n    req.oncomplete = afterConnect;\n    req.address = address;\n    req.port = port;\n    req.localAddress = localAddress;\n    req.localPort = localPort;\n\n    // node::TCPConnectWrap isn't instantiated and attached to the JS instance\n    // of TCPConnectWrap above until connect() is called. So don't set the init\n    // trigger id until now.\n    setInitTriggerId(self[async_id_symbol]);\n    if (addressType === 4)\n      err = self._handle.connect(req, address, port);\n    else\n      err = self._handle.connect6(req, address, port);\n\n  } else {\n    const req = new PipeConnectWrap();\n    req.address = address;\n    req.oncomplete = afterConnect;\n    // node::PipeConnectWrap isn't instantiated and attached to the JS instance\n    // of PipeConnectWrap above until connect() is called. So don't set the\n    // init trigger id until now.\n    setInitTriggerId(self[async_id_symbol]);\n    err = self._handle.connect(req, address, afterConnect);\n  }\n\n  if (err) {\n    var sockname = self._getsockname();\n    var details;\n\n    if (sockname) {\n      details = sockname.address + ':' + sockname.port;\n    }\n\n    const ex = exceptionWithHostPort(err, 'connect', address, port, details);\n    self.destroy(ex);\n  }\n}\n\n\nSocket.prototype.connect = function() {\n  let normalized;\n  // If passed an array, it's treated as an array of arguments that have\n  // already been normalized (so we don't normalize more than once). This has\n  // been solved before in https://github.com/nodejs/node/pull/12342, but was\n  // reverted as it had unintended side effects.\n  if (Array.isArray(arguments[0]) && arguments[0][normalizedArgsSymbol]) {\n    normalized = arguments[0];\n  } else {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < arguments.length; i++)\n      args[i] = arguments[i];\n    // TODO(joyeecheung): use destructuring when V8 is fast enough\n    normalized = normalizeArgs(args);\n  }\n  const options = normalized[0];\n  const cb = normalized[1];\n\n  if (this.write !== Socket.prototype.write)\n    this.write = Socket.prototype.write;\n\n  if (this.destroyed) {\n    this._undestroy();\n    this._handle = null;\n    this._peername = null;\n    this._sockname = null;\n  }\n\n  var pipe = !!options.path;\n  debug('pipe', pipe, options.path);\n\n  if (!this._handle) {\n    this._handle = pipe ? new Pipe() : new TCP();\n    initSocketHandle(this);\n  }\n\n  if (cb !== null) {\n    this.once('connect', cb);\n  }\n\n  this._unrefTimer();\n\n  this.connecting = true;\n  this.writable = true;\n\n  if (pipe) {\n    internalConnect(this, options.path);\n  } else {\n    lookupAndConnect(this, options);\n  }\n  return this;\n};\n\n\nfunction lookupAndConnect(self, options) {\n  const dns = lazyDns();\n  var host = options.host || 'localhost';\n  var port = options.port;\n  var localAddress = options.localAddress;\n  var localPort = options.localPort;\n\n  if (localAddress && !cares.isIP(localAddress))\n    throw new TypeError('\"localAddress\" option must be a valid IP: ' +\n                        localAddress);\n\n  if (localPort && typeof localPort !== 'number')\n    throw new TypeError('\"localPort\" option should be a number: ' + localPort);\n\n  if (typeof port !== 'undefined') {\n    if (typeof port !== 'number' && typeof port !== 'string')\n      throw new TypeError('\"port\" option should be a number or string: ' +\n                          port);\n    if (!isLegalPort(port))\n      throw new RangeError('\"port\" option should be >= 0 and < 65536: ' + port);\n  }\n  port |= 0;\n\n  // If host is an IP, skip performing a lookup\n  var addressType = cares.isIP(host);\n  if (addressType) {\n    nextTick(self[async_id_symbol], function() {\n      if (self.connecting)\n        internalConnect(self, host, port, addressType, localAddress, localPort);\n    });\n    return;\n  }\n\n  if (options.lookup && typeof options.lookup !== 'function')\n    throw new TypeError('\"lookup\" option should be a function');\n\n  var dnsopts = {\n    family: options.family,\n    hints: options.hints || 0\n  };\n\n  if (dnsopts.family !== 4 && dnsopts.family !== 6 && dnsopts.hints === 0) {\n    dnsopts.hints = dns.ADDRCONFIG;\n  }\n\n  debug('connect: find host', host);\n  debug('connect: dns options', dnsopts);\n  self._host = host;\n  var lookup = options.lookup || dns.lookup;\n  setInitTriggerId(self[async_id_symbol]);\n  lookup(host, dnsopts, function emitLookup(err, ip, addressType) {\n    self.emit('lookup', err, ip, addressType, host);\n\n    // It's possible we were destroyed while looking this up.\n    // XXX it would be great if we could cancel the promise returned by\n    // the look up.\n    if (!self.connecting) return;\n\n    if (err) {\n      // net.createConnection() creates a net.Socket object and\n      // immediately calls net.Socket.connect() on it (that's us).\n      // There are no event listeners registered yet so defer the\n      // error event to the next tick.\n      err.host = options.host;\n      err.port = options.port;\n      err.message = err.message + ' ' + options.host + ':' + options.port;\n      process.nextTick(connectErrorNT, self, err);\n    } else {\n      self._unrefTimer();\n      internalConnect(self,\n                      ip,\n                      port,\n                      addressType,\n                      localAddress,\n                      localPort);\n    }\n  });\n}\n\n\nfunction connectErrorNT(self, err) {\n  self.destroy(err);\n}\n\n\nSocket.prototype.ref = function() {\n  if (!this._handle) {\n    this.once('connect', this.ref);\n    return this;\n  }\n\n  this._handle.ref();\n\n  return this;\n};\n\n\nSocket.prototype.unref = function() {\n  if (!this._handle) {\n    this.once('connect', this.unref);\n    return this;\n  }\n\n  this._handle.unref();\n\n  return this;\n};\n\n\nfunction afterConnect(status, handle, req, readable, writable) {\n  var self = handle.owner;\n\n  // callback may come after call to destroy\n  if (self.destroyed) {\n    return;\n  }\n\n  // Update handle if it was wrapped\n  // TODO(indutny): assert that the handle is actually an ancestor of old one\n  handle = self._handle;\n\n  debug('afterConnect');\n\n  assert.ok(self.connecting);\n  self.connecting = false;\n  self._sockname = null;\n\n  if (status === 0) {\n    self.readable = readable;\n    self.writable = writable;\n    self._unrefTimer();\n\n    self.emit('connect');\n\n    // start the first read, or get an immediate EOF.\n    // this doesn't actually consume any bytes, because len=0.\n    if (readable && !self.isPaused())\n      self.read(0);\n\n  } else {\n    self.connecting = false;\n    var details;\n    if (req.localAddress && req.localPort) {\n      details = req.localAddress + ':' + req.localPort;\n    }\n    var ex = exceptionWithHostPort(status,\n                                   'connect',\n                                   req.address,\n                                   req.port,\n                                   details);\n    if (details) {\n      ex.localAddress = req.localAddress;\n      ex.localPort = req.localPort;\n    }\n    self.destroy(ex);\n  }\n}\n\n\nfunction Server(options, connectionListener) {\n  if (!(this instanceof Server))\n    return new Server(options, connectionListener);\n\n  EventEmitter.call(this);\n\n  if (typeof options === 'function') {\n    connectionListener = options;\n    options = {};\n    this.on('connection', connectionListener);\n  } else if (options == null || typeof options === 'object') {\n    options = options || {};\n\n    if (typeof connectionListener === 'function') {\n      this.on('connection', connectionListener);\n    }\n  } else {\n    throw new TypeError('options must be an object');\n  }\n\n  this._connections = 0;\n\n  Object.defineProperty(this, 'connections', {\n    get: internalUtil.deprecate(() => {\n\n      if (this._usingSlaves) {\n        return null;\n      }\n      return this._connections;\n    }, 'Server.connections property is deprecated. ' +\n       'Use Server.getConnections method instead.', 'DEP0020'),\n    set: internalUtil.deprecate((val) => (this._connections = val),\n                                'Server.connections property is deprecated.',\n                                'DEP0020'),\n    configurable: true, enumerable: false\n  });\n\n  this[async_id_symbol] = -1;\n  this._handle = null;\n  this._usingSlaves = false;\n  this._slaves = [];\n  this._unref = false;\n\n  this.allowHalfOpen = options.allowHalfOpen || false;\n  this.pauseOnConnect = !!options.pauseOnConnect;\n}\nutil.inherits(Server, EventEmitter);\n\n\nfunction toNumber(x) { return (x = Number(x)) >= 0 ? x : false; }\n\n// Returns handle if it can be created, or error code if it can't\nfunction createServerHandle(address, port, addressType, fd) {\n  var err = 0;\n  // assign handle in listen, and clean up if bind or listen fails\n  var handle;\n\n  var isTCP = false;\n  if (typeof fd === 'number' && fd >= 0) {\n    try {\n      handle = createHandle(fd);\n    } catch (e) {\n      // Not a fd we can listen on.  This will trigger an error.\n      debug('listen invalid fd=%d:', fd, e.message);\n      return uv.UV_EINVAL;\n    }\n    handle.open(fd);\n    handle.readable = true;\n    handle.writable = true;\n    assert(!address && !port);\n  } else if (port === -1 && addressType === -1) {\n    handle = new Pipe();\n    if (process.platform === 'win32') {\n      var instances = parseInt(process.env.NODE_PENDING_PIPE_INSTANCES);\n      if (!isNaN(instances)) {\n        handle.setPendingInstances(instances);\n      }\n    }\n  } else {\n    handle = new TCP();\n    isTCP = true;\n  }\n\n  if (address || port || isTCP) {\n    debug('bind to', address || 'any');\n    if (!address) {\n      // Try binding to ipv6 first\n      err = handle.bind6('::', port);\n      if (err) {\n        handle.close();\n        // Fallback to ipv4\n        return createServerHandle('0.0.0.0', port);\n      }\n    } else if (addressType === 6) {\n      err = handle.bind6(address, port);\n    } else {\n      err = handle.bind(address, port);\n    }\n  }\n\n  if (err) {\n    handle.close();\n    return err;\n  }\n\n  return handle;\n}\n\nfunction setupListenHandle(address, port, addressType, backlog, fd) {\n  debug('setupListenHandle', address, port, addressType, backlog, fd);\n\n  // If there is not yet a handle, we need to create one and bind.\n  // In the case of a server sent via IPC, we don't need to do this.\n  if (this._handle) {\n    debug('setupListenHandle: have a handle already');\n  } else {\n    debug('setupListenHandle: create a handle');\n\n    var rval = null;\n\n    // Try to bind to the unspecified IPv6 address, see if IPv6 is available\n    if (!address && typeof fd !== 'number') {\n      rval = createServerHandle('::', port, 6, fd);\n\n      if (typeof rval === 'number') {\n        rval = null;\n        address = '0.0.0.0';\n        addressType = 4;\n      } else {\n        address = '::';\n        addressType = 6;\n      }\n    }\n\n    if (rval === null)\n      rval = createServerHandle(address, port, addressType, fd);\n\n    if (typeof rval === 'number') {\n      var error = exceptionWithHostPort(rval, 'listen', address, port);\n      process.nextTick(emitErrorNT, this, error);\n      return;\n    }\n    this._handle = rval;\n  }\n\n  this[async_id_symbol] = getNewAsyncId(this._handle);\n  this._handle.onconnection = onconnection;\n  this._handle.owner = this;\n\n  // Use a backlog of 512 entries. We pass 511 to the listen() call because\n  // the kernel does: backlogsize = roundup_pow_of_two(backlogsize + 1);\n  // which will thus give us a backlog of 512 entries.\n  var err = this._handle.listen(backlog || 511);\n\n  if (err) {\n    var ex = exceptionWithHostPort(err, 'listen', address, port);\n    this._handle.close();\n    this._handle = null;\n    nextTick(this[async_id_symbol], emitErrorNT, this, ex);\n    return;\n  }\n\n  // generate connection key, this should be unique to the connection\n  this._connectionKey = addressType + ':' + address + ':' + port;\n\n  // unref the handle if the server was unref'ed prior to listening\n  if (this._unref)\n    this.unref();\n\n  nextTick(this[async_id_symbol], emitListeningNT, this);\n}\n\nServer.prototype._listen2 = setupListenHandle;  // legacy alias\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\n\nfunction emitListeningNT(self) {\n  // ensure handle hasn't closed\n  if (self._handle)\n    self.emit('listening');\n}\n\n\nfunction lazyDns() {\n  if (dns === undefined)\n    dns = require('dns');\n  return dns;\n}\n\n\nfunction listenInCluster(server, address, port, addressType,\n                         backlog, fd, exclusive) {\n  exclusive = !!exclusive;\n\n  if (!cluster) cluster = require('cluster');\n\n  if (cluster.isMaster || exclusive) {\n    // Will create a new handle\n    // _listen2 sets up the listened handle, it is still named like this\n    // to avoid breaking code that wraps this method\n    server._listen2(address, port, addressType, backlog, fd);\n    return;\n  }\n\n  const serverQuery = {\n    address: address,\n    port: port,\n    addressType: addressType,\n    fd: fd,\n    flags: 0\n  };\n\n  // Get the master's server handle, and listen on it\n  cluster._getServer(server, serverQuery, listenOnMasterHandle);\n\n  function listenOnMasterHandle(err, handle) {\n    // EADDRINUSE may not be reported until we call listen(). To complicate\n    // matters, a failed bind() followed by listen() will implicitly bind to\n    // a random port. Ergo, check that the socket is bound to the expected\n    // port before calling listen().\n    //\n    // FIXME(bnoordhuis) Doesn't work for pipe handles, they don't have a\n    // getsockname() method. Non-issue for now, the cluster module doesn't\n    // really support pipes anyway.\n    if (err === 0 && port > 0 && handle.getsockname) {\n      var out = {};\n      err = handle.getsockname(out);\n      if (err === 0 && port !== out.port)\n        err = uv.UV_EADDRINUSE;\n    }\n\n    if (err) {\n      var ex = exceptionWithHostPort(err, 'bind', address, port);\n      return server.emit('error', ex);\n    }\n\n    // Reuse master's server handle\n    server._handle = handle;\n    // _listen2 sets up the listened handle, it is still named like this\n    // to avoid breaking code that wraps this method\n    server._listen2(address, port, addressType, backlog, fd);\n  }\n}\n\n\nServer.prototype.listen = function() {\n  var args = new Array(arguments.length);\n  for (var i = 0; i < arguments.length; i++)\n    args[i] = arguments[i];\n  // TODO(joyeecheung): use destructuring when V8 is fast enough\n  var normalized = normalizeArgs(args);\n  var options = normalized[0];\n  var cb = normalized[1];\n\n  var hasCallback = (cb !== null);\n  if (hasCallback) {\n    this.once('listening', cb);\n  }\n  var backlogFromArgs =\n    // (handle, backlog) or (path, backlog) or (port, backlog)\n    toNumber(args.length > 1 && args[1]) ||\n    toNumber(args.length > 2 && args[2]);  // (port, host, backlog)\n\n  options = options._handle || options.handle || options;\n  // (handle[, backlog][, cb]) where handle is an object with a handle\n  if (options instanceof TCP) {\n    this._handle = options;\n    this[async_id_symbol] = this._handle.getAsyncId();\n    listenInCluster(this, null, -1, -1, backlogFromArgs);\n    return this;\n  }\n  // (handle[, backlog][, cb]) where handle is an object with a fd\n  if (typeof options.fd === 'number' && options.fd >= 0) {\n    listenInCluster(this, null, null, null, backlogFromArgs, options.fd);\n    return this;\n  }\n\n  // ([port][, host][, backlog][, cb]) where port is omitted,\n  // that is, listen() or listen(cb),\n  // or (options[, cb]) where options.port is explicitly set as undefined,\n  // bind to an arbitrary unused port\n  if (args.length === 0 || typeof args[0] === 'function' ||\n    (typeof options.port === 'undefined' && 'port' in options)) {\n    options.port = 0;\n  }\n  // ([port][, host][, backlog][, cb]) where port is specified\n  // or (options[, cb]) where options.port is specified\n  // or if options.port is normalized as 0 before\n  var backlog;\n  if (typeof options.port === 'number' || typeof options.port === 'string') {\n    if (!isLegalPort(options.port)) {\n      throw new RangeError('\"port\" argument must be >= 0 and < 65536');\n    }\n    backlog = options.backlog || backlogFromArgs;\n    // start TCP server listening on host:port\n    if (options.host) {\n      lookupAndListen(this, options.port | 0, options.host, backlog,\n                      options.exclusive);\n    } else { // Undefined host, listens on unspecified address\n      // Default addressType 4 will be used to search for master server\n      listenInCluster(this, null, options.port | 0, 4,\n                      backlog, undefined, options.exclusive);\n    }\n    return this;\n  }\n\n  // (path[, backlog][, cb]) or (options[, cb])\n  // where path or options.path is a UNIX domain socket or Windows pipe\n  if (options.path && isPipeName(options.path)) {\n    var pipeName = this._pipeName = options.path;\n    backlog = options.backlog || backlogFromArgs;\n    listenInCluster(this, pipeName, -1, -1,\n                    backlog, undefined, options.exclusive);\n    return this;\n  }\n\n  throw new Error('Invalid listen argument: ' + util.inspect(options));\n};\n\nfunction lookupAndListen(self, port, address, backlog, exclusive) {\n  const dns = lazyDns();\n  dns.lookup(address, function doListen(err, ip, addressType) {\n    if (err) {\n      self.emit('error', err);\n    } else {\n      addressType = ip ? addressType : 4;\n      listenInCluster(self, ip, port, addressType,\n                      backlog, undefined, exclusive);\n    }\n  });\n}\n\nObject.defineProperty(Server.prototype, 'listening', {\n  get: function() {\n    return !!this._handle;\n  },\n  configurable: true,\n  enumerable: true\n});\n\nServer.prototype.address = function() {\n  if (this._handle && this._handle.getsockname) {\n    var out = {};\n    var err = this._handle.getsockname(out);\n    if (err) {\n      throw errnoException(err, 'address');\n    }\n    return out;\n  } else if (this._pipeName) {\n    return this._pipeName;\n  } else {\n    return null;\n  }\n};\n\nfunction onconnection(err, clientHandle) {\n  var handle = this;\n  var self = handle.owner;\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  var socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen,\n    pauseOnCreate: self.pauseOnConnect\n  });\n  socket.readable = socket.writable = true;\n\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  ;\n  ;\n  self.emit('connection', socket);\n}\n\n\nServer.prototype.getConnections = function(cb) {\n  const self = this;\n\n  function end(err, connections) {\n    nextTick(self[async_id_symbol], cb, err, connections);\n  }\n\n  if (!this._usingSlaves) {\n    return end(null, this._connections);\n  }\n\n  // Poll slaves\n  var left = this._slaves.length;\n  var total = this._connections;\n\n  function oncount(err, count) {\n    if (err) {\n      left = -1;\n      return end(err);\n    }\n\n    total += count;\n    if (--left === 0) return end(null, total);\n  }\n\n  for (var n = 0; n < this._slaves.length; n++) {\n    this._slaves[n].getConnections(oncount);\n  }\n};\n\n\nServer.prototype.close = function(cb) {\n  if (typeof cb === 'function') {\n    if (!this._handle) {\n      this.once('close', function close() {\n        cb(new Error('Not running'));\n      });\n    } else {\n      this.once('close', cb);\n    }\n  }\n\n  if (this._handle) {\n    this._handle.close();\n    this._handle = null;\n  }\n\n  if (this._usingSlaves) {\n    var left = this._slaves.length;\n    const onSlaveClose = () => {\n      if (--left !== 0) return;\n\n      this._connections = 0;\n      this._emitCloseIfDrained();\n    };\n\n    // Increment connections to be sure that, even if all sockets will be closed\n    // during polling of slaves, `close` event will be emitted only once.\n    this._connections++;\n\n    // Poll slaves\n    for (var n = 0; n < this._slaves.length; n++)\n      this._slaves[n].close(onSlaveClose);\n  } else {\n    this._emitCloseIfDrained();\n  }\n\n  return this;\n};\n\nServer.prototype._emitCloseIfDrained = function() {\n  debug('SERVER _emitCloseIfDrained');\n\n  if (this._handle || this._connections) {\n    debug('SERVER handle? %j   connections? %d',\n          !!this._handle, this._connections);\n    return;\n  }\n\n  const asyncId = this._handle ? this[async_id_symbol] : null;\n  nextTick(asyncId, emitCloseNT, this);\n};\n\n\nfunction emitCloseNT(self) {\n  debug('SERVER: emit close');\n  self.emit('close');\n}\n\n\nServer.prototype.listenFD = internalUtil.deprecate(function(fd, type) {\n  return this.listen({ fd: fd });\n}, 'Server.listenFD is deprecated. Use Server.listen({fd: <number>}) instead.',\n                                                   'DEP0021');\n\nServer.prototype._setupSlave = function(socketList) {\n  this._usingSlaves = true;\n  this._slaves.push(socketList);\n};\n\nServer.prototype.ref = function() {\n  this._unref = false;\n\n  if (this._handle)\n    this._handle.ref();\n\n  return this;\n};\n\nServer.prototype.unref = function() {\n  this._unref = true;\n\n  if (this._handle)\n    this._handle.unref();\n\n  return this;\n};\n\nvar _setSimultaneousAccepts;\n\nif (process.platform === 'win32') {\n  var simultaneousAccepts;\n\n  _setSimultaneousAccepts = function(handle) {\n    if (handle === undefined) {\n      return;\n    }\n\n    if (simultaneousAccepts === undefined) {\n      simultaneousAccepts = (process.env.NODE_MANY_ACCEPTS &&\n                             process.env.NODE_MANY_ACCEPTS !== '0');\n    }\n\n    if (handle._simultaneousAccepts !== simultaneousAccepts) {\n      handle.setSimultaneousAccepts(simultaneousAccepts);\n      handle._simultaneousAccepts = simultaneousAccepts;\n    }\n  };\n} else {\n  _setSimultaneousAccepts = function(handle) {};\n}\n\nmodule.exports = {\n  _createServerHandle: createServerHandle,\n  _normalizeArgs: normalizeArgs,\n  _setSimultaneousAccepts,\n  connect,\n  createConnection: connect,\n  createServer,\n  isIP: cares.isIP,\n  isIPv4: cares.isIPv4,\n  isIPv6: cares.isIPv6,\n  Server,\n  Socket,\n  Stream: Socket, // Legacy naming\n};\n\n});"},
    {"fileId":37, "filename":"internal/net.js", "source":"(function (exports, require, module, __filename, __dirname) { 'use strict';\n\n// Check that the port number is not NaN when coerced to a number,\n// is an integer and that it falls within the legal range of port numbers.\nfunction isLegalPort(port) {\n  if ((typeof port !== 'number' && typeof port !== 'string') ||\n      (typeof port === 'string' && port.trim().length === 0))\n    return false;\n  return +port === (+port >>> 0) && port <= 0xFFFF;\n}\n\nmodule.exports = {\n  isLegalPort,\n  normalizedArgsSymbol: Symbol('normalizedArgs')\n};\n\n});"},
    {"fileId":38, "filename":"console.js", "source":"(function (exports, require, module, __filename, __dirname) { // Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst util = require('util');\nconst trace_mgr = require('trace_mgr'); //ENABLE_TTD\n\nfunction Console(stdout, stderr, ignoreErrors = true) {\n  if (!(this instanceof Console)) {\n    return new Console(stdout, stderr, ignoreErrors);\n  }\n  if (!stdout || typeof stdout.write !== 'function') {\n    throw new TypeError('Console expects a writable stream instance');\n  }\n  if (!stderr) {\n    stderr = stdout;\n  } else if (typeof stderr.write !== 'function') {\n    throw new TypeError('Console expects writable stream instances');\n  }\n\n  var prop = {\n    writable: true,\n    enumerable: false,\n    configurable: true\n  };\n  prop.value = stdout;\n  Object.defineProperty(this, '_stdout', prop);\n  prop.value = stderr;\n  Object.defineProperty(this, '_stderr', prop);\n  prop.value = ignoreErrors;\n  Object.defineProperty(this, '_ignoreErrors', prop);\n  prop.value = new Map();\n  Object.defineProperty(this, '_times', prop);\n  prop.value = createWriteErrorHandler(stdout);\n  Object.defineProperty(this, '_stdoutErrorHandler', prop);\n  prop.value = createWriteErrorHandler(stderr);\n  Object.defineProperty(this, '_stderrErrorHandler', prop);\n\n  // bind the prototype functions to this Console instance\n  var keys = Object.keys(Console.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var k = keys[v];\n    this[k] = this[k].bind(this);\n  }\n}\n\n// Make a function that can serve as the callback passed to `stream.write()`.\nfunction createWriteErrorHandler(stream) {\n  return (err) => {\n    // This conditional evaluates to true if and only if there was an error\n    // that was not already emitted (which happens when the _write callback\n    // is invoked asynchronously).\n    if (err && !stream._writableState.errorEmitted) {\n      // If there was an error, it will be emitted on `stream` as\n      // an `error` event. Adding a `once` listener will keep that error\n      // from becoming an uncaught exception, but since the handler is\n      // removed after the event, non-console.* writes won\u9102t be affected.\n      stream.once('error', noop);\n    }\n  };\n}\n\nfunction write(ignoreErrors, stream, string, errorhandler) {\n  if (!ignoreErrors) return stream.write(string);\n\n  // There may be an error occurring synchronously (e.g. for files or TTYs\n  // on POSIX systems) or asynchronously (e.g. pipes on POSIX systems), so\n  // handle both situations.\n  try {\n    // Add and later remove a noop error handler to catch synchronous errors.\n    stream.once('error', noop);\n\n    stream.write(string, errorhandler);\n  } catch (e) {\n    // Sorry, there\u9102s no proper way to pass along the error here.\n  } finally {\n    stream.removeListener('error', noop);\n  }\n}\n\n\n// As of v8 5.0.71.32, the combination of rest param, template string\n// and .apply(null, args) benchmarks consistently faster than using\n// the spread operator when calling util.format.\nConsole.prototype.log = function log(...args) {\n  write(this._ignoreErrors,\n        this._stdout,\n        `${util.format.apply(null, args)}\\n`,\n        this._stdoutErrorHandler);\n};\n\n\nConsole.prototype.info = Console.prototype.log;\n\n\nConsole.prototype.warn = function warn(...args) {\n  write(this._ignoreErrors,\n        this._stderr,\n        `${util.format.apply(null, args)}\\n`,\n        this._stderrErrorHandler);\n\n  trace_mgr.emitTrace('emitOnLogWarn'); //ENABLE_TTD\n};\n\n\nConsole.prototype.error = function error(...args) {\n  write(this._ignoreErrors,\n        this._stderr,\n        `${util.format.apply(null, args)}\\n`,\n        this._stderrErrorHandler);\n\n  trace_mgr.emitTrace('emitOnLogError'); //ENABLE_TTD\n};\n\nConsole.prototype.dir = function dir(object, options) {\n  options = Object.assign({customInspect: false}, options);\n  write(this._ignoreErrors,\n        this._stdout,\n        `${util.inspect(object, options)}\\n`,\n        this._stdoutErrorHandler);\n};\n\n\nConsole.prototype.time = function time(label) {\n  this._times.set(label, process.hrtime());\n};\n\n\nConsole.prototype.timeEnd = function timeEnd(label) {\n  const time = this._times.get(label);\n  if (!time) {\n    process.emitWarning(`No such label '${label}' for console.timeEnd()`);\n    return;\n  }\n  const duration = process.hrtime(time);\n  const ms = duration[0] * 1000 + duration[1] / 1e6;\n  this.log('%s: %sms', label, ms.toFixed(3));\n  this._times.delete(label);\n};\n\n\nConsole.prototype.trace = function trace(...args) {\n  // TODO probably can to do this better with V8's debug object once that is\n  // exposed.\n  var err = new Error();\n  err.name = 'Trace';\n  err.message = util.format.apply(null, args);\n  Error.captureStackTrace(err, trace);\n  this.error(err.stack);\n};\n\n\nConsole.prototype.assert = function assert(expression, ...args) {\n  if (!expression) {\n    require('assert').ok(false, util.format.apply(null, args));\n  }\n};\n\n\nmodule.exports = new Console(process.stdout, process.stderr);\nmodule.exports.Console = Console;\n\nfunction noop() {}\n\n});"}]}